local style = require "core.style"
local common = require "core.common"

style.background = { common.color "#2e2e32" }  -- Docview
style.background2 = { common.color "#252529" } -- Treeview
style.background3 = { common.color "#252529" } -- Command view
style.text = { common.color "#97979c" }
style.caret = { common.color "#93DDFA" }
style.accent = { common.color "#e1e1e6" }
-- style.dim - text color for nonactive tabs, tabs divider, prefix in log and
-- search result, hotkeys for context menu and command view
style.dim = { common.color "#525257" }
style.divider = { common.color "#202024" } -- Line between nodes
style.selection = { common.color "#48484f" }
style.line_number = { common.color "#525259" }
style.line_number2 = { common.color "#83838f" } -- With cursor
style.line_highlight = { common.color "#343438" }
style.scrollbar = { common.color "#414146" }
style.scrollbar2 = { common.color "#4b4b52" } -- Hovered
style.scrollbar_track = { common.color "#252529" }
style.nagbar = { common.color "#FF0000" }
style.nagbar_text = { common.color "#FFFFFF" }
style.nagbar_dim = { common.color "rgba(0, 0, 0, 0.45)" }
style.drag_overlay = { common.color "rgba(255,255,255,0.1)" }
style.drag_overlay_tab = { common.color "#93DDFA" }
style.good = { common.color "#72b886" }
style.warn = { common.color "#FFA94D" }
style.error = { common.color "#FF3333" }
style.modified = { common.color "#1c7c9c" }

style.syntax["normal"] = { common.color "#e1e1e6" }
style.syntax["symbol"] = { common.color "#e1e1e6" }
style.syntax["comment"] = { common.color "#676b6f" }
style.syntax["keyword"] = { common.color "#E58AC9" }  -- local function end if case
style.syntax["keyword2"] = { common.color "#F77483" } -- self int float
style.syntax["number"] = { common.color "#FFA94D" }
style.syntax["literal"] = { common.color "#FFA94D" }  -- true false nil
style.syntax["string"] = { common.color "#f7c95c" }
style.syntax["operator"] = { common.color "#93DDFA" } -- = + - / < >
style.syntax["function"] = { common.color "#93DDFA" }

style.log["INFO"]  = { icon = "i", color = style.text }
style.log["WARN"]  = { icon = "!", color = style.warn }
style.log["ERROR"] = { icon = "!", color = style.error }

return style
local style = require "core.style"
local common = require "core.common"

style.background = { common.color "#343233" }
style.background2 = { common.color "#2c2a2b" }
style.background3 = { common.color "#2c2a2b" }
style.text = { common.color "#c4b398" }
style.caret = { common.color "#61efce" }
style.accent = { common.color "#ffd152" }
style.dim = { common.color "#615d5f" }
style.divider = { common.color "#242223" }
style.selection = { common.color "#454244" }
style.line_number = { common.color "#454244" }
style.line_number2 = { common.color "#615d5f" }
style.line_highlight = { common.color "#383637" }
style.scrollbar = { common.color "#454344" }
style.scrollbar2 = { common.color "#524F50" }

style.syntax["normal"] = { common.color "#efdab9" }
style.syntax["symbol"] = { common.color "#efdab9" }
style.syntax["comment"] = { common.color "#615d5f" }
style.syntax["keyword"] = { common.color "#d36e2d" }
style.syntax["keyword2"] = { common.color "#ef6179" }
style.syntax["number"] = { common.color "#ffd152" }
style.syntax["literal"] = { common.color "#ffd152" }
style.syntax["string"] = { common.color "#ffd152" }
style.syntax["operator"] = { common.color "#efdab9" }
style.syntax["function"] = { common.color "#61efce" }
local style = require "core.style"
local common = require "core.common"

style.background = { common.color "#fbfbfb" }
style.background2 = { common.color "#f2f2f2" }
style.background3 = { common.color "#f2f2f2" }
style.text = { common.color "#404040" }
style.caret = { common.color "#fc1785" }
style.accent = { common.color "#fc1785" }
style.dim = { common.color "#b0b0b0" }
style.divider = { common.color "#e8e8e8" }
style.selection = { common.color "#b7dce8" }
style.line_number = { common.color "#d0d0d0" }
style.line_number2 = { common.color "#808080" }
style.line_highlight = { common.color "#f2f2f2" }
style.scrollbar = { common.color "#e0e0e0" }
style.scrollbar2 = { common.color "#c0c0c0" }

style.syntax["normal"] = { common.color "#181818" }
style.syntax["symbol"] = { common.color "#181818" }
style.syntax["comment"] = { common.color "#22a21f" }
style.syntax["keyword"] = { common.color "#fb6620" }
style.syntax["keyword2"] = { common.color "#fc1785" }
style.syntax["number"] = { common.color "#1586d2" }
style.syntax["literal"] = { common.color "#1586d2" }
style.syntax["string"] = { common.color "#1586d2" }
style.syntax["operator"] = { common.color "#fb6620" }
style.syntax["function"] = { common.color "#fc1785" }
local b05 = 'rgba(0,0,0,0.5)'   local red = '#994D4D'
local b80 = '#333333'       local orange  = '#B3661A'
local b60 = '#808080'       local green   = '#52994D'
local b40 = '#ADADAD'       local teal    = '#4D9999'
local b20 = '#CECECE'       local blue    = '#1A66B3'
local b00 = '#E6E6E6'       local magenta = '#994D99'
--------------------------=--------------------------
local style               =     require  'core.style'
local common              =     require 'core.common'
--------------------------=--------------------------
style.line_highlight      =     { common.color(b20) }
style.background          =     { common.color(b00) }
style.background2         =     { common.color(b20) }
style.background3         =     { common.color(b20) }
style.text                =     { common.color(b60) }
style.caret               =     { common.color(b80) }
style.accent              =     { common.color(b80) }
style.dim                 =     { common.color(b60) }
style.divider             =     { common.color(b40) }
style.selection           =     { common.color(b40) }
style.line_number         =     { common.color(b60) }
style.line_number2        =     { common.color(b80) }
style.scrollbar           =     { common.color(b40) }
style.scrollbar2          =     { common.color(b60) }
style.nagbar              =     { common.color(red) }
style.nagbar_text         =     { common.color(b00) }
style.nagbar_dim          =     { common.color(b05) }
--------------------------=--------------------------
style.syntax              =                        {}
style.syntax['normal']    =     { common.color(b80) }
style.syntax['symbol']    =     { common.color(b80) }
style.syntax['comment']   =     { common.color(b60) }
style.syntax['keyword']   =    { common.color(blue) }
style.syntax['keyword2']  =     { common.color(red) }
style.syntax['number']    =    { common.color(teal) }
style.syntax['literal']   =    { common.color(blue) }
style.syntax['string']    =   { common.color(green) }
style.syntax['operator']  = { common.color(magenta) }
style.syntax['function']  =    { common.color(blue) }
--------------------------=--------------------------
style.syntax.paren1       = { common.color(magenta) }
style.syntax.paren2       =  { common.color(orange) }
style.syntax.paren3       =    { common.color(teal) }
style.syntax.paren4       =    { common.color(blue) }
style.syntax.paren5       =     { common.color(red) }
--------------------------=--------------------------
style.lint                =                        {}
style.lint.info           =    { common.color(blue) }
style.lint.hint           =   { common.color(green) }
style.lint.warning        =     { common.color(red) }
style.lint.error          =  { common.color(orange) }
local bit = {}

local LUA_NBITS = 32
local ALLONES = (~(((~0) << (LUA_NBITS - 1)) << 1))

local function trim(x)
	return (x & ALLONES)
end

local function mask(n)
	return (~((ALLONES << 1) << ((n) - 1)))
end

local function check_args(field, width)
	assert(field >= 0, "field cannot be negative")
	assert(width > 0, "width must be positive")
	assert(field + width < LUA_NBITS and field + width >= 0,
	       "trying to access non-existent bits")
end

function bit.extract(n, field, width)
	local w = width or 1
	check_args(field, w)
	local m = trim(n)
	return m >> field & mask(w)
end

function bit.replace(n, v, field, width)
	local w = width or 1
	check_args(field, w)
	local m = trim(n)
	local x = v & mask(width);
	return m & ~(mask(w) << field) | (x << field)
end

return bit
local core = require "core"
local command = {}

command.map = {}

local always_true = function() return true end


---Used iternally by command.add, statusview, and contextmenu to generate a
---function with a condition to evaluate returning the boolean result of this
---evaluation.
---
---If a string predicate is given it is treated as a require import that should
---return a valid object which is checked against the current active view,
---eg: "core.docview" will match any view that inherits from DocView. Appending
---a `!` at the end of the string means we want to match the given object
---from the import strcitly eg: "core.docview!" only DocView is matched.
---A function that returns a boolean can be used instead to perform a custom
---evaluation, setting to nil means always evaluates to true.
---
---@param predicate string | table | function
---@return function
function command.generate_predicate(predicate)
  predicate = predicate or always_true
  local strict = false
  if type(predicate) == "string" then
    if predicate:match("!$") then
      strict = true
      predicate = predicate:gsub("!$", "")
    end
    predicate = require(predicate)
  end
  if type(predicate) == "table" then
    local class = predicate
    if not strict then
      predicate = function(...) return core.active_view:extends(class), core.active_view, ... end
    else
      predicate = function(...) return core.active_view:is(class), core.active_view, ... end
    end
  end
  return predicate
end


function command.add(predicate, map)
  predicate = command.generate_predicate(predicate)
  for name, fn in pairs(map) do
    if command.map[name] then
      core.log_quiet("Replacing existing command \"%s\"", name)
    end
    command.map[name] = { predicate = predicate, perform = fn }
  end
end


local function capitalize_first(str)
  return str:sub(1, 1):upper() .. str:sub(2)
end

function command.prettify_name(name)
  return name:gsub(":", ": "):gsub("-", " "):gsub("%S+", capitalize_first)
end


function command.get_all_valid()
  local res = {}
  local memoized_predicates = {}
  for name, cmd in pairs(command.map) do
    if memoized_predicates[cmd.predicate] == nil then
      memoized_predicates[cmd.predicate] = cmd.predicate()
    end
    if memoized_predicates[cmd.predicate] then
      table.insert(res, name)
    end
  end
  return res
end

function command.is_valid(name, ...)
  return command.map[name] and command.map[name].predicate(...)
end

local function perform(name, ...)
  local cmd = command.map[name]
  if not cmd then return false end
  local res = { cmd.predicate(...) }
  if table.remove(res, 1) then
    if #res > 0 then
      -- send values returned from predicate
      cmd.perform(table.unpack(res))
    else
      -- send original parameters
      cmd.perform(...)
    end
    return true
  end
  return false
end


function command.perform(...)
  local ok, res = core.try(perform, ...)
  return not ok or res
end


function command.add_defaults()
  local reg = {
    "core", "root", "command", "doc", "findreplace",
    "files", "drawwhitespace", "dialog", "log", "statusbar"
  }
  for _, name in ipairs(reg) do
    require("core.commands." .. name)
  end
end


return command
local core = require "core"
local command = require "core.command"

command.add("core.commandview", {
  ["command:submit"] = function(active_view)
    active_view:submit()
  end,

  ["command:complete"] = function(active_view)
    active_view:complete()
  end,

  ["command:escape"] = function(active_view)
    active_view:exit()
  end,

  ["command:select-previous"] = function(active_view)
    active_view:move_suggestion_idx(1)
  end,

  ["command:select-next"] = function(active_view)
    active_view:move_suggestion_idx(-1)
  end,
})
local core = require "core"
local common = require "core.common"
local command = require "core.command"
local keymap = require "core.keymap"
local LogView = require "core.logview"


local fullscreen = false
local restore_title_view = false

local function suggest_directory(text)
  text = common.home_expand(text)
  local basedir = common.dirname(core.project_dir)
  return common.home_encode_list((basedir and text == basedir .. PATHSEP or text == "") and
    core.recent_projects or common.dir_path_suggest(text))
end

local function check_directory_path(path)
    local abs_path = system.absolute_path(path)
    local info = abs_path and system.get_file_info(abs_path)
    if not info or info.type ~= 'dir' then
      return nil
    end
    return abs_path
end

command.add(nil, {
  ["core:quit"] = function()
    core.quit()
  end,

  ["core:restart"] = function()
    core.restart()
  end,

  ["core:force-quit"] = function()
    core.quit(true)
  end,

  ["core:toggle-fullscreen"] = function()
    fullscreen = not fullscreen
    if fullscreen then
      restore_title_view = core.title_view.visible
    end
    system.set_window_mode(fullscreen and "fullscreen" or "normal")
    core.show_title_bar(not fullscreen and restore_title_view)
    core.title_view:configure_hit_test(not fullscreen and restore_title_view)
  end,

  ["core:reload-module"] = function()
    core.command_view:enter("Reload Module", {
      submit = function(text, item)
        local text = item and item.text or text
        core.reload_module(text)
        core.log("Reloaded module %q", text)
      end,
      suggest = function(text)
        local items = {}
        for name in pairs(package.loaded) do
          table.insert(items, name)
        end
        return common.fuzzy_match(items, text)
      end
    })
  end,

  ["core:find-command"] = function()
    local commands = command.get_all_valid()
    core.command_view:enter("Do Command", {
      submit = function(text, item)
        if item then
          command.perform(item.command)
        end
      end,
      suggest = function(text)
        local res = common.fuzzy_match(commands, text)
        for i, name in ipairs(res) do
          res[i] = {
            text = command.prettify_name(name),
            info = keymap.get_binding(name),
            command = name,
          }
        end
        return res
      end
    })
  end,

  ["core:find-file"] = function()
    if not core.project_files_number() then
       return command.perform "core:open-file"
    end
    local files = {}
    for dir, item in core.get_project_files() do
      if item.type == "file" then
        local path = (dir == core.project_dir and "" or dir .. PATHSEP)
        table.insert(files, common.home_encode(path .. item.filename))
      end
    end
    core.command_view:enter("Open File From Project", {
      submit = function(text, item)
        text = item and item.text or text
        core.root_view:open_doc(core.open_doc(common.home_expand(text)))
      end,
      suggest = function(text)
        return common.fuzzy_match_with_recents(files, core.visited_files, text)
      end
    })
  end,

  ["core:new-doc"] = function()
    core.root_view:open_doc(core.open_doc())
  end,

  ["core:new-named-doc"] = function()
    core.command_view:enter("File name", {
      submit = function(text)
        core.root_view:open_doc(core.open_doc(text))
      end
    })
  end,

  ["core:open-file"] = function()
    local view = core.active_view
    local text
    if view.doc and view.doc.abs_filename then
      local dirname, filename = view.doc.abs_filename:match("(.*)[/\\](.+)$")
      if dirname then
        dirname = core.normalize_to_project_dir(dirname)
        text = dirname == core.project_dir and "" or common.home_encode(dirname) .. PATHSEP
      end
    end
    core.command_view:enter("Open File", {
      text = text,
      submit = function(text)
        local filename = system.absolute_path(common.home_expand(text))
        core.root_view:open_doc(core.open_doc(filename))
      end,
      suggest = function (text)
          return common.home_encode_list(common.path_suggest(common.home_expand(text)))
        end,
      validate = function(text)
          local filename = common.home_expand(text)
          local path_stat, err = system.get_file_info(filename)
          if err then
            if err:find("No such file", 1, true) then
              -- check if the containing directory exists
              local dirname = common.dirname(filename)
              local dir_stat = dirname and system.get_file_info(dirname)
              if not dirname or (dir_stat and dir_stat.type == 'dir') then
                return true
              end
            end
            core.error("Cannot open file %s: %s", text, err)
          elseif path_stat.type == 'dir' then
            core.error("Cannot open %s, is a folder", text)
          else
            return true
          end
        end,
    })
  end,

  ["core:open-log"] = function()
    local node = core.root_view:get_active_node_default()
    node:add_view(LogView())
  end,

  ["core:open-user-module"] = function()
    local user_module_doc = core.open_doc(USERDIR .. "/init.lua")
    if not user_module_doc then return end
    core.root_view:open_doc(user_module_doc)
  end,

  ["core:open-project-module"] = function()
    if not system.get_file_info(".lite_project.lua") then
      core.try(core.write_init_project_module, ".lite_project.lua")
    end
    local doc = core.open_doc(".lite_project.lua")
    core.root_view:open_doc(doc)
    doc:save()
  end,

  ["core:change-project-folder"] = function()
    local dirname = common.dirname(core.project_dir)
    local text
    if dirname then
      text = common.home_encode(dirname) .. PATHSEP
    end
    core.command_view:enter("Change Project Folder", {
      text = text,
      submit = function(text)
        local path = common.home_expand(text)
        local abs_path = check_directory_path(path)
        if not abs_path then
          core.error("Cannot open directory %q", path)
          return
        end
        if abs_path == core.project_dir then return end
        core.confirm_close_docs(core.docs, function(dirpath)
          core.open_folder_project(dirpath)
        end, abs_path)
      end,
      suggest = suggest_directory
    })
  end,

  ["core:open-project-folder"] = function()
    local dirname = common.dirname(core.project_dir)
    local text
    if dirname then
      text = common.home_encode(dirname) .. PATHSEP
    end
    core.command_view:enter("Open Project", {
      text = text,
      submit = function(text)
        local path = common.home_expand(text)
        local abs_path = check_directory_path(path)
        if not abs_path then
          core.error("Cannot open directory %q", path)
          return
        end
        if abs_path == core.project_dir then
          core.error("Directory %q is currently opened", abs_path)
          return
        end
        system.exec(string.format("%q %q", EXEFILE, abs_path))
      end,
      suggest = suggest_directory
    })
  end,

  ["core:add-directory"] = function()
    core.command_view:enter("Add Directory", {
      submit = function(text)
        text = common.home_expand(text)
        local path_stat, err = system.get_file_info(text)
        if not path_stat then
          core.error("cannot open %q: %s", text, err)
          return
        elseif path_stat.type ~= 'dir' then
          core.error("%q is not a directory", text)
          return
        end
        core.add_project_directory(system.absolute_path(text))
      end,
      suggest = suggest_directory
    })
  end,

  ["core:remove-directory"] = function()
    local dir_list = {}
    local n = #core.project_directories
    for i = n, 2, -1 do
      dir_list[n - i + 1] = core.project_directories[i].name
    end
    core.command_view:enter("Remove Directory", {
      submit = function(text, item)
        text = common.home_expand(item and item.text or text)
        if not core.remove_project_directory(text) then
          core.error("No directory %q to be removed", text)
        end
      end,
      suggest = function(text)
        text = common.home_expand(text)
        return common.home_encode_list(common.dir_list_suggest(text, dir_list))
      end
    })
  end,
})
local core = require "core"
local command = require "core.command"
local common = require "core.common"

command.add("core.nagview", {
  ["dialog:previous-entry"] = function(v)
    local hover = v.hovered_item or 1
    v:change_hovered(hover == 1 and #v.options or hover - 1)
  end,
  ["dialog:next-entry"] = function(v)
    local hover = v.hovered_item or 1
    v:change_hovered(hover == #v.options and 1 or hover + 1)
  end,
  ["dialog:select-yes"] = function(v)
    if v ~= core.nag_view then return end
    v:change_hovered(common.find_index(v.options, "default_yes"))
    command.perform "dialog:select"
  end,
  ["dialog:select-no"] = function(v)
    if v ~= core.nag_view then return end
    v:change_hovered(common.find_index(v.options, "default_no"))
    command.perform "dialog:select"
  end,
  ["dialog:select"] = function(v)
    if v.hovered_item then
      v.on_selected(v.options[v.hovered_item])
      v:next()
    end
  end
})
local core = require "core"
local command = require "core.command"
local common = require "core.common"
local config = require "core.config"
local translate = require "core.doc.translate"
local style = require "core.style"
local DocView = require "core.docview"
local tokenizer = require "core.tokenizer"


local function doc()
  return core.active_view.doc
end


local function doc_multiline_selections(sort)
  local iter, state, idx, line1, col1, line2, col2 = doc():get_selections(sort)
  return function()
    idx, line1, col1, line2, col2 = iter(state, idx)
    if idx and line2 > line1 and col2 == 1 then
      line2 = line2 - 1
      col2 = #doc().lines[line2]
    end
    return idx, line1, col1, line2, col2
  end
end

local function append_line_if_last_line(line)
  if line >= #doc().lines then
    doc():insert(line, math.huge, "\n")
  end
end

local function save(filename)
  local abs_filename
  if filename then
    filename = core.normalize_to_project_dir(filename)
    abs_filename = core.project_absolute_path(filename)
  end
  local ok, err = pcall(doc().save, doc(), filename, abs_filename)
  if ok then
    local saved_filename = doc().filename
    core.log("Saved \"%s\"", saved_filename)
  else
    core.error(err)
    core.nag_view:show("Saving failed", string.format("Could not save \"%s\" do you want to save to another location?", doc().filename), {
      { font = style.font, text = "No", default_no = true },
      { font = style.font, text = "Yes" , default_yes = true }
    }, function(item)
      if item.text == "Yes" then
        core.add_thread(function()
          -- we need to run this in a thread because of the odd way the nagview is.
          command.perform("doc:save-as")
        end)
      end
    end)
  end
end

local function cut_or_copy(delete)
  local full_text = ""
  local text = ""
  core.cursor_clipboard = {}
  core.cursor_clipboard_whole_line = {}
  for idx, line1, col1, line2, col2 in doc():get_selections() do
    if line1 ~= line2 or col1 ~= col2 then
      text = doc():get_text(line1, col1, line2, col2)
      full_text = full_text == "" and text or (full_text .. " " .. text)
      core.cursor_clipboard_whole_line[idx] = false
      if delete then
        doc():delete_to_cursor(idx, 0)
      end
    else -- Cut/copy whole line
      -- Remove newline from the text. It will be added as needed on paste.
      text = string.sub(doc().lines[line1], 1, -2)
      full_text = full_text == "" and text or (full_text .. text .. "\n")
      core.cursor_clipboard_whole_line[idx] = true
      if delete then
        if line1 < #doc().lines then
          doc():remove(line1, 1, line1 + 1, 1)
        elseif #doc().lines == 1 then
          doc():remove(line1, 1, line1, math.huge)
        else
          doc():remove(line1 - 1, math.huge, line1, math.huge)
        end
      end
    end
    core.cursor_clipboard[idx] = text
  end
  core.cursor_clipboard["full"] = full_text
  system.set_clipboard(full_text)
end

local function split_cursor(direction)
  local new_cursors = {}
  for _, line1, col1 in doc():get_selections() do
    if line1 + direction >= 1 and line1 + direction <= #doc().lines then
      table.insert(new_cursors, { line1 + direction, col1 })
    end
  end
  -- add selections in the order that will leave the "last" added one as doc.last_selection
  local start, stop = 1, #new_cursors
  if direction < 0 then
    start, stop = #new_cursors, 1
  end
  for i = start, stop, direction do
    local v = new_cursors[i]
    doc():add_selection(v[1], v[2])
  end
  core.blink_reset()
end

local function set_cursor(dv, x, y, snap_type)
  local line, col = dv:resolve_screen_position(x, y)
  dv.doc:set_selection(line, col, line, col)
  if snap_type == "word" or snap_type == "lines" then
    command.perform("doc:select-" .. snap_type)
  end
  dv.mouse_selecting = { line, col, snap_type }
  core.blink_reset()
end

local function line_comment(comment, line1, col1, line2, col2)
  local start_comment = (type(comment) == 'table' and comment[1] or comment) .. " "
  local end_comment = (type(comment) == 'table' and " " .. comment[2])
  local uncomment = true
  local start_offset = math.huge
  for line = line1, line2 do
    local text = doc().lines[line]
    local s = text:find("%S")
    if s then
      local cs, ce = text:find(start_comment, s, true)
      if cs ~= s then
        uncomment = false
      end
      start_offset = math.min(start_offset, s)
    end
  end

  local end_line = col2 == #doc().lines[line2]
  for line = line1, line2 do
    local text = doc().lines[line]
    local s = text:find("%S")
    if s and uncomment then
      if end_comment and text:sub(#text - #end_comment, #text - 1) == end_comment then
        doc():remove(line, #text - #end_comment, line, #text)
      end
      local cs, ce = text:find(start_comment, s, true)
      if ce then
        doc():remove(line, cs, line, ce + 1)
      end
    elseif s then
      doc():insert(line, start_offset, start_comment)
      if end_comment then
        doc():insert(line, #doc().lines[line], " " .. comment[2])
      end
    end
  end
  col1 = col1 + (col1 > start_offset and #start_comment or 0) * (uncomment and -1 or 1)
  col2 = col2 + (col2 > start_offset and #start_comment or 0) * (uncomment and -1 or 1)
  if end_comment and end_line then
    col2 = col2 + #end_comment * (uncomment and -1 or 1)
  end
  return line1, col1, line2, col2
end

local function block_comment(comment, line1, col1, line2, col2)
  -- automatically skip spaces
  local word_start = doc():get_text(line1, col1, line1, math.huge):find("%S")
  local word_end = doc():get_text(line2, 1, line2, col2):find("%s*$")
  col1 = col1 + (word_start and (word_start - 1) or 0)
  col2 = word_end and word_end or col2

  local block_start = doc():get_text(line1, col1, line1, col1 + #comment[1])
  local block_end = doc():get_text(line2, col2 - #comment[2], line2, col2)

  if block_start == comment[1] and block_end == comment[2] then
    -- remove up to 1 whitespace after the comment
    local start_len, stop_len = #comment[1], #comment[2]
    if doc():get_text(line1, col1 + #comment[1], line1, col1 + #comment[1] + 1):find("%s$") then
      start_len = start_len + 1
    end
    if doc():get_text(line2, col2 - #comment[2] - 1, line2, col2):find("^%s") then
      stop_len = stop_len + 1
    end

    doc():remove(line1, col1, line1, col1 + start_len)
    col2 = col2 - (line1 == line2 and start_len or 0)
    doc():remove(line2, col2 - stop_len, line2, col2)

    return line1, col1, line2, col2 - stop_len
  else
    doc():insert(line1, col1, comment[1] .. " ")
    col2 = col2 + (line1 == line2 and (#comment[1] + 1) or 0)
    doc():insert(line2, col2, " " .. comment[2])

    return line1, col1, line2, col2 + #comment[2] + 1
  end
end

local function insert_paste(doc, value, whole_line, idx)
  if whole_line then
    local line1, col1 = doc:get_selection_idx(idx)
    doc:insert(line1, 1, value:gsub("\r", "").."\n")
    -- Because we're inserting at the start of the line,
    -- if the cursor is in the middle of the line
    -- it gets carried to the next line along with the old text.
    -- If it's at the start of the line it doesn't get carried,
    -- so we move it of as many characters as we're adding.
    if col1 == 1 then
      doc:move_to_cursor(idx, #value+1)
    end
  else
    doc:text_input(value:gsub("\r", ""), idx)
  end
end

local commands = {
  ["doc:select-none"] = function(dv)
    local l1, c1 = dv.doc:get_selection_idx(dv.doc.last_selection)
    if not l1 then
      l1, c1 = dv.doc:get_selection_idx(1)
    end
    dv.doc:set_selection(l1, c1)
  end,

  ["doc:cut"] = function()
    cut_or_copy(true)
  end,

  ["doc:copy"] = function()
    cut_or_copy(false)
  end,

  ["doc:undo"] = function(dv)
    dv.doc:undo()
  end,

  ["doc:redo"] = function(dv)
    dv.doc:redo()
  end,

  ["doc:paste"] = function(dv)
    local clipboard = system.get_clipboard()
    -- If the clipboard has changed since our last look, use that instead
    if core.cursor_clipboard["full"] ~= clipboard then
      core.cursor_clipboard = {}
      core.cursor_clipboard_whole_line = {}
      for idx in dv.doc:get_selections() do
        insert_paste(dv.doc, clipboard, false, idx)
      end
      return
    end
    -- Use internal clipboard(s)
    -- If there are mixed whole lines and normal lines, consider them all as normal
    local only_whole_lines = true
    for _,whole_line in pairs(core.cursor_clipboard_whole_line) do
      if not whole_line then
        only_whole_lines = false
        break
      end
    end
    if #core.cursor_clipboard_whole_line == (#dv.doc.selections/4) then
    -- If we have the same number of clipboards and selections,
    -- paste each clipboard into its corresponding selection
      for idx in dv.doc:get_selections() do
        insert_paste(dv.doc, core.cursor_clipboard[idx], only_whole_lines, idx)
      end
    else
      -- Paste every clipboard and add a selection at the end of each one
      local new_selections = {}
      for idx in dv.doc:get_selections() do
        for cb_idx in ipairs(core.cursor_clipboard_whole_line) do
          insert_paste(dv.doc, core.cursor_clipboard[cb_idx], only_whole_lines, idx)
          if not only_whole_lines then
            table.insert(new_selections, {dv.doc:get_selection_idx(idx)})
          end
        end
        if only_whole_lines then
          table.insert(new_selections, {dv.doc:get_selection_idx(idx)})
        end
      end
      local first = true
      for _,selection in pairs(new_selections) do
        if first then
          dv.doc:set_selection(table.unpack(selection))
          first = false
        else
          dv.doc:add_selection(table.unpack(selection))
        end
      end
    end
  end,

  ["doc:newline"] = function(dv)
    for idx, line, col in dv.doc:get_selections(false, true) do
      local indent = dv.doc.lines[line]:match("^[\t ]*")
      if col <= #indent then
        indent = indent:sub(#indent + 2 - col)
      end
      -- Remove current line if it contains only whitespace
      if not config.keep_newline_whitespace and dv.doc.lines[line]:match("^%s+$") then
        dv.doc:remove(line, 1, line, math.huge)
      end
      dv.doc:text_input("\n" .. indent, idx)
    end
  end,

  ["doc:newline-below"] = function(dv)
    for idx, line in dv.doc:get_selections(false, true) do
      local indent = dv.doc.lines[line]:match("^[\t ]*")
      dv.doc:insert(line, math.huge, "\n" .. indent)
      dv.doc:set_selections(idx, line + 1, math.huge)
    end
  end,

  ["doc:newline-above"] = function(dv)
    for idx, line in dv.doc:get_selections(false, true) do
      local indent = dv.doc.lines[line]:match("^[\t ]*")
      dv.doc:insert(line, 1, indent .. "\n")
      dv.doc:set_selections(idx, line, math.huge)
    end
  end,

  ["doc:delete"] = function(dv)
    for idx, line1, col1, line2, col2 in dv.doc:get_selections() do
      if line1 == line2 and col1 == col2 and dv.doc.lines[line1]:find("^%s*$", col1) then
        dv.doc:remove(line1, col1, line1, math.huge)
      end
      dv.doc:delete_to_cursor(idx, translate.next_char)
    end
  end,

  ["doc:backspace"] = function(dv)
    local _, indent_size = dv.doc:get_indent_info()
    for idx, line1, col1, line2, col2 in dv.doc:get_selections() do
      if line1 == line2 and col1 == col2 then
        local text = dv.doc:get_text(line1, 1, line1, col1)
        if #text >= indent_size and text:find("^ *$") then
          dv.doc:delete_to_cursor(idx, 0, -indent_size)
          return
        end
      end
      dv.doc:delete_to_cursor(idx, translate.previous_char)
    end
  end,

  ["doc:select-all"] = function(dv)
    dv.doc:set_selection(1, 1, math.huge, math.huge)
    -- avoid triggering DocView:scroll_to_make_visible
    dv.last_line1 = 1
    dv.last_col1 = 1
    dv.last_line2 = #dv.doc.lines
    dv.last_col2 = #dv.doc.lines[#dv.doc.lines]
  end,

  ["doc:select-lines"] = function(dv)
    for idx, line1, _, line2 in dv.doc:get_selections(true) do
      append_line_if_last_line(line2)
      dv.doc:set_selections(idx, line1, 1, line2 + 1, 1)
    end
  end,

  ["doc:select-word"] = function(dv)
    for idx, line1, col1 in dv.doc:get_selections(true) do
      local line1, col1 = translate.start_of_word(dv.doc, line1, col1)
      local line2, col2 = translate.end_of_word(dv.doc, line1, col1)
      dv.doc:set_selections(idx, line2, col2, line1, col1)
    end
  end,

  ["doc:join-lines"] = function(dv)
    for idx, line1, col1, line2, col2 in dv.doc:get_selections(true) do
      if line1 == line2 then line2 = line2 + 1 end
      local text = dv.doc:get_text(line1, 1, line2, math.huge)
      text = text:gsub("(.-)\n[\t ]*", function(x)
        return x:find("^%s*$") and x or x .. " "
      end)
      dv.doc:insert(line1, 1, text)
      dv.doc:remove(line1, #text + 1, line2, math.huge)
      if line1 ~= line2 or col1 ~= col2 then
        dv.doc:set_selections(idx, line1, math.huge)
      end
    end
  end,

  ["doc:indent"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      local l1, c1, l2, c2 = dv.doc:indent_text(false, line1, col1, line2, col2)
      if l1 then
        dv.doc:set_selections(idx, l1, c1, l2, c2)
      end
    end
  end,

  ["doc:unindent"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      local l1, c1, l2, c2 = dv.doc:indent_text(true, line1, col1, line2, col2)
      if l1 then
        dv.doc:set_selections(idx, l1, c1, l2, c2)
      end
    end
  end,

  ["doc:duplicate-lines"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      append_line_if_last_line(line2)
      local text = doc():get_text(line1, 1, line2 + 1, 1)
      dv.doc:insert(line2 + 1, 1, text)
      local n = line2 - line1 + 1
      dv.doc:set_selections(idx, line1 + n, col1, line2 + n, col2)
    end
  end,

  ["doc:delete-lines"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      append_line_if_last_line(line2)
      dv.doc:remove(line1, 1, line2 + 1, 1)
      dv.doc:set_selections(idx, line1, col1)
    end
  end,

  ["doc:move-lines-up"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      append_line_if_last_line(line2)
      if line1 > 1 then
        local text = doc().lines[line1 - 1]
        dv.doc:insert(line2 + 1, 1, text)
        dv.doc:remove(line1 - 1, 1, line1, 1)
        dv.doc:set_selections(idx, line1 - 1, col1, line2 - 1, col2)
      end
    end
  end,

  ["doc:move-lines-down"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      append_line_if_last_line(line2 + 1)
      if line2 < #dv.doc.lines then
        local text = dv.doc.lines[line2 + 1]
        dv.doc:remove(line2 + 1, 1, line2 + 2, 1)
        dv.doc:insert(line1, 1, text)
        dv.doc:set_selections(idx, line1 + 1, col1, line2 + 1, col2)
      end
    end
  end,

  ["doc:toggle-block-comments"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      local current_syntax = dv.doc.syntax
      if line1 > 1 then
        -- Use the previous line state, as it will be the state
        -- of the beginning of the current line
        local state = dv.doc.highlighter:get_line(line1 - 1).state
        local syntaxes = tokenizer.extract_subsyntaxes(dv.doc.syntax, state)
        -- Go through all the syntaxes until the first with `block_comment` defined
        for _, s in pairs(syntaxes) do
          if s.block_comment then
            current_syntax = s
            break
          end
        end
      end
      local comment = current_syntax.block_comment
      if not comment then
        if dv.doc.syntax.comment then
          command.perform "doc:toggle-line-comments"
        end
        return
      end
      -- if nothing is selected, toggle the whole line
      if line1 == line2 and col1 == col2 then
        col1 = 1
        col2 = #dv.doc.lines[line2]
      end
      dv.doc:set_selections(idx, block_comment(comment, line1, col1, line2, col2))
    end
  end,

  ["doc:toggle-line-comments"] = function(dv)
    for idx, line1, col1, line2, col2 in doc_multiline_selections(true) do
      local current_syntax = dv.doc.syntax
      if line1 > 1 then
        -- Use the previous line state, as it will be the state
        -- of the beginning of the current line
        local state = dv.doc.highlighter:get_line(line1 - 1).state
        local syntaxes = tokenizer.extract_subsyntaxes(dv.doc.syntax, state)
        -- Go through all the syntaxes until the first with comments defined
        for _, s in pairs(syntaxes) do
          if s.comment or s.block_comment then
            current_syntax = s
            break
          end
        end
      end
      local comment = current_syntax.comment or current_syntax.block_comment
      if comment then
        dv.doc:set_selections(idx, line_comment(comment, line1, col1, line2, col2))
      end
    end
  end,

  ["doc:upper-case"] = function(dv)
    dv.doc:replace(string.uupper)
  end,

  ["doc:lower-case"] = function(dv)
    dv.doc:replace(string.ulower)
  end,

  ["doc:go-to-line"] = function(dv)
    local items
    local function init_items()
      if items then return end
      items = {}
      local mt = { __tostring = function(x) return x.text end }
      for i, line in ipairs(dv.doc.lines) do
        local item = { text = line:sub(1, -2), line = i, info = "line: " .. i }
        table.insert(items, setmetatable(item, mt))
      end
    end

    core.command_view:enter("Go To Line", {
      submit = function(text, item)
        local line = item and item.line or tonumber(text)
        if not line then
          core.error("Invalid line number or unmatched string")
          return
        end
        dv.doc:set_selection(line, 1  )
        dv:scroll_to_line(line, true)
      end,
      suggest = function(text)
        if not text:find("^%d*$") then
          init_items()
          return common.fuzzy_match(items, text)
        end
      end
    })
  end,

  ["doc:toggle-line-ending"] = function(dv)
    dv.doc.crlf = not dv.doc.crlf
  end,

  ["doc:save-as"] = function(dv)
    local last_doc = core.last_active_view and core.last_active_view.doc
    local text
    if dv.doc.filename then
      text = dv.doc.filename
    elseif last_doc and last_doc.filename then
      local dirname, filename = core.last_active_view.doc.abs_filename:match("(.*)[/\\](.+)$")
      text = core.normalize_to_project_dir(dirname) .. PATHSEP
    end
    core.command_view:enter("Save As", {
      text = text,
      submit = function(filename)
        save(common.home_expand(filename))
      end,
      suggest = function (text)
        return common.home_encode_list(common.path_suggest(common.home_expand(text)))
      end
    })
  end,

  ["doc:save"] = function(dv)
    if dv.doc.filename then
      save()
    else
      command.perform("doc:save-as")
    end
  end,

  ["doc:reload"] = function(dv)
    dv.doc:reload()
  end,

  ["file:rename"] = function(dv)
    local old_filename = dv.doc.filename
    if not old_filename then
      core.error("Cannot rename unsaved doc")
      return
    end
    core.command_view:enter("Rename", {
      text = old_filename,
      submit = function(filename)
        save(common.home_expand(filename))
        core.log("Renamed \"%s\" to \"%s\"", old_filename, filename)
        if filename ~= old_filename then
          os.remove(old_filename)
        end
      end,
      suggest = function (text)
        return common.home_encode_list(common.path_suggest(common.home_expand(text)))
      end
    })
  end,


  ["file:delete"] = function(dv)
    local filename = dv.doc.abs_filename
    if not filename then
      core.error("Cannot remove unsaved doc")
      return
    end
    for i,docview in ipairs(core.get_views_referencing_doc(dv.doc)) do
      local node = core.root_view.root_node:get_node_for_view(docview)
      node:close_view(core.root_view.root_node, docview)
    end
    os.remove(filename)
    core.log("Removed \"%s\"", filename)
  end,

  ["doc:select-to-cursor"] = function(dv, x, y, clicks)
    local line1, col1 = select(3, doc():get_selection())
    local line2, col2 = dv:resolve_screen_position(x, y)
    dv.mouse_selecting = { line1, col1, nil }
    dv.doc:set_selection(line2, col2, line1, col1)
  end,

  ["doc:create-cursor-previous-line"] = function(dv)
    split_cursor(-1)
    dv.doc:merge_cursors()
  end,

  ["doc:create-cursor-next-line"] = function(dv)
    split_cursor(1)
    dv.doc:merge_cursors()
  end

}

command.add(function(x, y)
  if x == nil or y == nil or not core.active_view:extends(DocView) then return false end
  local dv = core.active_view
  local x1,y1,x2,y2 = dv.position.x, dv.position.y, dv.position.x + dv.size.x, dv.position.y + dv.size.y
  return x >= x1 + dv:get_gutter_width() and x < x2 and y >= y1 and y < y2, dv, x, y
end, {
  ["doc:set-cursor"] = function(dv, x, y)
    set_cursor(dv, x, y, "set")
  end,

  ["doc:set-cursor-word"] = function(dv, x, y)
    set_cursor(dv, x, y, "word")
  end,

  ["doc:set-cursor-line"] = function(dv, x, y, clicks)
    set_cursor(dv, x, y, "lines")
  end,

  ["doc:split-cursor"] = function(dv, x, y, clicks)
    local line, col = dv:resolve_screen_position(x, y)
    local removal_target = nil
    for idx, line1, col1 in dv.doc:get_selections(true) do
      if line1 == line and col1 == col and #doc().selections > 4 then
        removal_target = idx
      end
    end
    if removal_target then
      dv.doc:remove_selection(removal_target)
    else
      dv.doc:add_selection(line, col, line, col)
    end
    dv.mouse_selecting = { line, col, "set" }
  end
})

local translations = {
  ["previous-char"] = translate,
  ["next-char"] = translate,
  ["previous-word-start"] = translate,
  ["next-word-end"] = translate,
  ["previous-block-start"] = translate,
  ["next-block-end"] = translate,
  ["start-of-doc"] = translate,
  ["end-of-doc"] = translate,
  ["start-of-line"] = translate,
  ["end-of-line"] = translate,
  ["start-of-word"] = translate,
  ["start-of-indentation"] = translate,
  ["end-of-word"] = translate,
  ["previous-line"] = DocView.translate,
  ["next-line"] = DocView.translate,
  ["previous-page"] = DocView.translate,
  ["next-page"] = DocView.translate,
}

for name, obj in pairs(translations) do
  commands["doc:move-to-" .. name] = function(dv) dv.doc:move_to(obj[name:gsub("-", "_")], dv) end
  commands["doc:select-to-" .. name] = function(dv) dv.doc:select_to(obj[name:gsub("-", "_")], dv) end
  commands["doc:delete-to-" .. name] = function(dv) dv.doc:delete_to(obj[name:gsub("-", "_")], dv) end
end

commands["doc:move-to-previous-char"] = function(dv)
  for idx, line1, col1, line2, col2 in dv.doc:get_selections(true) do
    if line1 ~= line2 or col1 ~= col2 then
      dv.doc:set_selections(idx, line1, col1)
    else
      dv.doc:move_to_cursor(idx, translate.previous_char)
    end
  end
end

commands["doc:move-to-next-char"] = function(dv)
  for idx, line1, col1, line2, col2 in dv.doc:get_selections(true) do
    if line1 ~= line2 or col1 ~= col2 then
      dv.doc:set_selections(idx, line2, col2)
    else
      dv.doc:move_to_cursor(idx, translate.next_char)
    end
  end
end

command.add("core.docview", commands)
local command = require "core.command"
local config = require "core.config"

command.add(nil, {
  ["draw-whitespace:toggle"]  = function()
    config.draw_whitespace = not config.draw_whitespace
  end,

  ["draw-whitespace:disable"] = function()
    config.draw_whitespace = false
  end,

  ["draw-whitespace:enable"]  = function()
    config.draw_whitespace = true
  end,
})
local core = require "core"
local command = require "core.command"
local common = require "core.common"

command.add(nil, {
  ["files:create-directory"] = function()
    core.command_view:enter("New directory name", {
      submit = function(text)
        local success, err, path = common.mkdirp(text)
        if not success then
          core.error("cannot create directory %q: %s", path, err)
        end
      end
    })
  end,
})
local core = require "core"
local command = require "core.command"
local config = require "core.config"
local search = require "core.doc.search"
local keymap = require "core.keymap"
local DocView = require "core.docview"
local CommandView = require "core.commandview"
local StatusView = require "core.statusview"

local last_view, last_fn, last_text, last_sel

local case_sensitive = config.find_case_sensitive or false
local find_regex = config.find_regex or false
local found_expression

local function doc()
  local is_DocView = core.active_view:is(DocView) and not core.active_view:is(CommandView)
  return is_DocView and core.active_view.doc or (last_view and last_view.doc)
end

local function get_find_tooltip()
  local rf = keymap.get_binding("find-replace:repeat-find")
  local ti = keymap.get_binding("find-replace:toggle-sensitivity")
  local tr = keymap.get_binding("find-replace:toggle-regex")
  return (find_regex and "[Regex] " or "") ..
    (case_sensitive and "[Sensitive] " or "") ..
    (rf and ("Press " .. rf .. " to select the next match.") or "") ..
    (ti and (" " .. ti .. " toggles case sensitivity.") or "") ..
    (tr and (" " .. tr .. " toggles regex find.") or "")
end

local function update_preview(sel, search_fn, text)
  local ok, line1, col1, line2, col2 = pcall(search_fn, last_view.doc,
    sel[1], sel[2], text, case_sensitive, find_regex)
  if ok and line1 and text ~= "" then
    last_view.doc:set_selection(line2, col2, line1, col1)
    last_view:scroll_to_line(line2, true)
    found_expression = true
  else
    last_view.doc:set_selection(table.unpack(sel))
    found_expression = false
  end
end


local function insert_unique(t, v)
  local n = #t
  for i = 1, n do
    if t[i] == v then
      table.remove(t, i)
      break
    end
  end
  table.insert(t, 1, v)
end


local function find(label, search_fn)
  last_view, last_sel = core.active_view,
    { core.active_view.doc:get_selection() }
  local text = last_view.doc:get_text(table.unpack(last_sel))
  found_expression = false

  core.status_view:show_tooltip(get_find_tooltip())

  core.command_view:enter(label, {
    text = text,
    select_text = true,
    show_suggestions = false,
    submit = function(text, item)
      insert_unique(core.previous_find, text)
      core.status_view:remove_tooltip()
      if found_expression then
        last_fn, last_text = search_fn, text
      else
        core.error("Couldn't find %q", text)
        last_view.doc:set_selection(table.unpack(last_sel))
        last_view:scroll_to_make_visible(table.unpack(last_sel))
      end
    end,
    suggest = function(text)
      update_preview(last_sel, search_fn, text)
      last_fn, last_text = search_fn, text
      return core.previous_find
    end,
    cancel = function(explicit)
      core.status_view:remove_tooltip()
      if explicit then
        last_view.doc:set_selection(table.unpack(last_sel))
        last_view:scroll_to_make_visible(table.unpack(last_sel))
      end
    end
  })
end


local function replace(kind, default, fn)
  core.status_view:show_tooltip(get_find_tooltip())
  core.command_view:enter("Find To Replace " .. kind, {
    text = default,
    select_text = true,
    show_suggestions = false,
    submit = function(old)
      insert_unique(core.previous_find, old)

      local s = string.format("Replace %s %q With", kind, old)
      core.command_view:enter(s, {
        text = old,
        select_text = true,
        show_suggestions = false,
        submit = function(new)
          core.status_view:remove_tooltip()
          insert_unique(core.previous_replace, new)
          local results = doc():replace(function(text)
            return fn(text, old, new)
          end)
          local n = 0
          for _,v in pairs(results) do
            n = n + v
          end
          core.log("Replaced %d instance(s) of %s %q with %q", n, kind, old, new)
        end,
        suggest = function() return core.previous_replace end,
        cancel = function()
          core.status_view:remove_tooltip()
        end
      })
    end,
    suggest = function() return core.previous_find end,
    cancel = function()
      core.status_view:remove_tooltip()
    end
  })
end

local function has_selection()
  return core.active_view:is(DocView) and core.active_view.doc:has_selection()
end

local function has_unique_selection()
  if not doc() then return false end
  local text = nil
  for idx, line1, col1, line2, col2 in doc():get_selections(true, true) do
    if line1 == line2 and col1 == col2 then return false end
    local selection = doc():get_text(line1, col1, line2, col2)
    if text ~= nil and text ~= selection then return false end
    text = selection
  end
  return text ~= nil
end

local function is_in_selection(line, col, l1, c1, l2, c2)
  if line < l1 or line > l2 then return false end
  if line == l1 and col <= c1 then return false end
  if line == l2 and col > c2 then return false end
  return true
end

local function is_in_any_selection(line, col)
  for idx, l1, c1, l2, c2 in doc():get_selections(true, false) do
    if is_in_selection(line, col, l1, c1, l2, c2) then return true end
  end
  return false
end

local function select_add_next(all)
  local il1, ic1 = doc():get_selection(true)
  for idx, l1, c1, l2, c2 in doc():get_selections(true, true) do
    local text = doc():get_text(l1, c1, l2, c2)
    repeat
      l1, c1, l2, c2 = search.find(doc(), l2, c2, text, { wrap = true })
      if l1 == il1 and c1 == ic1 then break end
      if l2 and (all or not is_in_any_selection(l2, c2)) then
        doc():add_selection(l2, c2, l1, c1)
        if not all then
          core.active_view:scroll_to_make_visible(l2, c2)
          return
        end
      end
    until not all or not l2
    if all then break end
  end
end

local function select_next(reverse)
  local l1, c1, l2, c2 = doc():get_selection(true)
  local text = doc():get_text(l1, c1, l2, c2)
  if reverse then
    l1, c1, l2, c2 = search.find(doc(), l1, c1, text, { wrap = true, reverse = true })
  else
    l1, c1, l2, c2 = search.find(doc(), l2, c2, text, { wrap = true })
  end
  if l2 then doc():set_selection(l2, c2, l1, c1) end
end

command.add(has_unique_selection, {
  ["find-replace:select-next"] = select_next,
  ["find-replace:select-previous"] = function() select_next(true) end,
  ["find-replace:select-add-next"] = select_add_next,
  ["find-replace:select-add-all"] = function() select_add_next(true) end
})

command.add("core.docview!", {
  ["find-replace:find"] = function()
    find("Find Text", function(doc, line, col, text, case_sensitive, find_regex, find_reverse)
      local opt = { wrap = true, no_case = not case_sensitive, regex = find_regex, reverse = find_reverse }
      return search.find(doc, line, col, text, opt)
    end)
  end,

  ["find-replace:replace"] = function()
    local l1, c1, l2, c2 = doc():get_selection()
    local selected_text = doc():get_text(l1, c1, l2, c2)
    replace("Text", l1 == l2 and selected_text or "", function(text, old, new)
      if not find_regex then
        return text:gsub(old:gsub("%W", "%%%1"), new:gsub("%%", "%%%%"), nil)
      end
      local result, matches = regex.gsub(regex.compile(old, "m"), text, new)
      return result, matches
    end)
  end,

  ["find-replace:replace-symbol"] = function()
    local first = ""
    if doc():has_selection() then
      local text = doc():get_text(doc():get_selection())
      first = text:match(config.symbol_pattern) or ""
    end
    replace("Symbol", first, function(text, old, new)
      local n = 0
      local res = text:gsub(config.symbol_pattern, function(sym)
        if old == sym then
          n = n + 1
          return new
        end
      end)
      return res, n
    end)
  end,
})

local function valid_for_finding()
  return core.active_view:is(DocView) or core.active_view:is(CommandView)
end

command.add(valid_for_finding, {
  ["find-replace:repeat-find"] = function()
    if not last_fn then
      core.error("No find to continue from")
    else
      local sl1, sc1, sl2, sc2 = doc():get_selection(true)
      local line1, col1, line2, col2 = last_fn(doc(), sl1, sc2, last_text, case_sensitive, find_regex, false)
      if line1 then
        doc():set_selection(line2, col2, line1, col1)
        last_view:scroll_to_line(line2, true)
      else
        core.error("Couldn't find %q", last_text)
      end
    end
  end,

  ["find-replace:previous-find"] = function()
    if not last_fn then
      core.error("No find to continue from")
    else
      local sl1, sc1, sl2, sc2 = doc():get_selection(true)
      local line1, col1, line2, col2 = last_fn(doc(), sl1, sc1, last_text, case_sensitive, find_regex, true)
      if line1 then
        doc():set_selection(line2, col2, line1, col1)
        last_view:scroll_to_line(line2, true)
      else
        core.error("Couldn't find %q", last_text)
      end
    end
  end,
})

command.add("core.commandview", {
  ["find-replace:toggle-sensitivity"] = function()
    case_sensitive = not case_sensitive
    core.status_view:show_tooltip(get_find_tooltip())
    if last_sel then update_preview(last_sel, last_fn, last_text) end
  end,

  ["find-replace:toggle-regex"] = function()
    find_regex = not find_regex
    core.status_view:show_tooltip(get_find_tooltip())
    if last_sel then update_preview(last_sel, last_fn, last_text) end
  end
})
local core = require "core"
local command = require "core.command"


command.add(nil, {
  ["log:open-as-doc"] = function()
    local doc = core.open_doc("logs.txt")
    core.root_view:open_doc(doc)
    doc:insert(1, 1, core.get_log())
    doc.new_file = false
    doc:clean()
  end,
  ["log:copy-to-clipboard"] = function()
    system.set_clipboard(core.get_log())
  end
})
local core = require "core"
local style = require "core.style"
local DocView = require "core.docview"
local command = require "core.command"
local common = require "core.common"
local config = require "core.config"


local t = {
  ["root:close"] = function(node)
    node:close_active_view(core.root_view.root_node)
  end,

  ["root:close-or-quit"] = function(node)
    if node and (not node:is_empty() or not node.is_primary_node) then
      node:close_active_view(core.root_view.root_node)
    else
      core.quit()
    end
  end,

  ["root:close-all"] = function()
    core.confirm_close_docs(core.docs, core.root_view.close_all_docviews, core.root_view)
  end,

  ["root:close-all-others"] = function()
    local active_doc, docs = core.active_view and core.active_view.doc, {}
    for i, v in ipairs(core.docs) do if v ~= active_doc then table.insert(docs, v) end end
    core.confirm_close_docs(docs, core.root_view.close_all_docviews, core.root_view, true)
  end,

  ["root:switch-to-previous-tab"] = function(node)
    local idx = node:get_view_idx(core.active_view)
    idx = idx - 1
    if idx < 1 then idx = #node.views end
    node:set_active_view(node.views[idx])
  end,

  ["root:switch-to-next-tab"] = function(node)
    local idx = node:get_view_idx(core.active_view)
    idx = idx + 1
    if idx > #node.views then idx = 1 end
    node:set_active_view(node.views[idx])
  end,

  ["root:move-tab-left"] = function(node)
    local idx = node:get_view_idx(core.active_view)
    if idx > 1 then
      table.remove(node.views, idx)
      table.insert(node.views, idx - 1, core.active_view)
    end
  end,

  ["root:move-tab-right"] = function(node)
    local idx = node:get_view_idx(core.active_view)
    if idx < #node.views then
      table.remove(node.views, idx)
      table.insert(node.views, idx + 1, core.active_view)
    end
  end,

  ["root:shrink"] = function(node)
    local parent = node:get_parent_node(core.root_view.root_node)
    local n = (parent.a == node) and -0.1 or 0.1
    parent.divider = common.clamp(parent.divider + n, 0.1, 0.9)
  end,

  ["root:grow"] = function(node)
    local parent = node:get_parent_node(core.root_view.root_node)
    local n = (parent.a == node) and 0.1 or -0.1
    parent.divider = common.clamp(parent.divider + n, 0.1, 0.9)
  end
}


for i = 1, 9 do
  t["root:switch-to-tab-" .. i] = function(node)
    local view = node.views[i]
    if view then
      node:set_active_view(view)
    end
  end
end


for _, dir in ipairs { "left", "right", "up", "down" } do
  t["root:split-" .. dir] = function(node)
    local av = node.active_view
    node:split(dir)
    if av:is(DocView) then
      core.root_view:open_doc(av.doc)
    end
  end

  t["root:switch-to-" .. dir] = function(node)
    local x, y
    if dir == "left" or dir == "right" then
      y = node.position.y + node.size.y / 2
      x = node.position.x + (dir == "left" and -1 or node.size.x + style.divider_size)
    else
      x = node.position.x + node.size.x / 2
      y = node.position.y + (dir == "up"   and -1 or node.size.y + style.divider_size)
    end
    local node = core.root_view.root_node:get_child_overlapping_point(x, y)
    local sx, sy = node:get_locked_size()
    if not sx and not sy then
      core.set_active_view(node.active_view)
    end
  end
end

command.add(function()
  local node = core.root_view:get_active_node()
  local sx, sy = node:get_locked_size()
  return not sx and not sy, node
end, t)

command.add(nil, {
  ["root:scroll"] = function(delta)
    local view = (core.root_view.overlapping_node and core.root_view.overlapping_node.active_view) or core.active_view
    if view and view.scrollable then
      view.scroll.to.y = view.scroll.to.y + delta * -config.mouse_wheel_scroll
      return true
    end
    return false
  end,
  ["root:horizontal-scroll"] = function(delta)
    local view = (core.root_view.overlapping_node and core.root_view.overlapping_node.active_view) or core.active_view
    if view and view.scrollable then
      view.scroll.to.x = view.scroll.to.x + delta * -config.mouse_wheel_scroll
      return true
    end
    return false
  end
})
local core = require "core"
local command = require "core.command"
local common = require "core.common"
local style = require "core.style"
local StatusView = require "core.statusview"

local function status_view_item_names()
  local items = core.status_view:get_items_list()
  local names = {}
  for _, item in ipairs(items) do
    table.insert(names, item.name)
  end
  return names
end

local function status_view_items_data(names)
  local data = {}
  for _, name in ipairs(names) do
    local item = core.status_view:get_item(name)
    table.insert(data, {
      text = command.prettify_name(item.name),
      info = item.alignment == StatusView.Item.LEFT and "Left" or "Right",
      name = item.name
    })
  end
  return data
end

local function status_view_get_items(text)
  local names = status_view_item_names()
  local results = common.fuzzy_match(names, text)
  results = status_view_items_data(results)
  return results
end

command.add(nil, {
  ["status-bar:toggle"] = function()
    core.status_view:toggle()
  end,
  ["status-bar:show"] = function()
    core.status_view:show()
  end,
  ["status-bar:hide"] = function()
    core.status_view:hide()
  end,
  ["status-bar:disable-messages"] = function()
    core.status_view:display_messages(false)
  end,
  ["status-bar:enable-messages"] = function()
    core.status_view:display_messages(true)
  end,
  ["status-bar:hide-item"] = function()
    core.command_view:enter("Status bar item to hide", {
      submit = function(text, item)
        core.status_view:hide_items(item.name)
      end,
      suggest = status_view_get_items
    })
  end,
  ["status-bar:show-item"] = function()
    core.command_view:enter("Status bar item to show", {
      submit = function(text, item)
        core.status_view:show_items(item.name)
      end,
      suggest = status_view_get_items
    })
  end,
  ["status-bar:reset-items"] = function()
    core.status_view:show_items()
  end,
})
local core = require "core"
local common = require "core.common"
local style = require "core.style"
local Doc = require "core.doc"
local DocView = require "core.docview"
local View = require "core.view"


---@class core.commandview.input : core.doc
---@field super core.doc
local SingleLineDoc = Doc:extend()

function SingleLineDoc:insert(line, col, text)
  SingleLineDoc.super.insert(self, line, col, text:gsub("\n", ""))
end

---@class core.commandview : core.docview
---@field super core.docview
local CommandView = DocView:extend()

CommandView.context = "application"

local max_suggestions = 10

local noop = function() end

---@class core.commandview.state
---@field submit function
---@field suggest function
---@field cancel function
---@field validate function
---@field text string
---@field select_text boolean
---@field show_suggestions boolean
---@field typeahead boolean
---@field wrap boolean
local default_state = {
  submit = noop,
  suggest = noop,
  cancel = noop,
  validate = function() return true end,
  text = "",
  select_text = false,
  show_suggestions = true,
  typeahead = true,
  wrap = true,
}


function CommandView:new()
  CommandView.super.new(self, SingleLineDoc())
  self.suggestion_idx = 1
  self.suggestions = {}
  self.suggestions_height = 0
  self.last_change_id = 0
  self.last_text = ""
  self.gutter_width = 0
  self.gutter_text_brightness = 0
  self.selection_offset = 0
  self.state = default_state
  self.font = "font"
  self.size.y = 0
  self.label = ""
end


---@deprecated
function CommandView:set_hidden_suggestions()
  core.warn("Using deprecated function CommandView:set_hidden_suggestions")
  self.state.show_suggestions = false
end


function CommandView:get_name()
  return View.get_name(self)
end


function CommandView:get_line_screen_position(line, col)
  local x = CommandView.super.get_line_screen_position(self, 1, col)
  local _, y = self:get_content_offset()
  local lh = self:get_line_height()
  return x, y + (self.size.y - lh) / 2
end


function CommandView:get_scrollable_size()
  return 0
end

function CommandView:get_h_scrollable_size()
  return 0
end


function CommandView:scroll_to_make_visible()
  -- no-op function to disable this functionality
end


function CommandView:get_text()
  return self.doc:get_text(1, 1, 1, math.huge)
end


function CommandView:set_text(text, select)
  self.last_text = text
  self.doc:remove(1, 1, math.huge, math.huge)
  self.doc:text_input(text)
  if select then
    self.doc:set_selection(math.huge, math.huge, 1, 1)
  end
end


function CommandView:move_suggestion_idx(dir)
  local function overflow_suggestion_idx(n, count)
    if count == 0 then return 0 end
    if self.state.wrap then
      return (n - 1) % count + 1
    else
      return common.clamp(n, 1, count)
    end
  end

  if self.state.show_suggestions then
    local n = self.suggestion_idx + dir
    self.suggestion_idx = overflow_suggestion_idx(n, #self.suggestions)
    self:complete()
    self.last_change_id = self.doc:get_change_id()
  else
    local current_suggestion = #self.suggestions > 0 and self.suggestions[self.suggestion_idx].text
    local text = self:get_text()
    if text == current_suggestion then
      local n = self.suggestion_idx + dir
      if n == 0 and self.save_suggestion then
        self:set_text(self.save_suggestion)
      else
        self.suggestion_idx = overflow_suggestion_idx(n, #self.suggestions)
        self:complete()
      end
    else
      self.save_suggestion = text
      self:complete()
    end
    self.last_change_id = self.doc:get_change_id()
    self.state.suggest(self:get_text())
  end
end


function CommandView:complete()
  if #self.suggestions > 0 then
    self:set_text(self.suggestions[self.suggestion_idx].text)
  end
end


function CommandView:submit()
  local suggestion = self.suggestions[self.suggestion_idx]
  local text = self:get_text()
  if self.state.validate(text, suggestion) then
    local submit = self.state.submit
    self:exit(true)
    submit(text, suggestion)
  end
end

---@param label string
---@varargs any
---@overload fun(label:string, options: core.commandview.state)
function CommandView:enter(label, ...)
  if self.state ~= default_state then
    return
  end
  local options = select(1, ...)

  if type(options) ~= "table" then
    core.warn("Using CommandView:enter in a deprecated way")
    local submit, suggest, cancel, validate = ...
    options = {
      submit = submit,
      suggest = suggest,
      cancel = cancel,
      validate = validate,
    }
  end

  -- Support deprecated CommandView:set_hidden_suggestions
  -- Remove this when set_hidden_suggestions is not supported anymore
  if options.show_suggestions == nil then
    options.show_suggestions = self.state.show_suggestions
  end

  self.state = common.merge(default_state, options)

  -- We need to keep the text entered with CommandView:set_text to
  -- maintain compatibility with deprecated usage, but still allow
  -- overwriting with options.text
  local old_text = self:get_text()
  if old_text ~= "" then
    core.warn("Using deprecated function CommandView:set_text")
  end
  if options.text or options.select_text then
    local text = options.text or old_text
    self:set_text(text, self.state.select_text)
  end
  -- Replace with a simple
  -- self:set_text(self.state.text, self.state.select_text)
  -- once old usage is removed

  core.set_active_view(self)
  self:update_suggestions()
  self.gutter_text_brightness = 100
  self.label = label .. ": "
end


function CommandView:exit(submitted, inexplicit)
  if core.active_view == self then
    core.set_active_view(core.last_active_view)
  end
  local cancel = self.state.cancel
  self.state = default_state
  self.doc:reset()
  self.suggestions = {}
  if not submitted then cancel(not inexplicit) end
  self.save_suggestion = nil
  self.last_text = ""
end


function CommandView:get_line_height()
  return math.floor(self:get_font():get_height() * 1.2)
end


function CommandView:get_gutter_width()
  return self.gutter_width
end


function CommandView:get_suggestion_line_height()
  return self:get_font():get_height() + style.padding.y
end


function CommandView:update_suggestions()
  local t = self.state.suggest(self:get_text()) or {}
  local res = {}
  for i, item in ipairs(t) do
    if type(item) == "string" then
      item = { text = item }
    end
    res[i] = item
  end
  self.suggestions = res
  self.suggestion_idx = 1
end


function CommandView:update()
  CommandView.super.update(self)

  if core.active_view ~= self and self.state ~= default_state then
    self:exit(false, true)
  end

  -- update suggestions if text has changed
  if self.last_change_id ~= self.doc:get_change_id() then
    self:update_suggestions()
    if self.state.typeahead and self.suggestions[self.suggestion_idx] then
      local current_text = self:get_text()
      local suggested_text = self.suggestions[self.suggestion_idx].text or ""
      if #self.last_text < #current_text and
         string.find(suggested_text, current_text, 1, true) == 1 then
        self:set_text(suggested_text)
        self.doc:set_selection(1, #current_text + 1, 1, math.huge)
      end
      self.last_text = current_text
    end
    self.last_change_id = self.doc:get_change_id()
  end

  -- update gutter text color brightness
  self:move_towards("gutter_text_brightness", 0, 0.1, "commandview")

  -- update gutter width
  local dest = self:get_font():get_width(self.label) + style.padding.x
  if self.size.y <= 0 then
    self.gutter_width = dest
  else
    self:move_towards("gutter_width", dest, nil, "commandview")
  end

  -- update suggestions box height
  local lh = self:get_suggestion_line_height()
  local dest = self.state.show_suggestions and math.min(#self.suggestions, max_suggestions) * lh or 0
  self:move_towards("suggestions_height", dest, nil, "commandview")

  -- update suggestion cursor offset
  local dest = math.min(self.suggestion_idx, max_suggestions) * self:get_suggestion_line_height()
  self:move_towards("selection_offset", dest, nil, "commandview")

  -- update size based on whether this is the active_view
  local dest = 0
  if self == core.active_view then
    dest = style.font:get_height() + style.padding.y * 2
  end
  self:move_towards(self.size, "y", dest, nil, "commandview")
end


function CommandView:draw_line_highlight()
  -- no-op function to disable this functionality
end


function CommandView:draw_line_gutter(idx, x, y)
  local yoffset = self:get_line_text_y_offset()
  local pos = self.position
  local color = common.lerp(style.text, style.accent, self.gutter_text_brightness / 100)
  core.push_clip_rect(pos.x, pos.y, self:get_gutter_width(), self.size.y)
  x = x + style.padding.x
  renderer.draw_text(self:get_font(), self.label, x, y + yoffset, color)
  core.pop_clip_rect()
  return self:get_line_height()
end


local function draw_suggestions_box(self)
  local lh = self:get_suggestion_line_height()
  local dh = style.divider_size
  local x, _ = self:get_line_screen_position()
  local h = math.ceil(self.suggestions_height)
  local rx, ry, rw, rh = self.position.x, self.position.y - h - dh, self.size.x, h

  -- draw suggestions background
  if #self.suggestions > 0 then
    renderer.draw_rect(rx, ry, rw, rh, style.background3)
    renderer.draw_rect(rx, ry - dh, rw, dh, style.divider)
    local y = self.position.y - self.selection_offset - dh
    renderer.draw_rect(rx, y, rw, lh, style.line_highlight)
  end

  -- draw suggestion text
  local offset = math.max(self.suggestion_idx - max_suggestions, 0)
  local last = math.min(offset + max_suggestions, #self.suggestions)
  core.push_clip_rect(rx, ry, rw, rh)
  local first = 1 + offset
  for i=first, last do
    local item = self.suggestions[i]
    local color = (i == self.suggestion_idx) and style.accent or style.text
    local y = self.position.y - (i - offset) * lh - dh
    common.draw_text(self:get_font(), color, item.text, nil, x, y, 0, lh)

    if item.info then
      local w = self.size.x - x - style.padding.x
      common.draw_text(self:get_font(), style.dim, item.info, "right", x, y, w, lh)
    end
  end
  core.pop_clip_rect()
end


function CommandView:draw()
  CommandView.super.draw(self)
  if self.state.show_suggestions then
    core.root_view:defer_draw(draw_suggestions_box, self)
  end
end


return CommandView
local common = {}


function common.is_utf8_cont(s, offset)
  local byte = s:byte(offset or 1)
  return byte >= 0x80 and byte < 0xc0
end


function common.utf8_chars(text)
  return text:gmatch("[\x01-\x7f\xc2-\xf4][\x80-\xbf]*")
end


function common.clamp(n, lo, hi)
  return math.max(math.min(n, hi), lo)
end


function common.merge(a, b)
  a = type(a) == "table" and a or {}
  local t = {}
  for k, v in pairs(a) do
    t[k] = v
  end
  if b and type(b) == "table" then
    for k, v in pairs(b) do
      t[k] = v
    end
  end
  return t
end


function common.round(n)
  return n >= 0 and math.floor(n + 0.5) or math.ceil(n - 0.5)
end


function common.find_index(tbl, prop)
  for i, o in ipairs(tbl) do
    if o[prop] then return i end
  end
end


function common.lerp(a, b, t)
  if type(a) ~= "table" then
    return a + (b - a) * t
  end
  local res = {}
  for k, v in pairs(b) do
    res[k] = common.lerp(a[k], v, t)
  end
  return res
end


function common.distance(x1, y1, x2, y2)
    return math.sqrt(((x2-x1) ^ 2)+((y2-y1) ^ 2))
end


function common.color(str)
  local r, g, b, a = str:match("^#(%x%x)(%x%x)(%x%x)(%x?%x?)$")
  if r then
    r = tonumber(r, 16)
    g = tonumber(g, 16)
    b = tonumber(b, 16)
    a = tonumber(a, 16) or 0xff
  elseif str:match("rgba?%s*%([%d%s%.,]+%)") then
    local f = str:gmatch("[%d.]+")
    r = (f() or 0)
    g = (f() or 0)
    b = (f() or 0)
    a = (f() or 1) * 0xff
  else
    error(string.format("bad color string '%s'", str))
  end
  return r, g, b, a
end


function common.splice(t, at, remove, insert)
  insert = insert or {}
  local offset = #insert - remove
  local old_len = #t
  if offset < 0 then
    for i = at - offset, old_len - offset do
      t[i + offset] = t[i]
    end
  elseif offset > 0 then
    for i = old_len, at, -1 do
      t[i + offset] = t[i]
    end
  end
  for i, item in ipairs(insert) do
    t[at + i - 1] = item
  end
end



local function compare_score(a, b)
  return a.score > b.score
end

local function fuzzy_match_items(items, needle, files)
  local res = {}
  for _, item in ipairs(items) do
    local score = system.fuzzy_match(tostring(item), needle, files)
    if score then
      table.insert(res, { text = item, score = score })
    end
  end
  table.sort(res, compare_score)
  for i, item in ipairs(res) do
    res[i] = item.text
  end
  return res
end


function common.fuzzy_match(haystack, needle, files)
  if type(haystack) == "table" then
    return fuzzy_match_items(haystack, needle, files)
  end
  return system.fuzzy_match(haystack, needle, files)
end


function common.fuzzy_match_with_recents(haystack, recents, needle)
  if needle == "" then
    local recents_ext = {}
    for i = 2, #recents do
      table.insert(recents_ext, recents[i])
    end
    table.insert(recents_ext, recents[1])
    local others = common.fuzzy_match(haystack, "", true)
    for i = 1, #others do
      table.insert(recents_ext, others[i])
    end
    return recents_ext
  else
    return fuzzy_match_items(haystack, needle, true)
  end
end


function common.path_suggest(text, root)
  if root and root:sub(-1) ~= PATHSEP then
    root = root .. PATHSEP
  end
  local path, name = text:match("^(.-)([^/\\]*)$")
  local clean_dotslash = false
  -- ignore root if path is absolute
  local is_absolute = common.is_absolute_path(text)
  if not is_absolute then
    if path == "" then
      path = root or "."
      clean_dotslash = not root
    else
      path = (root or "") .. path
    end
  end

  -- Only in Windows allow using both styles of PATHSEP
  if (PATHSEP == "\\" and not string.match(path:sub(-1), "[\\/]")) or
     (PATHSEP ~= "\\" and path:sub(-1) ~= PATHSEP) then
    path = path .. PATHSEP
  end
  local files = system.list_dir(path) or {}
  local res = {}
  for _, file in ipairs(files) do
    file = path .. file
    local info = system.get_file_info(file)
    if info then
      if info.type == "dir" then
        file = file .. PATHSEP
      end
      if root then
        -- remove root part from file path
        local s, e = file:find(root, nil, true)
        if s == 1 then
          file = file:sub(e + 1)
        end
      elseif clean_dotslash then
        -- remove added dot slash
        local s, e = file:find("." .. PATHSEP, nil, true)
        if s == 1 then
          file = file:sub(e + 1)
        end
      end
      if file:lower():find(text:lower(), nil, true) == 1 then
        table.insert(res, file)
      end
    end
  end
  return res
end


function common.dir_path_suggest(text)
  local path, name = text:match("^(.-)([^/\\]*)$")
  local files = system.list_dir(path == "" and "." or path) or {}
  local res = {}
  for _, file in ipairs(files) do
    file = path .. file
    local info = system.get_file_info(file)
    if info and info.type == "dir" and file:lower():find(text:lower(), nil, true) == 1 then
      table.insert(res, file)
    end
  end
  return res
end


function common.dir_list_suggest(text, dir_list)
  local path, name = text:match("^(.-)([^/\\]*)$")
  local res = {}
  for _, dir_path in ipairs(dir_list) do
    if dir_path:lower():find(text:lower(), nil, true) == 1 then
      table.insert(res, dir_path)
    end
  end
  return res
end


function common.match_pattern(text, pattern, ...)
  if type(pattern) == "string" then
    return text:find(pattern, ...)
  end
  for _, p in ipairs(pattern) do
    local s, e = common.match_pattern(text, p, ...)
    if s then return s, e end
  end
  return false
end


function common.draw_text(font, color, text, align, x,y,w,h)
  local tw, th = font:get_width(text), font:get_height(text)
  if align == "center" then
    x = x + (w - tw) / 2
  elseif align == "right" then
    x = x + (w - tw)
  end
  y = common.round(y + (h - th) / 2)
  return renderer.draw_text(font, text, x, y, color), y + th
end


function common.bench(name, fn, ...)
  local start = system.get_time()
  local res = fn(...)
  local t = system.get_time() - start
  local ms = t * 1000
  local per = (t / (1 / 60)) * 100
  print(string.format("*** %-16s : %8.3fms %6.2f%%", name, ms, per))
  return res
end


local function serialize(val, pretty, indent_str, escape, sort, limit, level)
  local space = pretty and " " or ""
  local indent = pretty and string.rep(indent_str, level) or ""
  local newline = pretty and "\n" or ""
  if type(val) == "string" then
    local out = string.format("%q", val)
    if escape then
      out = string.gsub(out, "\\\n", "\\n")
      out = string.gsub(out, "\\7", "\\a")
      out = string.gsub(out, "\\8", "\\b")
      out = string.gsub(out, "\\9", "\\t")
      out = string.gsub(out, "\\11", "\\v")
      out = string.gsub(out, "\\12", "\\f")
      out = string.gsub(out, "\\13", "\\r")
    end
    return out
  elseif type(val) == "table" then
    -- early exit
    if level >= limit then return tostring(val) end
    local next_indent = pretty and (indent .. indent_str) or ""
    local t = {}
    for k, v in pairs(val) do
      table.insert(t,
        next_indent .. "[" ..
          serialize(k, pretty, indent_str, escape, sort, limit, level + 1) ..
        "]" .. space .. "=" .. space .. serialize(v, pretty, indent_str, escape, sort, limit, level + 1))
    end
    if #t == 0 then return "{}" end
    if sort then table.sort(t) end
    return "{" .. newline .. table.concat(t, "," .. newline) .. newline .. indent .. "}"
  end
  return tostring(val)
end

-- Serialize `val` into a parsable string.
-- Available options
-- * pretty: enable pretty printing
-- * indent_str: indent to use ("  " by default)
-- * escape: use normal escape characters instead of the ones used by string.format("%q", ...)
-- * sort: sort the keys inside tables
-- * limit: limit how deep to serialize
-- * initial_indent: the initial indentation level
function common.serialize(val, opts)
  opts = opts or {}
  local indent_str = opts.indent_str or "  "
  local initial_indent = opts.initial_indent or 0
  local indent = opts.pretty and string.rep(indent_str, initial_indent) or ""
  local limit = (opts.limit or math.huge) + initial_indent
  return indent .. serialize(val, opts.pretty, indent_str,
                   opts.escape, opts.sort, limit, initial_indent)
end


function common.basename(path)
  -- a path should never end by / or \ except if it is '/' (unix root) or
  -- 'X:\' (windows drive)
  return path:match("[^\\/]+$") or path
end


-- can return nil if there is no directory part in the path
function common.dirname(path)
  return path:match("(.+)[\\/][^\\/]+$")
end


function common.home_encode(text)
  if HOME and string.find(text, HOME, 1, true) == 1 then
    local dir_pos = #HOME + 1
    -- ensure we don't replace if the text is just "$HOME" or "$HOME/" so
    -- it must have a "/" following the $HOME and some characters following.
    if string.find(text, PATHSEP, dir_pos, true) == dir_pos and #text > dir_pos then
      return "~" .. text:sub(dir_pos)
    end
  end
  return text
end


function common.home_encode_list(paths)
  local t = {}
  for i = 1, #paths do
    t[i] = common.home_encode(paths[i])
  end
  return t
end


function common.home_expand(text)
  return HOME and text:gsub("^~", HOME) or text
end


local function split_on_slash(s, sep_pattern)
  local t = {}
  if s:match("^[/\\]") then
    t[#t + 1] = ""
  end
  for fragment in string.gmatch(s, "([^/\\]+)") do
    t[#t + 1] = fragment
  end
  return t
end


-- The filename argument given to the function is supposed to
-- come from system.absolute_path and as such should be an
-- absolute path without . or .. elements.
-- This function exists because on Windows the drive letter returned
-- by system.absolute_path is sometimes with a lower case and sometimes
-- with an upper case so we normalize to upper case.
function common.normalize_volume(filename)
  if not filename then return end
  if PATHSEP == '\\' then
    local drive, rem = filename:match('^([a-zA-Z]:\\)(.-)'..PATHSEP..'?$')
    if drive then
      return drive:upper() .. rem
    end
  end
  return filename
end


function common.normalize_path(filename)
  if not filename then return end
  local volume
  if PATHSEP == '\\' then
    filename = filename:gsub('[/\\]', '\\')
    local drive, rem = filename:match('^([a-zA-Z]:\\)(.*)')
    if drive then
      volume, filename = drive:upper(), rem
    else
      drive, rem = filename:match('^(\\\\[^\\]+\\[^\\]+\\)(.*)')
      if drive then
        volume, filename = drive, rem
      end
    end
  else
    local relpath = filename:match('^/(.+)')
    if relpath then
      volume, filename = "/", relpath
    end
  end
  local parts = split_on_slash(filename, PATHSEP)
  local accu = {}
  for _, part in ipairs(parts) do
    if part == '..' then
      if #accu > 0 and accu[#accu] ~= ".." then
        table.remove(accu)
      elseif volume then
        error("invalid path " .. volume .. filename)
      else
        table.insert(accu, part)
      end
    elseif part ~= '.' then
      table.insert(accu, part)
    end
  end
  local npath = table.concat(accu, PATHSEP)
  return (volume or "") .. (npath == "" and PATHSEP or npath)
end


function common.is_absolute_path(path)
  return path:sub(1, 1) == PATHSEP or path:match("^(%a):\\")
end


function common.path_belongs_to(filename, path)
  return string.find(filename, path .. PATHSEP, 1, true) == 1
end


function common.relative_path(ref_dir, dir)
  local drive_pattern = "^(%a):\\"
  local drive, ref_drive = dir:match(drive_pattern), ref_dir:match(drive_pattern)
  if drive and ref_drive and drive ~= ref_drive then
    -- Windows, different drives, system.absolute_path fails for C:\..\D:\
    return dir
  end
  local ref_ls = split_on_slash(ref_dir)
  local dir_ls = split_on_slash(dir)
  local i = 1
  while i <= #ref_ls do
    if dir_ls[i] ~= ref_ls[i] then
      break
    end
    i = i + 1
  end
  local ups = ""
  for k = i, #ref_ls do
    ups = ups .. ".." .. PATHSEP
  end
  local rel_path = ups .. table.concat(dir_ls, PATHSEP, i)
  return rel_path ~= "" and rel_path or "."
end


function common.mkdirp(path)
  local stat = system.get_file_info(path)
  if stat and stat.type then
    return false, "path exists", path
  end
  local subdirs = {}
  while path and path ~= "" do
    local success_mkdir = system.mkdir(path)
    if success_mkdir then break end
    local updir, basedir = path:match("(.*)[/\\](.+)$")
    table.insert(subdirs, 1, basedir or path)
    path = updir
  end
  for _, dirname in ipairs(subdirs) do
    path = path and path .. PATHSEP .. dirname or dirname
    if not system.mkdir(path) then
      return false, "cannot create directory", path
    end
  end
  return true
end

function common.rm(path, recursively)
  local stat = system.get_file_info(path)
  if not stat or (stat.type ~= "file" and stat.type ~= "dir") then
    return false, "invalid path given", path
  end

  if stat.type == "file" then
    local removed, error = os.remove(path)
    if not removed then
      return false, error, path
    end
  else
    local contents = system.list_dir(path)
    if #contents > 0 and not recursively then
      return false, "directory is not empty", path
    end

    for _, item in pairs(contents) do
      local item_path = path .. PATHSEP .. item
      local item_stat = system.get_file_info(item_path)

      if not item_stat then
        return false, "invalid file encountered", item_path
      end

      if item_stat.type == "dir" then
        local deleted, error, ipath = common.rm(item_path, recursively)
        if not deleted then
          return false, error, ipath
        end
      elseif item_stat.type == "file" then
        local removed, error = os.remove(item_path)
        if not removed then
          return false, error, item_path
        end
      end
    end

    local removed, error = system.rmdir(path)
    if not removed then
      return false, error, path
    end
  end

  return true
end


return common
local config = {}

config.fps = 60
config.max_log_items = 800
config.message_timeout = 5
config.mouse_wheel_scroll = 50 * SCALE
config.animate_drag_scroll = false
config.scroll_past_end = true
---@type "expanded" | "contracted" | false @Force the scrollbar status of the DocView
config.force_scrollbar_status = false
config.file_size_limit = 10
config.ignore_files = {
  -- folders
  "^%.svn/",        "^%.git/",   "^%.hg/",        "^CVS/", "^%.Trash/", "^%.Trash%-.*/",
  "^node_modules/", "^%.cache/", "^__pycache__/",
  -- files
  "%.pyc$",         "%.pyo$",       "%.exe$",        "%.dll$",   "%.obj$", "%.o$",
  "%.a$",           "%.lib$",       "%.so$",         "%.dylib$", "%.ncb$", "%.sdf$",
  "%.suo$",         "%.pdb$",       "%.idb$",        "%.class$", "%.psd$", "%.db$",
  "^desktop%.ini$", "^%.DS_Store$", "^%.directory$",
}
config.symbol_pattern = "[%a_][%w_]*"
config.non_word_chars = " \t\n/\\()\"':,.;<>~!@#$%^&*|+=[]{}`?-"
config.undo_merge_timeout = 0.3
config.max_undos = 10000
config.max_tabs = 8
config.always_show_tabs = true
-- Possible values: false, true, "no_selection"
config.highlight_current_line = true
config.line_height = 1.2
config.indent_size = 2
config.tab_type = "soft"
config.keep_newline_whitespace = false
config.line_limit = 80
config.max_project_files = 2000
config.transitions = true
config.disabled_transitions = {
  scroll = false,
  commandview = false,
  contextmenu = false,
  logview = false,
  nagbar = false,
  tabs = false,
  tab_drag = false,
  statusbar = false,
}
config.animation_rate = 1.0
config.blink_period = 0.8
config.disable_blink = false
config.draw_whitespace = false
config.borderless = false
config.tab_close_button = true
config.max_clicks = 3

-- set as true to be able to test non supported plugins
config.skip_plugins_version = false

config.plugins = {}
-- Allow you to set plugin configs even if we haven't seen the plugin before.
setmetatable(config.plugins, {
  __index = function(t, k)
    local v = rawget(t, k)
    if v == true or v == nil then v = {} rawset(t, k, v) end
    return v
  end
})

-- Disable these plugins by default.
config.plugins.trimwhitespace = false
config.plugins.drawwhitespace = false

return config
local core = require "core"
local common = require "core.common"
local command = require "core.command"
local config = require "core.config"
local keymap = require "core.keymap"
local style = require "core.style"
local Object = require "core.object"
local View = require "core.view"

local border_width = 1
local divider_width = 1
local divider_padding = 5
local DIVIDER = {}

---@class core.contextmenu : core.object
local ContextMenu = Object:extend()

ContextMenu.DIVIDER = DIVIDER

function ContextMenu:new()
  self.itemset = {}
  self.show_context_menu = false
  self.selected = -1
  self.height = 0
  self.position = { x = 0, y = 0 }
  self.current_scale = SCALE
end

local function get_item_size(item)
  local lw, lh
  if item == DIVIDER then
    lw = 0
    lh = divider_width + divider_padding * SCALE * 2
  else
    lw = style.font:get_width(item.text)
    if item.info then
      lw = lw + style.padding.x + style.font:get_width(item.info)
    end
    lh = style.font:get_height() + style.padding.y
  end
  return lw, lh
end

local function update_items_size(items, update_binding)
  local width, height = 0, 0
  for _, item in ipairs(items) do
    if update_binding and item ~= DIVIDER then
      item.info = keymap.get_binding(item.command)
    end
    local lw, lh = get_item_size(item)
    width = math.max(width, lw)
    height = height + lh
  end
  width = width + style.padding.x * 2
  items.width, items.height = width, height
end

function ContextMenu:register(predicate, items)
  predicate = command.generate_predicate(predicate)
  update_items_size(items, true)
  table.insert(self.itemset, { predicate = predicate, items = items })
end

function ContextMenu:show(x, y)
  self.items = nil
  local items_list = { width = 0, height = 0 }
  for _, items in ipairs(self.itemset) do
    if items.predicate(x, y) then
      items_list.width = math.max(items_list.width, items.items.width)
      items_list.height = items_list.height
      for _, subitems in ipairs(items.items) do
        if not subitems.command or command.is_valid(subitems.command) then
          local lw, lh = get_item_size(subitems)
          items_list.height = items_list.height + lh
          table.insert(items_list, subitems)
        end
      end
    end
  end

  if #items_list > 0 then
    self.items = items_list
    local w, h = self.items.width, self.items.height

    -- by default the box is opened on the right and below
    x = common.clamp(x, 0, core.root_view.size.x - w - style.padding.x)
    y = common.clamp(y, 0, core.root_view.size.y - h)

    self.position.x, self.position.y = x, y
    self.show_context_menu = true
    core.request_cursor("arrow")
    return true
  end
  return false
end

function ContextMenu:hide()
  self.show_context_menu = false
  self.items = nil
  self.selected = -1
  self.height = 0
  core.request_cursor(core.active_view.cursor)
end

function ContextMenu:each_item()
  local x, y, w = self.position.x, self.position.y, self.items.width
  local oy = y
  return coroutine.wrap(function()
    for i, item in ipairs(self.items) do
      local _, lh = get_item_size(item)
      if y - oy > self.height then break end
      coroutine.yield(i, item, x, y, w, lh)
      y = y + lh
    end
  end)
end

function ContextMenu:on_mouse_moved(px, py)
  if not self.show_context_menu then return end

  self.selected = -1
  for i, item, x, y, w, h in self:each_item() do
    if px > x and px <= x + w and py > y and py <= y + h then
      self.selected = i
      break
    end
  end
  return true
end

function ContextMenu:on_selected(item)
  if type(item.command) == "string" then
    command.perform(item.command)
  else
    item.command()
  end
end

local function change_value(value, change)
  return value + change
end

function ContextMenu:focus_previous()
  self.selected = (self.selected == -1 or self.selected == 1) and #self.items or change_value(self.selected, -1)
  if self:get_item_selected() == DIVIDER then
    self.selected = change_value(self.selected, -1)
  end
end

function ContextMenu:focus_next()
  self.selected = (self.selected == -1 or self.selected == #self.items) and 1 or change_value(self.selected, 1)
  if self:get_item_selected() == DIVIDER then
    self.selected = change_value(self.selected, 1)
  end
end

function ContextMenu:get_item_selected()
  return (self.items or {})[self.selected]
end

function ContextMenu:call_selected_item()
    local selected = self:get_item_selected()
    self:hide()
    if selected then
      self:on_selected(selected)
    end
end

function ContextMenu:on_mouse_pressed(button, px, py, clicks)
  local caught = false

  if self.show_context_menu then
    if button == "left" then
      local selected = self:get_item_selected()
      if selected then
        self:on_selected(selected)
      end
    end
    self:hide()
    caught = true
  else
    if button == "right" then
      caught = self:show(px, py)
    end
  end
  return caught
end

ContextMenu.move_towards = View.move_towards

function ContextMenu:update()
  if self.show_context_menu then
    self:move_towards("height", self.items.height, nil, "contextmenu")
  end
end

function ContextMenu:draw()
  if not self.show_context_menu then return end
  if self.current_scale ~= SCALE then
    update_items_size(self.items)
    for _, set in ipairs(self.itemset) do
      update_items_size(set.items)
    end
    self.current_scale = SCALE
  end
  core.root_view:defer_draw(self.draw_context_menu, self)
end

function ContextMenu:draw_context_menu()
  if not self.items then return end
  local bx, by, bw, bh = self.position.x, self.position.y, self.items.width, self.height

  renderer.draw_rect(
    bx - border_width,
    by - border_width,
    bw + (border_width * 2),
    bh + (border_width * 2),
    style.divider
  )
  renderer.draw_rect(bx, by, bw, bh, style.background3)

  for i, item, x, y, w, h in self:each_item() do
    if item == DIVIDER then
      renderer.draw_rect(x, y + divider_padding * SCALE, w, divider_width, style.divider)
    else
      if i == self.selected then
        renderer.draw_rect(x, y, w, h, style.selection)
      end

      common.draw_text(style.font, style.text, item.text, "left", x + style.padding.x, y, w, h)
      if item.info then
        common.draw_text(style.font, style.dim, item.info, "right", x, y, w - style.padding.x, h)
      end
    end
  end
end

return ContextMenu
local common = require "core.common"
local config = require "core.config"
local dirwatch = {}

function dirwatch:__index(idx)
  local value = rawget(self, idx)
  if value ~= nil then return value end
  return dirwatch[idx]
end

function dirwatch.new()
  local t = {
    scanned = {},
    watched = {},
    reverse_watched = {},
    monitor = dirmonitor.new(),
    single_watch_top = nil,
    single_watch_count = 0
  }
  setmetatable(t, dirwatch)
  return t
end


function dirwatch:scan(directory, bool)
  if bool == false then return self:unwatch(directory) end
  self.scanned[directory] = system.get_file_info(directory).modified
end

-- Should be called on every directory in a subdirectory.
-- In windows, this is a no-op for anything underneath a top-level directory,
-- but code should be called anyway, so we can ensure that we have a proper
-- experience across all platforms. Should be an absolute path.
-- Can also be called on individual files, though this should be used sparingly,
-- so as not to run into system limits (like in the autoreload plugin).
function dirwatch:watch(directory, bool)
  if bool == false then return self:unwatch(directory) end
  local info = system.get_file_info(directory)
  if not info then return end
  if not self.watched[directory] and not self.scanned[directory] then
    if self.monitor:mode() == "single" then
      if info.type ~= "dir" then return self:scan(directory) end
      if not self.single_watch_top or directory:find(self.single_watch_top, 1, true) ~= 1 then
        -- Get the highest level of directory that is common to this directory, and the original.
        local target = directory
        while self.single_watch_top and self.single_watch_top:find(target, 1, true) ~= 1 do
          target = common.dirname(target)
        end
        if target ~= self.single_watch_top then
          local value = self.monitor:watch(target)
          if value and value < 0 then
            return self:scan(directory)
          end
          self.single_watch_top = target
        end
      end
      self.single_watch_count = self.single_watch_count + 1
      self.watched[directory] = true
    else
      local value = self.monitor:watch(directory)
      -- If for whatever reason, we can't watch this directory, revert back to scanning.
      -- Don't bother trying to find out why, for now.
      if value and value < 0 then
        return self:scan(directory)
      end
      self.watched[directory] = value
      self.reverse_watched[value] = directory
    end
  end
end

-- this should be an absolute path
function dirwatch:unwatch(directory)
  if self.watched[directory] then
    if self.monitor:mode() == "multiple" then
      self.monitor:unwatch(self.watched[directory])
      self.reverse_watched[directory] = nil
    else
      self.single_watch_count = self.single_watch_count - 1
      if self.single_watch_count == 0 then
        self.single_watch_top = nil
        self.monitor:unwatch(directory)
      end
    end
    self.watched[directory] = nil
  elseif self.scanned[directory] then
    self.scanned[directory] = nil
  end
end

-- designed to be run inside a coroutine.
function dirwatch:check(change_callback, scan_time, wait_time)
  local had_change = false
  self.monitor:check(function(id)
    had_change = true
    if self.monitor:mode() == "single" then
      local path = common.dirname(id)
      if not string.match(id, "^/") and not string.match(id, "^%a:[/\\]") then
        path = common.dirname(self.single_watch_top .. PATHSEP .. id)
      end
      change_callback(path)
    elseif self.reverse_watched[id] then
      change_callback(self.reverse_watched[id])
    end
  end)
  local start_time = system.get_time()
  for directory, old_modified in pairs(self.scanned) do
    if old_modified then
      local info = system.get_file_info(directory)
      local new_modified = info and info.modified
      if old_modified ~= new_modified then
        change_callback(directory)
        had_change = true
        self.scanned[directory] = new_modified
      end
    end
    if system.get_time() - start_time > (scan_time or 0.01) then
      coroutine.yield(wait_time or 0.01)
      start_time = system.get_time()
    end
  end
  return had_change
end


-- inspect config.ignore_files patterns and prepare ready to use entries.
local function compile_ignore_files()
  local ipatterns = config.ignore_files
  local compiled = {}
  -- config.ignore_files could be a simple string...
  if type(ipatterns) ~= "table" then ipatterns = {ipatterns} end
  for i, pattern in ipairs(ipatterns) do
    -- we ignore malformed pattern that raise an error
    if pcall(string.match, "a", pattern) then
      table.insert(compiled, {
        use_path = pattern:match("/[^/$]"), -- contains a slash but not at the end
        -- An '/' or '/$' at the end means we want to match a directory.
        match_dir = pattern:match(".+/%$?$"), -- to be used as a boolen value
        pattern = pattern -- get the actual pattern
      })
    end
  end
  return compiled
end


local function fileinfo_pass_filter(info, ignore_compiled)
  if info.size >= config.file_size_limit * 1e6 then return false end
  local basename = common.basename(info.filename)
  -- replace '\' with '/' for Windows where PATHSEP = '\'
  local fullname = "/" .. info.filename:gsub("\\", "/")
  for _, compiled in ipairs(ignore_compiled) do
    local test = compiled.use_path and fullname or basename
    if compiled.match_dir then
      if info.type == "dir" and string.match(test .. "/", compiled.pattern) then
        return false
      end
    else
      if string.match(test, compiled.pattern) then
        return false
      end
    end
  end
  return true
end


local function compare_file(a, b)
  return a.filename < b.filename
end


-- compute a file's info entry completed with "filename" to be used
-- in project scan or falsy if it shouldn't appear in the list.
local function get_project_file_info(root, file, ignore_compiled)
  local info = system.get_file_info(root .. PATHSEP .. file)
  -- info can be not nil but info.type may be nil if is neither a file neither
  -- a directory, for example for /dev/* entries on linux.
  if info and info.type then
    info.filename = file
    return fileinfo_pass_filter(info, ignore_compiled) and info
  end
end


-- "root" will by an absolute path without trailing '/'
-- "path" will be a path starting without '/' and without trailing '/'
--    or the empty string.
--    It will identifies a sub-path within "root.
-- The current path location will therefore always be: root .. path.
-- When recursing "root" will always be the same, only "path" will change.
-- Returns a list of file "items". In each item the "filename" will be the
-- complete file path relative to "root" *without* the trailing '/', and without the starting '/'.
function dirwatch.get_directory_files(dir, root, path, t, entries_count, recurse_pred)
  local t0 = system.get_time()
  local t_elapsed = system.get_time() - t0
  local dirs, files = {}, {}
  local ignore_compiled = compile_ignore_files()


  local all = system.list_dir(root .. PATHSEP .. path)
  if not all then return nil end

  for _, file in ipairs(all or {}) do
    local info = get_project_file_info(root, (path ~= "" and (path .. PATHSEP) or "") .. file, ignore_compiled)
    if info then
      table.insert(info.type == "dir" and dirs or files, info)
      entries_count = entries_count + 1
    end
  end

  local recurse_complete = true
  table.sort(dirs, compare_file)
  for _, f in ipairs(dirs) do
    table.insert(t, f)
    if recurse_pred(dir, f.filename, entries_count, t_elapsed) then
      local _, complete, n = dirwatch.get_directory_files(dir, root, f.filename, t, entries_count, recurse_pred)
      recurse_complete = recurse_complete and complete
      if n ~= nil then
        entries_count = n
      end
    else
      recurse_complete = false
    end
  end

  table.sort(files, compare_file)
  for _, f in ipairs(files) do
    table.insert(t, f)
  end

  return t, recurse_complete, entries_count
end


return dirwatch
local core = require "core"
local common = require "core.common"
local config = require "core.config"
local tokenizer = require "core.tokenizer"
local Object = require "core.object"


local Highlighter = Object:extend()


function Highlighter:new(doc)
  self.doc = doc
  self.running = false
  self:reset()
end

-- init incremental syntax highlighting
function Highlighter:start()
  if self.running then return end
  self.running = true
  core.add_thread(function()
    while self.first_invalid_line < self.max_wanted_line do
      local max = math.min(self.first_invalid_line + 40, self.max_wanted_line)
      local retokenized_from
      for i = self.first_invalid_line, max do
        local state = (i > 1) and self.lines[i - 1].state
        local line = self.lines[i]
        if not (line and line.init_state == state and line.text == self.doc.lines[i]) then
          retokenized_from = retokenized_from or i
          self.lines[i] = self:tokenize_line(i, state)
        elseif retokenized_from then
          self:update_notify(retokenized_from, i - retokenized_from - 1)
          retokenized_from = nil
        end
      end
      if retokenized_from then
        self:update_notify(retokenized_from, max - retokenized_from)
      end

      self.first_invalid_line = max + 1
      core.redraw = true
      coroutine.yield()
    end
    self.max_wanted_line = 0
    self.running = false
  end, self)
end

local function set_max_wanted_lines(self, amount)
  self.max_wanted_line = amount
  if self.first_invalid_line < self.max_wanted_line then
    self:start()
  end
end


function Highlighter:reset()
  self.lines = {}
  self:soft_reset()
end

function Highlighter:soft_reset()
  for i=1,#self.lines do
    self.lines[i] = false
  end
  self.first_invalid_line = 1
  self.max_wanted_line = 0
end

function Highlighter:invalidate(idx)
  self.first_invalid_line = math.min(self.first_invalid_line, idx)
  set_max_wanted_lines(self, math.min(self.max_wanted_line, #self.doc.lines))
end

function Highlighter:insert_notify(line, n)
  self:invalidate(line)
  local blanks = { }
  for i = 1, n do
    blanks[i] = false
  end
  common.splice(self.lines, line, 0, blanks)
end

function Highlighter:remove_notify(line, n)
  self:invalidate(line)
  common.splice(self.lines, line, n)
end

function Highlighter:update_notify(line, n)
  -- plugins can hook here to be notified that lines have been retokenized
end


function Highlighter:tokenize_line(idx, state)
  local res = {}
  res.init_state = state
  res.text = self.doc.lines[idx]
  res.tokens, res.state = tokenizer.tokenize(self.doc.syntax, res.text, state)
  return res
end


function Highlighter:get_line(idx)
  local line = self.lines[idx]
  if not line or line.text ~= self.doc.lines[idx] then
    local prev = self.lines[idx - 1]
    line = self:tokenize_line(idx, prev and prev.state)
    self.lines[idx] = line
    self:update_notify(idx, 0)
  end
  set_max_wanted_lines(self, math.max(self.max_wanted_line, idx))
  return line
end


function Highlighter:each_token(idx)
  return tokenizer.each_token(self:get_line(idx).tokens)
end


return Highlighter
local Object = require "core.object"
local Highlighter = require "core.doc.highlighter"
local core = require "core"
local syntax = require "core.syntax"
local config = require "core.config"
local common = require "core.common"

---@class core.doc : core.object
local Doc = Object:extend()


local function split_lines(text)
  local res = {}
  for line in (text .. "\n"):gmatch("(.-)\n") do
    table.insert(res, line)
  end
  return res
end


function Doc:new(filename, abs_filename, new_file)
  self.new_file = new_file
  self:reset()
  if filename then
    self:set_filename(filename, abs_filename)
    if not new_file then
      self:load(filename)
    end
  end
end


function Doc:reset()
  self.lines = { "\n" }
  self.selections = { 1, 1, 1, 1 }
  self.last_selection = 1
  self.undo_stack = { idx = 1 }
  self.redo_stack = { idx = 1 }
  self.clean_change_id = 1
  self.highlighter = Highlighter(self)
  self:reset_syntax()
end


function Doc:reset_syntax()
  local header = self:get_text(1, 1, self:position_offset(1, 1, 128))
  local syn = syntax.get(self.filename or "", header)
  if self.syntax ~= syn then
    self.syntax = syn
    self.highlighter:soft_reset()
  end
end


function Doc:set_filename(filename, abs_filename)
  self.filename = filename
  self.abs_filename = abs_filename
  self:reset_syntax()
end


function Doc:load(filename)
  local fp = assert( io.open(filename, "rb") )
  self:reset()
  self.lines = {}
  local i = 1
  for line in fp:lines() do
    if line:byte(-1) == 13 then
      line = line:sub(1, -2)
      self.crlf = true
    end
    table.insert(self.lines, line .. "\n")
    self.highlighter.lines[i] = false
    i = i + 1
  end
  if #self.lines == 0 then
    table.insert(self.lines, "\n")
  end
  fp:close()
  self:reset_syntax()
end


function Doc:reload()
  if self.filename then
    local sel = { self:get_selection() }
    self:load(self.filename)
    self:clean()
    self:set_selection(table.unpack(sel))
  end
end


function Doc:save(filename, abs_filename)
  if not filename then
    assert(self.filename, "no filename set to default to")
    filename = self.filename
    abs_filename = self.abs_filename
  else
    assert(self.filename or abs_filename, "calling save on unnamed doc without absolute path")
  end
  local fp = assert( io.open(filename, "wb") )
  for _, line in ipairs(self.lines) do
    if self.crlf then line = line:gsub("\n", "\r\n") end
    fp:write(line)
  end
  fp:close()
  self:set_filename(filename, abs_filename)
  self.new_file = false
  self:clean()
end


function Doc:get_name()
  return self.filename or "unsaved"
end


function Doc:is_dirty()
  if self.new_file then
    return #self.lines > 1 or #self.lines[1] > 1
  else
    return self.clean_change_id ~= self:get_change_id()
  end
end


function Doc:clean()
  self.clean_change_id = self:get_change_id()
end


function Doc:get_indent_info()
  if not self.indent_info then return config.tab_type, config.indent_size, false end
  return self.indent_info.type or config.tab_type,
         self.indent_info.size or config.indent_size,
         self.indent_info.confirmed
end


function Doc:get_change_id()
  return self.undo_stack.idx
end

local function sort_positions(line1, col1, line2, col2)
  if line1 > line2 or line1 == line2 and col1 > col2 then
    return line2, col2, line1, col1, true
  end
  return line1, col1, line2, col2, false
end

-- Cursor section. Cursor indices are *only* valid during a get_selections() call.
-- Cursors will always be iterated in order from top to bottom. Through normal operation
-- curors can never swap positions; only merge or split, or change their position in cursor
-- order.
function Doc:get_selection(sort)
  local line1, col1, line2, col2, swap = self:get_selection_idx(self.last_selection, sort)
  if not line1 then
    line1, col1, line2, col2, swap = self:get_selection_idx(1, sort)
  end
  return line1, col1, line2, col2, swap
end


---Get the selection specified by `idx`
---@param idx integer @the index of the selection to retrieve
---@param sort? boolean @whether to sort the selection returned
---@return integer,integer,integer,integer,boolean? @line1, col1, line2, col2, was the selection sorted
function Doc:get_selection_idx(idx, sort)
  local line1, col1, line2, col2 = self.selections[idx*4-3], self.selections[idx*4-2], self.selections[idx*4-1], self.selections[idx*4]
  if line1 and sort then
    return sort_positions(line1, col1, line2, col2)
  else
    return line1, col1, line2, col2
  end
end

function Doc:get_selection_text(limit)
  limit = limit or math.huge
  local result = {}
  for idx, line1, col1, line2, col2 in self:get_selections() do
    if idx > limit then break end
    if line1 ~= line2 or col1 ~= col2 then
      local text = self:get_text(line1, col1, line2, col2)
      if text ~= "" then result[#result + 1] = text end
    end
  end
  return table.concat(result, "\n")
end

function Doc:has_selection()
  local line1, col1, line2, col2 = self:get_selection(false)
  return line1 ~= line2 or col1 ~= col2
end

function Doc:has_any_selection()
  for idx, line1, col1, line2, col2 in self:get_selections() do
    if line1 ~= line2 or col1 ~= col2 then return true end
  end
  return false
end

function Doc:sanitize_selection()
  for idx, line1, col1, line2, col2 in self:get_selections() do
    self:set_selections(idx, line1, col1, line2, col2)
  end
end

function Doc:set_selections(idx, line1, col1, line2, col2, swap, rm)
  assert(not line2 == not col2, "expected 3 or 5 arguments")
  if swap then line1, col1, line2, col2 = line2, col2, line1, col1 end
  line1, col1 = self:sanitize_position(line1, col1)
  line2, col2 = self:sanitize_position(line2 or line1, col2 or col1)
  common.splice(self.selections, (idx - 1)*4 + 1, rm == nil and 4 or rm, { line1, col1, line2, col2 })
end

function Doc:add_selection(line1, col1, line2, col2, swap)
  local l1, c1 = sort_positions(line1, col1, line2 or line1, col2 or col1)
  local target = #self.selections / 4 + 1
  for idx, tl1, tc1 in self:get_selections(true) do
    if l1 < tl1 or l1 == tl1 and c1 < tc1 then
      target = idx
      break
    end
  end
  self:set_selections(target, line1, col1, line2, col2, swap, 0)
  self.last_selection = target
end


function Doc:remove_selection(idx)
  if self.last_selection >= idx then
    self.last_selection = self.last_selection - 1
  end
  common.splice(self.selections, (idx - 1) * 4 + 1, 4)
end


function Doc:set_selection(line1, col1, line2, col2, swap)
  self.selections = {}
  self:set_selections(1, line1, col1, line2, col2, swap)
  self.last_selection = 1
end

function Doc:merge_cursors(idx)
  for i = (idx or (#self.selections - 3)), (idx or 5), -4 do
    for j = 1, i - 4, 4 do
      if self.selections[i] == self.selections[j] and
        self.selections[i+1] == self.selections[j+1] then
          common.splice(self.selections, i, 4)
          if self.last_selection >= (i+3)/4 then
            self.last_selection = self.last_selection - 1
          end
          break
      end
    end
  end
end

local function selection_iterator(invariant, idx)
  local target = invariant[3] and (idx*4 - 7) or (idx*4 + 1)
  if target > #invariant[1] or target <= 0 or (type(invariant[3]) == "number" and invariant[3] ~= idx - 1) then return end
  if invariant[2] then
    return idx+(invariant[3] and -1 or 1), sort_positions(table.unpack(invariant[1], target, target+4))
  else
    return idx+(invariant[3] and -1 or 1), table.unpack(invariant[1], target, target+4)
  end
end

-- If idx_reverse is true, it'll reverse iterate. If nil, or false, regular iterate.
-- If a number, runs for exactly that iteration.
function Doc:get_selections(sort_intra, idx_reverse)
  return selection_iterator, { self.selections, sort_intra, idx_reverse },
    idx_reverse == true and ((#self.selections / 4) + 1) or ((idx_reverse or -1)+1)
end
-- End of cursor seciton.

function Doc:sanitize_position(line, col)
  line = common.clamp(line, 1, #self.lines)
  col = common.clamp(col, 1, #self.lines[line])
  return line, col
end


local function position_offset_func(self, line, col, fn, ...)
  line, col = self:sanitize_position(line, col)
  return fn(self, line, col, ...)
end


local function position_offset_byte(self, line, col, offset)
  line, col = self:sanitize_position(line, col)
  col = col + offset
  while line > 1 and col < 1 do
    line = line - 1
    col = col + #self.lines[line]
  end
  while line < #self.lines and col > #self.lines[line] do
    col = col - #self.lines[line]
    line = line + 1
  end
  return self:sanitize_position(line, col)
end


local function position_offset_linecol(self, line, col, lineoffset, coloffset)
  return self:sanitize_position(line + lineoffset, col + coloffset)
end


function Doc:position_offset(line, col, ...)
  if type(...) ~= "number" then
    return position_offset_func(self, line, col, ...)
  elseif select("#", ...) == 1 then
    return position_offset_byte(self, line, col, ...)
  elseif select("#", ...) == 2 then
    return position_offset_linecol(self, line, col, ...)
  else
    error("bad number of arguments")
  end
end


function Doc:get_text(line1, col1, line2, col2)
  line1, col1 = self:sanitize_position(line1, col1)
  line2, col2 = self:sanitize_position(line2, col2)
  line1, col1, line2, col2 = sort_positions(line1, col1, line2, col2)
  if line1 == line2 then
    return self.lines[line1]:sub(col1, col2 - 1)
  end
  local lines = { self.lines[line1]:sub(col1) }
  for i = line1 + 1, line2 - 1 do
    table.insert(lines, self.lines[i])
  end
  table.insert(lines, self.lines[line2]:sub(1, col2 - 1))
  return table.concat(lines)
end


function Doc:get_char(line, col)
  line, col = self:sanitize_position(line, col)
  return self.lines[line]:sub(col, col)
end


local function push_undo(undo_stack, time, type, ...)
  undo_stack[undo_stack.idx] = { type = type, time = time, ... }
  undo_stack[undo_stack.idx - config.max_undos] = nil
  undo_stack.idx = undo_stack.idx + 1
end


local function pop_undo(self, undo_stack, redo_stack, modified)
  -- pop command
  local cmd = undo_stack[undo_stack.idx - 1]
  if not cmd then return end
  undo_stack.idx = undo_stack.idx - 1

  -- handle command
  if cmd.type == "insert" then
    local line, col, text = table.unpack(cmd)
    self:raw_insert(line, col, text, redo_stack, cmd.time)
  elseif cmd.type == "remove" then
    local line1, col1, line2, col2 = table.unpack(cmd)
    self:raw_remove(line1, col1, line2, col2, redo_stack, cmd.time)
  elseif cmd.type == "selection" then
    self.selections = { table.unpack(cmd) }
    self:sanitize_selection()
  end

  modified = modified or (cmd.type ~= "selection")

  -- if next undo command is within the merge timeout then treat as a single
  -- command and continue to execute it
  local next = undo_stack[undo_stack.idx - 1]
  if next and math.abs(cmd.time - next.time) < config.undo_merge_timeout then
    return pop_undo(self, undo_stack, redo_stack, modified)
  end

  if modified then
    self:on_text_change("undo")
  end
end


function Doc:raw_insert(line, col, text, undo_stack, time)
  -- split text into lines and merge with line at insertion point
  local lines = split_lines(text)
  local len = #lines[#lines]
  local before = self.lines[line]:sub(1, col - 1)
  local after = self.lines[line]:sub(col)
  for i = 1, #lines - 1 do
    lines[i] = lines[i] .. "\n"
  end
  lines[1] = before .. lines[1]
  lines[#lines] = lines[#lines] .. after

  -- splice lines into line array
  common.splice(self.lines, line, 1, lines)

  -- keep cursors where they should be
  for idx, cline1, ccol1, cline2, ccol2 in self:get_selections(true, true) do
    if cline1 < line then break end
    local line_addition = (line < cline1 or col < ccol1) and #lines - 1 or 0
    local column_addition = line == cline1 and ccol1 > col and len or 0
    self:set_selections(idx, cline1 + line_addition, ccol1 + column_addition, cline2 + line_addition, ccol2 + column_addition)
  end

  -- push undo
  local line2, col2 = self:position_offset(line, col, #text)
  push_undo(undo_stack, time, "selection", table.unpack(self.selections))
  push_undo(undo_stack, time, "remove", line, col, line2, col2)

  -- update highlighter and assure selection is in bounds
  self.highlighter:insert_notify(line, #lines - 1)
  self:sanitize_selection()
end


function Doc:raw_remove(line1, col1, line2, col2, undo_stack, time)
  -- push undo
  local text = self:get_text(line1, col1, line2, col2)
  push_undo(undo_stack, time, "selection", table.unpack(self.selections))
  push_undo(undo_stack, time, "insert", line1, col1, text)

  -- get line content before/after removed text
  local before = self.lines[line1]:sub(1, col1 - 1)
  local after = self.lines[line2]:sub(col2)

  -- splice line into line array
  common.splice(self.lines, line1, line2 - line1 + 1, { before .. after })

  -- move all cursors back if they share a line with the removed text
  for idx, cline1, ccol1, cline2, ccol2 in self:get_selections(true, true) do
    if cline1 < line2 then break end
    local line_removal = line2 - line1
    local column_removal = line2 == cline2 and col2 < ccol1 and (line2 == line1 and col2 - col1 or col2) or 0
    self:set_selections(idx, cline1 - line_removal, ccol1 - column_removal, cline2 - line_removal, ccol2 - column_removal)
  end

  -- update highlighter and assure selection is in bounds
  self.highlighter:remove_notify(line1, line2 - line1)
  self:sanitize_selection()
end


function Doc:insert(line, col, text)
  self.redo_stack = { idx = 1 }
  line, col = self:sanitize_position(line, col)
  self:raw_insert(line, col, text, self.undo_stack, system.get_time())
  self:on_text_change("insert")
end


function Doc:remove(line1, col1, line2, col2)
  self.redo_stack = { idx = 1 }
  line1, col1 = self:sanitize_position(line1, col1)
  line2, col2 = self:sanitize_position(line2, col2)
  line1, col1, line2, col2 = sort_positions(line1, col1, line2, col2)
  self:raw_remove(line1, col1, line2, col2, self.undo_stack, system.get_time())
  self:on_text_change("remove")
end


function Doc:undo()
  pop_undo(self, self.undo_stack, self.redo_stack, false)
end


function Doc:redo()
  pop_undo(self, self.redo_stack, self.undo_stack, false)
end


function Doc:text_input(text, idx)
  for sidx, line1, col1, line2, col2 in self:get_selections(true, idx or true) do
    if line1 ~= line2 or col1 ~= col2 then
      self:delete_to_cursor(sidx)
    end
    self:insert(line1, col1, text)
    self:move_to_cursor(sidx, #text)
  end
end


function Doc:ime_text_editing(text, start, length, idx)
  for sidx, line1, col1, line2, col2 in self:get_selections(true, idx or true) do
    if line1 ~= line2 or col1 ~= col2 then
      self:delete_to_cursor(sidx)
    end
    self:insert(line1, col1, text)
    self:set_selections(sidx, line1, col1 + #text, line1, col1)
  end
end


function Doc:replace_cursor(idx, line1, col1, line2, col2, fn)
  local old_text = self:get_text(line1, col1, line2, col2)
  local new_text, res = fn(old_text)
  if old_text ~= new_text then
    self:insert(line2, col2, new_text)
    self:remove(line1, col1, line2, col2)
    if line1 == line2 and col1 == col2 then
      line2, col2 = self:position_offset(line1, col1, #new_text)
      self:set_selections(idx, line1, col1, line2, col2)
    end
  end
  return res
end

function Doc:replace(fn)
  local has_selection, results = false, { }
  for idx, line1, col1, line2, col2 in self:get_selections(true) do
    if line1 ~= line2 or col1 ~= col2 then
      results[idx] = self:replace_cursor(idx, line1, col1, line2, col2, fn)
      has_selection = true
    end
  end
  if not has_selection then
    self:set_selection(table.unpack(self.selections))
    results[1] = self:replace_cursor(1, 1, 1, #self.lines, #self.lines[#self.lines], fn)
  end
  return results
end


function Doc:delete_to_cursor(idx, ...)
  for sidx, line1, col1, line2, col2 in self:get_selections(true, idx) do
    if line1 ~= line2 or col1 ~= col2 then
      self:remove(line1, col1, line2, col2)
    else
      local l2, c2 = self:position_offset(line1, col1, ...)
      self:remove(line1, col1, l2, c2)
      line1, col1 = sort_positions(line1, col1, l2, c2)
    end
    self:set_selections(sidx, line1, col1)
  end
  self:merge_cursors(idx)
end
function Doc:delete_to(...) return self:delete_to_cursor(nil, ...) end

function Doc:move_to_cursor(idx, ...)
  for sidx, line, col in self:get_selections(false, idx) do
    self:set_selections(sidx, self:position_offset(line, col, ...))
  end
  self:merge_cursors(idx)
end
function Doc:move_to(...) return self:move_to_cursor(nil, ...) end


function Doc:select_to_cursor(idx, ...)
  for sidx, line, col, line2, col2 in self:get_selections(false, idx) do
    line, col = self:position_offset(line, col, ...)
    self:set_selections(sidx, line, col, line2, col2)
  end
  self:merge_cursors(idx)
end
function Doc:select_to(...) return self:select_to_cursor(nil, ...) end


function Doc:get_indent_string()
  local indent_type, indent_size = self:get_indent_info()
  if indent_type == "hard" then
    return "\t"
  end
  return string.rep(" ", indent_size)
end

-- returns the size of the original indent, and the indent
-- in your config format, rounded either up or down
function Doc:get_line_indent(line, rnd_up)
  local _, e = line:find("^[ \t]+")
  local indent_type, indent_size = self:get_indent_info()
  local soft_tab = string.rep(" ", indent_size)
  if indent_type == "hard" then
    local indent = e and line:sub(1, e):gsub(soft_tab, "\t") or ""
    return e, indent:gsub(" +", rnd_up and "\t" or "")
  else
    local indent = e and line:sub(1, e):gsub("\t", soft_tab) or ""
    local number = #indent / #soft_tab
    return e, indent:sub(1,
      (rnd_up and math.ceil(number) or math.floor(number))*#soft_tab)
  end
end

-- un/indents text; behaviour varies based on selection and un/indent.
-- * if there's a selection, it will stay static around the
--   text for both indenting and unindenting.
-- * if you are in the beginning whitespace of a line, and are indenting, the
--   cursor will insert the exactly appropriate amount of spaces, and jump the
--   cursor to the beginning of first non whitespace characters
-- * if you are not in the beginning whitespace of a line, and you indent, it
--   inserts the appropriate whitespace, as if you typed them normally.
-- * if you are unindenting, the cursor will jump to the start of the line,
--   and remove the appropriate amount of spaces (or a tab).
function Doc:indent_text(unindent, line1, col1, line2, col2)
  local text = self:get_indent_string()
  local _, se = self.lines[line1]:find("^[ \t]+")
  local in_beginning_whitespace = col1 == 1 or (se and col1 <= se + 1)
  local has_selection = line1 ~= line2 or col1 ~= col2
  if unindent or has_selection or in_beginning_whitespace then
    local l1d, l2d = #self.lines[line1], #self.lines[line2]
    for line = line1, line2 do
      if not has_selection or #self.lines[line] > 1 then -- don't indent empty lines in a selection
        local e, rnded = self:get_line_indent(self.lines[line], unindent)
        self:remove(line, 1, line, (e or 0) + 1)
        self:insert(line, 1,
          unindent and rnded:sub(1, #rnded - #text) or rnded .. text)
      end
    end
    l1d, l2d = #self.lines[line1] - l1d, #self.lines[line2] - l2d
    if (unindent or in_beginning_whitespace) and not has_selection then
      local start_cursor = (se and se + 1 or 1) + l1d or #(self.lines[line1])
      return line1, start_cursor, line2, start_cursor
    end
    return line1, col1 + l1d, line2, col2 + l2d
  end
  self:insert(line1, col1, text)
  return line1, col1 + #text, line1, col1 + #text
end

-- For plugins to add custom actions of document change
function Doc:on_text_change(type)
end

-- For plugins to get notified when a document is closed
function Doc:on_close()
  core.log_quiet("Closed doc \"%s\"", self:get_name())
end


return Doc
local search = {}

local default_opt = {}


local function pattern_lower(str)
  if str:sub(1, 1) == "%" then
    return str
  end
  return str:lower()
end


local function init_args(doc, line, col, text, opt)
  opt = opt or default_opt
  line, col = doc:sanitize_position(line, col)

  if opt.no_case and not opt.regex then
    text = text:lower()
  end

  return doc, line, col, text, opt
end

-- This function is needed to uniform the behavior of
-- `regex:cmatch` and `string.find`.
local function regex_func(text, re, index, _)
  local s, e = re:cmatch(text, index)
  return s, e and e - 1
end

local function rfind(func, text, pattern, index, plain)
  local s, e = func(text, pattern, 1, plain)
  local last_s, last_e
  if index < 0 then index = #text - index + 1 end
  while e and e <= index do
    last_s, last_e = s, e
    s, e = func(text, pattern, s + 1, plain)
  end
  return last_s, last_e
end


function search.find(doc, line, col, text, opt)
  doc, line, col, text, opt = init_args(doc, line, col, text, opt)
  local plain = not opt.pattern
  local pattern = text
  local search_func = string.find
  if opt.regex then
    pattern = regex.compile(text, opt.no_case and "i" or "")
    search_func = regex_func
  end
  local start, finish, step = line, #doc.lines, 1
  if opt.reverse then
    start, finish, step = line, 1, -1
  end
  for line = start, finish, step do
    local line_text = doc.lines[line]
    if opt.no_case and not opt.regex then
      line_text = line_text:lower()
    end
    local s, e
    if opt.reverse then
      s, e = rfind(search_func, line_text, pattern, col - 1, plain)
    else
      s, e = search_func(line_text, pattern, col, plain)
    end
    if s then
      return line, s, line, e + 1
    end
    col = opt.reverse and -1 or 1
  end

  if opt.wrap then
    opt = { no_case = opt.no_case, regex = opt.regex, reverse = opt.reverse }
    if opt.reverse then
      return search.find(doc, #doc.lines, #doc.lines[#doc.lines], text, opt)
    else
      return search.find(doc, 1, 1, text, opt)
    end
  end
end


return search
local common = require "core.common"
local config = require "core.config"

-- functions for translating a Doc position to another position these functions
-- can be passed to Doc:move_to|select_to|delete_to()

local translate = {}


local function is_non_word(char)
  return config.non_word_chars:find(char, nil, true)
end


function translate.previous_char(doc, line, col)
  repeat
    line, col = doc:position_offset(line, col, -1)
  until not common.is_utf8_cont(doc:get_char(line, col))
  return line, col
end


function translate.next_char(doc, line, col)
  repeat
    line, col = doc:position_offset(line, col, 1)
  until not common.is_utf8_cont(doc:get_char(line, col))
  return line, col
end


function translate.previous_word_start(doc, line, col)
  local prev
  while line > 1 or col > 1 do
    local l, c = doc:position_offset(line, col, -1)
    local char = doc:get_char(l, c)
    if prev and prev ~= char or not is_non_word(char) then
      break
    end
    prev, line, col = char, l, c
  end
  return translate.start_of_word(doc, line, col)
end


function translate.next_word_end(doc, line, col)
  local prev
  local end_line, end_col = translate.end_of_doc(doc, line, col)
  while line < end_line or col < end_col do
    local char = doc:get_char(line, col)
    if prev and prev ~= char or not is_non_word(char) then
      break
    end
    line, col = doc:position_offset(line, col, 1)
    prev = char
  end
  return translate.end_of_word(doc, line, col)
end


function translate.start_of_word(doc, line, col)
  while true do
    local line2, col2 = doc:position_offset(line, col, -1)
    local char = doc:get_char(line2, col2)
    if is_non_word(char)
    or line == line2 and col == col2 then
      break
    end
    line, col = line2, col2
  end
  return line, col
end


function translate.end_of_word(doc, line, col)
  while true do
    local line2, col2 = doc:position_offset(line, col, 1)
    local char = doc:get_char(line, col)
    if is_non_word(char)
    or line == line2 and col == col2 then
      break
    end
    line, col = line2, col2
  end
  return line, col
end


function translate.previous_block_start(doc, line, col)
  while true do
    line = line - 1
    if line <= 1 then
      return 1, 1
    end
    if doc.lines[line-1]:find("^%s*$")
    and not doc.lines[line]:find("^%s*$") then
      return line, (doc.lines[line]:find("%S"))
    end
  end
end


function translate.next_block_end(doc, line, col)
  while true do
    if line >= #doc.lines then
      return #doc.lines, 1
    end
    if doc.lines[line+1]:find("^%s*$")
    and not doc.lines[line]:find("^%s*$") then
      return line+1, #doc.lines[line+1]
    end
    line = line + 1
  end
end


function translate.start_of_line(doc, line, col)
  return line, 1
end

function translate.start_of_indentation(doc, line, col)
  local s, e = doc.lines[line]:find("^%s*")
  return line, col > e + 1 and e + 1 or 1
end

function translate.end_of_line(doc, line, col)
  return line, math.huge
end


function translate.start_of_doc(doc, line, col)
  return 1, 1
end


function translate.end_of_doc(doc, line, col)
  return #doc.lines, #doc.lines[#doc.lines]
end


return translate
local core = require "core"
local common = require "core.common"
local config = require "core.config"
local style = require "core.style"
local keymap = require "core.keymap"
local translate = require "core.doc.translate"
local ime = require "core.ime"
local View = require "core.view"

---@class core.docview : core.view
---@field super core.view
local DocView = View:extend()

DocView.context = "session"

local function move_to_line_offset(dv, line, col, offset)
  local xo = dv.last_x_offset
  if xo.line ~= line or xo.col ~= col then
    xo.offset = dv:get_col_x_offset(line, col)
  end
  xo.line = line + offset
  xo.col = dv:get_x_offset_col(line + offset, xo.offset)
  return xo.line, xo.col
end


DocView.translate = {
  ["previous_page"] = function(doc, line, col, dv)
    local min, max = dv:get_visible_line_range()
    return line - (max - min), 1
  end,

  ["next_page"] = function(doc, line, col, dv)
    if line == #doc.lines then
      return #doc.lines, #doc.lines[line]
    end
    local min, max = dv:get_visible_line_range()
    return line + (max - min), 1
  end,

  ["previous_line"] = function(doc, line, col, dv)
    if line == 1 then
      return 1, 1
    end
    return move_to_line_offset(dv, line, col, -1)
  end,

  ["next_line"] = function(doc, line, col, dv)
    if line == #doc.lines then
      return #doc.lines, math.huge
    end
    return move_to_line_offset(dv, line, col, 1)
  end,
}


function DocView:new(doc)
  DocView.super.new(self)
  self.cursor = "ibeam"
  self.scrollable = true
  self.doc = assert(doc)
  self.font = "code_font"
  self.last_x_offset = {}
  self.ime_selection = { from = 0, size = 0 }
  self.ime_status = false
  self.hovering_gutter = false
  self.v_scrollbar:set_forced_status(config.force_scrollbar_status)
  self.h_scrollbar:set_forced_status(config.force_scrollbar_status)
end


function DocView:try_close(do_close)
  if self.doc:is_dirty()
  and #core.get_views_referencing_doc(self.doc) == 1 then
    core.command_view:enter("Unsaved Changes; Confirm Close", {
      submit = function(_, item)
        if item.text:match("^[cC]") then
          do_close()
        elseif item.text:match("^[sS]") then
          self.doc:save()
          do_close()
        end
      end,
      suggest = function(text)
        local items = {}
        if not text:find("^[^cC]") then table.insert(items, "Close Without Saving") end
        if not text:find("^[^sS]") then table.insert(items, "Save And Close") end
        return items
      end
    })
  else
    do_close()
  end
end


function DocView:get_name()
  local post = self.doc:is_dirty() and "*" or ""
  local name = self.doc:get_name()
  return name:match("[^/%\\]*$") .. post
end


function DocView:get_filename()
  if self.doc.abs_filename then
    local post = self.doc:is_dirty() and "*" or ""
    return common.home_encode(self.doc.abs_filename) .. post
  end
  return self:get_name()
end


function DocView:get_scrollable_size()
  if not config.scroll_past_end then
    return self:get_line_height() * (#self.doc.lines) + style.padding.y * 2
  end
  return self:get_line_height() * (#self.doc.lines - 1) + self.size.y
end

function DocView:get_h_scrollable_size()
  return math.huge
end


function DocView:get_font()
  return style[self.font]
end


function DocView:get_line_height()
  return math.floor(self:get_font():get_height() * config.line_height)
end


function DocView:get_gutter_width()
  local padding = style.padding.x * 2
  return self:get_font():get_width(#self.doc.lines) + padding, padding
end


function DocView:get_line_screen_position(line, col)
  local x, y = self:get_content_offset()
  local lh = self:get_line_height()
  local gw = self:get_gutter_width()
  y = y + (line-1) * lh + style.padding.y
  if col then
    return x + gw + self:get_col_x_offset(line, col), y
  else
    return x + gw, y
  end
end

function DocView:get_line_text_y_offset()
  local lh = self:get_line_height()
  local th = self:get_font():get_height()
  return (lh - th) / 2
end


function DocView:get_visible_line_range()
  local x, y, x2, y2 = self:get_content_bounds()
  local lh = self:get_line_height()
  local minline = math.max(1, math.floor(y / lh))
  local maxline = math.min(#self.doc.lines, math.floor(y2 / lh) + 1)
  return minline, maxline
end


function DocView:get_col_x_offset(line, col)
  local default_font = self:get_font()
  local column = 1
  local xoffset = 0
  for _, type, text in self.doc.highlighter:each_token(line) do
    local font = style.syntax_fonts[type] or default_font
    for char in common.utf8_chars(text) do
      if column == col then
        return xoffset
      end
      xoffset = xoffset + font:get_width(char)
      column = column + #char
    end
  end

  return xoffset
end


function DocView:get_x_offset_col(line, x)
  local line_text = self.doc.lines[line]

  local xoffset, last_i, i = 0, 1, 1
  local default_font = self:get_font()
  for _, type, text in self.doc.highlighter:each_token(line) do
    local font = style.syntax_fonts[type] or default_font
    for char in common.utf8_chars(text) do
      local w = font:get_width(char)
      if xoffset >= x then
        return (xoffset - x > w / 2) and last_i or i
      end
      xoffset = xoffset + w
      last_i = i
      i = i + #char
    end
  end

  return #line_text
end


function DocView:resolve_screen_position(x, y)
  local ox, oy = self:get_line_screen_position(1)
  local line = math.floor((y - oy) / self:get_line_height()) + 1
  line = common.clamp(line, 1, #self.doc.lines)
  local col = self:get_x_offset_col(line, x - ox)
  return line, col
end


function DocView:scroll_to_line(line, ignore_if_visible, instant)
  local min, max = self:get_visible_line_range()
  if not (ignore_if_visible and line > min and line < max) then
    local x, y = self:get_line_screen_position(line)
    local ox, oy = self:get_content_offset()
    self.scroll.to.y = math.max(0, y - oy - self.size.y / 2)
    if instant then
      self.scroll.y = self.scroll.to.y
    end
  end
end


function DocView:scroll_to_make_visible(line, col)
  local ox, oy = self:get_content_offset()
  local _, ly = self:get_line_screen_position(line, col)
  local lh = self:get_line_height()
  self.scroll.to.y = common.clamp(self.scroll.to.y, ly - oy - self.size.y + lh * 2, ly - oy - lh)
  local gw = self:get_gutter_width()
  local xoffset = self:get_col_x_offset(line, col)
  local xmargin = 3 * self:get_font():get_width(' ')
  local xsup = xoffset + gw + xmargin
  local xinf = xoffset - xmargin
  if xsup > self.scroll.x + self.size.x then
    self.scroll.to.x = xsup - self.size.x
  elseif xinf < self.scroll.x then
    self.scroll.to.x = math.max(0, xinf)
  end
end

function DocView:on_mouse_moved(x, y, ...)
  DocView.super.on_mouse_moved(self, x, y, ...)

  self.hovering_gutter = false
  local gw = self:get_gutter_width()

  if self:scrollbar_hovering() or self:scrollbar_dragging() then
    self.cursor = "arrow"
  elseif gw > 0 and x >= self.position.x and x <= (self.position.x + gw) then
    self.cursor = "arrow"
    self.hovering_gutter = true
  else
    self.cursor = "ibeam"
  end

  if self.mouse_selecting then
    local l1, c1 = self:resolve_screen_position(x, y)
    local l2, c2, snap_type = table.unpack(self.mouse_selecting)
    if keymap.modkeys["ctrl"] then
      if l1 > l2 then l1, l2 = l2, l1 end
      self.doc.selections = { }
      for i = l1, l2 do
        self.doc:set_selections(i - l1 + 1, i, math.min(c1, #self.doc.lines[i]), i, math.min(c2, #self.doc.lines[i]))
      end
    else
      if snap_type then
        l1, c1, l2, c2 = self:mouse_selection(self.doc, snap_type, l1, c1, l2, c2)
      end
      self.doc:set_selection(l1, c1, l2, c2)
    end
  end
end


function DocView:mouse_selection(doc, snap_type, line1, col1, line2, col2)
  local swap = line2 < line1 or line2 == line1 and col2 <= col1
  if swap then
    line1, col1, line2, col2 = line2, col2, line1, col1
  end
  if snap_type == "word" then
    line1, col1 = translate.start_of_word(doc, line1, col1)
    line2, col2 = translate.end_of_word(doc, line2, col2)
  elseif snap_type == "lines" then
    col1, col2 = 1, math.huge
  end
  if swap then
    return line2, col2, line1, col1
  end
  return line1, col1, line2, col2
end


function DocView:on_mouse_pressed(button, x, y, clicks)
  if button ~= "left" or not self.hovering_gutter then
    return DocView.super.on_mouse_pressed(self, button, x, y, clicks)
  end
  local line = self:resolve_screen_position(x, y)
  if keymap.modkeys["shift"] then
    local sline, scol, sline2, scol2 = self.doc:get_selection(true)
    if line > sline then
      self.doc:set_selection(sline, 1, line,  #self.doc.lines[line])
    else
      self.doc:set_selection(line, 1, sline2, #self.doc.lines[sline2])
    end
  else
    if clicks == 1 then
      self.doc:set_selection(line, 1, line, 1)
    elseif clicks == 2 then
      self.doc:set_selection(line, 1, line, #self.doc.lines[line])
    end
  end
  return true
end


function DocView:on_mouse_released(...)
  DocView.super.on_mouse_released(self, ...)
  self.mouse_selecting = nil
end


function DocView:on_text_input(text)
  self.doc:text_input(text)
end

function DocView:on_ime_text_editing(text, start, length)
  self.doc:ime_text_editing(text, start, length)
  self.ime_status = #text > 0
  self.ime_selection.from = start
  self.ime_selection.size = length

  -- Set the composition bounding box that the system IME
  -- will consider when drawing its interface
  local line1, col1, line2, col2 = self.doc:get_selection(true)
  local col = math.min(col1, col2)
  self:update_ime_location()
  self:scroll_to_make_visible(line1, col + start)
end

---Update the composition bounding box that the system IME
---will consider when drawing its interface
function DocView:update_ime_location()
  if not self.ime_status then return end

  local line1, col1, line2, col2 = self.doc:get_selection(true)
  local x, y = self:get_line_screen_position(line1)
  local h = self:get_line_height()
  local col = math.min(col1, col2)

  local x1, x2 = 0, 0

  if self.ime_selection.size > 0 then
    -- focus on a part of the text
    local from = col + self.ime_selection.from
    local to = from + self.ime_selection.size
    x1 = self:get_col_x_offset(line1, from)
    x2 = self:get_col_x_offset(line1, to)
  else
    -- focus the whole text
    x1 = self:get_col_x_offset(line1, col1)
    x2 = self:get_col_x_offset(line2, col2)
  end

  ime.set_location(x + x1, y, x2 - x1, h)
end

function DocView:update()
  -- scroll to make caret visible and reset blink timer if it moved
  local line1, col1, line2, col2 = self.doc:get_selection()
  if (line1 ~= self.last_line1 or col1 ~= self.last_col1 or
      line2 ~= self.last_line2 or col2 ~= self.last_col2) and self.size.x > 0 then
    if core.active_view == self and not ime.editing then
      self:scroll_to_make_visible(line1, col1)
    end
    core.blink_reset()
    self.last_line1, self.last_col1 = line1, col1
    self.last_line2, self.last_col2 = line2, col2
  end

  -- update blink timer
  if self == core.active_view and not self.mouse_selecting then
    local T, t0 = config.blink_period, core.blink_start
    local ta, tb = core.blink_timer, system.get_time()
    if ((tb - t0) % T < T / 2) ~= ((ta - t0) % T < T / 2) then
      core.redraw = true
    end
    core.blink_timer = tb
  end

  self:update_ime_location()

  DocView.super.update(self)
end


function DocView:draw_line_highlight(x, y)
  local lh = self:get_line_height()
  renderer.draw_rect(x, y, self.size.x, lh, style.line_highlight)
end


function DocView:draw_line_text(line, x, y)
  local default_font = self:get_font()
  local tx, ty = x, y + self:get_line_text_y_offset()
  local last_token = nil
  local tokens = self.doc.highlighter:get_line(line).tokens
  local tokens_count = #tokens
  if string.sub(tokens[tokens_count], -1) == "\n" then
    last_token = tokens_count - 1
  end
  for tidx, type, text in self.doc.highlighter:each_token(line) do
    local color = style.syntax[type]
    local font = style.syntax_fonts[type] or default_font
    -- do not render newline, fixes issue #1164
    if tidx == last_token then text = text:sub(1, -2) end
    tx = renderer.draw_text(font, text, tx, ty, color)
  end
  return self:get_line_height()
end

function DocView:draw_caret(x, y)
    local lh = self:get_line_height()
    renderer.draw_rect(x, y, style.caret_width, lh, style.caret)
end

function DocView:draw_line_body(line, x, y)
  -- draw highlight if any selection ends on this line
  local draw_highlight = false
  local hcl = config.highlight_current_line
  if hcl ~= false then
    for lidx, line1, col1, line2, col2 in self.doc:get_selections(false) do
      if line1 == line then
        if hcl == "no_selection" then
          if (line1 ~= line2) or (col1 ~= col2) then
            draw_highlight = false
            break
          end
        end
        draw_highlight = true
        break
      end
    end
  end
  if draw_highlight and core.active_view == self then
    self:draw_line_highlight(x + self.scroll.x, y)
  end

  -- draw selection if it overlaps this line
  local lh = self:get_line_height()
  for lidx, line1, col1, line2, col2 in self.doc:get_selections(true) do
    if line >= line1 and line <= line2 then
      local text = self.doc.lines[line]
      if line1 ~= line then col1 = 1 end
      if line2 ~= line then col2 = #text + 1 end
      local x1 = x + self:get_col_x_offset(line, col1)
      local x2 = x + self:get_col_x_offset(line, col2)
      if x1 ~= x2 then
        renderer.draw_rect(x1, y, x2 - x1, lh, style.selection)
      end
    end
  end

  -- draw line's text
  return self:draw_line_text(line, x, y)
end


function DocView:draw_line_gutter(line, x, y, width)
  local color = style.line_number
  for _, line1, _, line2 in self.doc:get_selections(true) do
    if line >= line1 and line <= line2 then
      color = style.line_number2
      break
    end
  end
  x = x + style.padding.x
  local lh = self:get_line_height()
  common.draw_text(self:get_font(), color, line, "right", x, y, width, lh)
  return lh
end


function DocView:draw_ime_decoration(line1, col1, line2, col2)
  local x, y = self:get_line_screen_position(line1)
  local line_size = math.max(1, SCALE)
  local lh = self:get_line_height()

  -- Draw IME underline
  local x1 = self:get_col_x_offset(line1, col1)
  local x2 = self:get_col_x_offset(line2, col2)
  renderer.draw_rect(x + math.min(x1, x2), y + lh - line_size, math.abs(x1 - x2), line_size, style.text)

  -- Draw IME selection
  local col = math.min(col1, col2)
  local from = col + self.ime_selection.from
  local to = from + self.ime_selection.size
  x1 = self:get_col_x_offset(line1, from)
  if from ~= to then
    x2 = self:get_col_x_offset(line1, to)
    line_size = style.caret_width
    renderer.draw_rect(x + math.min(x1, x2), y + lh - line_size, math.abs(x1 - x2), line_size, style.caret)
  end
  self:draw_caret(x + x1, y)
end


function DocView:draw_overlay()
  if core.active_view == self then
    local minline, maxline = self:get_visible_line_range()
    -- draw caret if it overlaps this line
    local T = config.blink_period
    for _, line1, col1, line2, col2 in self.doc:get_selections() do
      if line1 >= minline and line1 <= maxline
      and system.window_has_focus() then
        if ime.editing then
          self:draw_ime_decoration(line1, col1, line2, col2)
        else
          if config.disable_blink
          or (core.blink_timer - core.blink_start) % T < T / 2 then
            self:draw_caret(self:get_line_screen_position(line1, col1))
          end
        end
      end
    end
  end
end

function DocView:draw()
  self:draw_background(style.background)
  local _, indent_size = self.doc:get_indent_info()
  self:get_font():set_tab_size(indent_size)

  local minline, maxline = self:get_visible_line_range()
  local lh = self:get_line_height()

  local x, y = self:get_line_screen_position(minline)
  local gw, gpad = self:get_gutter_width()
  for i = minline, maxline do
    y = y + (self:draw_line_gutter(i, self.position.x, y, gpad and gw - gpad or gw) or lh)
  end

  local pos = self.position
  x, y = self:get_line_screen_position(minline)
  -- the clip below ensure we don't write on the gutter region. On the
  -- right side it is redundant with the Node's clip.
  core.push_clip_rect(pos.x + gw, pos.y, self.size.x - gw, self.size.y)
  for i = minline, maxline do
    y = y + (self:draw_line_body(i, x, y) or lh)
  end
  self:draw_overlay()
  core.pop_clip_rect()

  self:draw_scrollbar()
end


return DocView
local style = require "core.style"
local keymap = require "core.keymap"
local View = require "core.view"

---@class core.emptyview : core.view
---@field super core.view
local EmptyView = View:extend()

local function draw_text(x, y, color)
  local th = style.big_font:get_height()
  local dh = 2 * th + style.padding.y * 2
  local x1, y1 = x, y + (dh - th) / 2
  local xv = x1
  local title = "Lite XL"
  local version = "version " .. VERSION
  local title_width = style.big_font:get_width(title)
  local version_width = style.font:get_width(version)
  if version_width > title_width then
    version = VERSION
    version_width = style.font:get_width(version)
    xv = x1 - (version_width - title_width)
  end
  x = renderer.draw_text(style.big_font, title, x1, y1, color)
  renderer.draw_text(style.font, version, xv, y1 + th, color)
  x = x + style.padding.x
  renderer.draw_rect(x, y, math.ceil(1 * SCALE), dh, color)
  local lines = {
    { fmt = "%s to run a command", cmd = "core:find-command" },
    { fmt = "%s to open a file from the project", cmd = "core:find-file" },
    { fmt = "%s to change project folder", cmd = "core:change-project-folder" },
    { fmt = "%s to open a project folder", cmd = "core:open-project-folder" },
  }
  th = style.font:get_height()
  y = y + (dh - (th + style.padding.y) * #lines) / 2
  local w = 0
  for _, line in ipairs(lines) do
    local text = string.format(line.fmt, keymap.get_binding(line.cmd))
    w = math.max(w, renderer.draw_text(style.font, text, x + style.padding.x, y, color))
    y = y + th + style.padding.y
  end
  return w, dh
end

function EmptyView:draw()
  self:draw_background(style.background)
  local w, h = draw_text(0, 0, { 0, 0, 0, 0 })
  local x = self.position.x + math.max(style.padding.x, (self.size.x - w) / 2)
  local y = self.position.y + (self.size.y - h) / 2
  draw_text(x, y, style.dim)
end

return EmptyView
local core = require "core"

local ime = { }

function ime.reset()
  ime.editing = false
  ime.last_location = { x = 0, y = 0, w = 0, h = 0 }
end

---Convert from utf-8 offset and length (from SDL) to byte offsets
---@param text string @Textediting string
---@param start integer @0-based utf-8 offset of the starting position of the selection
---@param length integer @Size of the utf-8 length of the selection
function ime.ingest(text, start, length)
  if #text == 0 then
    -- finished textediting
    ime.reset()
    return "", 0, 0
  end

  ime.editing = true

  if start < 0 then
    -- we assume no selection and caret at the end
    return text, #text, 0
  end

  -- start is 0-based, so we use start + 1
  local start_byte = utf8.offset(text, start + 1)
  if not start_byte then
    -- bad start offset
    -- we assume it meant the last byte of the text
    start_byte = #text
  else
    start_byte = math.min(start_byte - 1, #text)
  end

  if length < 0 then
    -- caret only
    return text, start_byte, 0
  end

  local end_byte = utf8.offset(text, start + length + 1)
  if not end_byte or end_byte - 1 < start_byte then
    -- bad length, assume caret only
    return text, start_byte, 0
  end

  end_byte = math.min(end_byte - 1, #text)
  return text, start_byte, end_byte - start_byte
end

---Forward the given textediting SDL event data to Views.
---@param text string @Textediting string
---@param start integer @0-based utf-8 offset of the starting position of the selection
---@param length integer @Size of the utf-8 length of the selection
function ime.on_text_editing(text, start, length, ...)
  if ime.editing or #text > 0 then
    core.root_view:on_ime_text_editing(ime.ingest(text, start, length, ...))
  end
end

---Stop IME composition.
---Might not completely work on every platform.
function ime.stop()
  if ime.editing then
    -- SDL_ClearComposition for now doesn't work everywhere
    system.clear_ime()
    ime.on_text_editing("", 0, 0)
  end
end

---Set the bounding box of the text pertaining the IME.
---The IME will draw its interface based on this info.
---@param x number
---@param y number
---@param w number
---@param h number
function ime.set_location(x, y, w, h)
  if not ime.last_location or
     ime.last_location.x ~= x or
     ime.last_location.y ~= y or
     ime.last_location.w ~= w or
     ime.last_location.h ~= h
  then
    ime.last_location.x, ime.last_location.y, ime.last_location.w, ime.last_location.h = x, y, w, h
    system.set_text_input_rect(x, y, w, h)
  end
end

ime.reset()
return ime
require "core.strict"
require "core.regex"
local common = require "core.common"
local config = require "core.config"
local style = require "colors.default"
local command
local keymap
local dirwatch
local ime
local RootView
local StatusView
local TitleView
local CommandView
local NagView
local DocView
local Doc

local core = {}

local function load_session()
  local ok, t = pcall(dofile, USERDIR .. "/session.lua")
  return ok and t or {}
end


local function save_session()
  local fp = io.open(USERDIR .. "/session.lua", "w")
  if fp then
    fp:write("return {recents=", common.serialize(core.recent_projects),
      ", window=", common.serialize(table.pack(system.get_window_size())),
      ", window_mode=", common.serialize(system.get_window_mode()),
      ", previous_find=", common.serialize(core.previous_find),
      ", previous_replace=", common.serialize(core.previous_replace),
      "}\n")
    fp:close()
  end
end


local function update_recents_project(action, dir_path_abs)
  local dirname = common.normalize_volume(dir_path_abs)
  if not dirname then return end
  local recents = core.recent_projects
  local n = #recents
  for i = 1, n do
    if dirname == recents[i] then
      table.remove(recents, i)
      break
    end
  end
  if action == "add" then
    table.insert(recents, 1, dirname)
  end
end


function core.set_project_dir(new_dir, change_project_fn)
  local chdir_ok = pcall(system.chdir, new_dir)
  if chdir_ok then
    if change_project_fn then change_project_fn() end
    core.project_dir = common.normalize_volume(new_dir)
    core.project_directories = {}
  end
  return chdir_ok
end


local function reload_customizations()
  local user_error = not core.load_user_directory()
  local project_error = not core.load_project_module()
  if user_error or project_error then
    -- Use core.add_thread to delay opening the LogView, as opening
    -- it directly here disturbs the normal save operations.
    core.add_thread(function()
      local LogView = require "core.logview"
      local rn = core.root_view.root_node
      for _,v in pairs(core.root_view.root_node:get_children()) do
        if v:is(LogView) then
          rn:get_node_for_view(v):set_active_view(v)
          return
        end
      end
      command.perform("core:open-log")
    end)
  end
end


function core.open_folder_project(dir_path_abs)
  if core.set_project_dir(dir_path_abs, core.on_quit_project) then
    core.root_view:close_all_docviews()
    reload_customizations()
    update_recents_project("add", dir_path_abs)
    core.add_project_directory(dir_path_abs)
    core.on_enter_project(dir_path_abs)
  end
end


local function strip_leading_path(filename)
    return filename:sub(2)
end

local function strip_trailing_slash(filename)
  if filename:match("[^:][/\\]$") then
    return filename:sub(1, -2)
  end
  return filename
end


function core.project_subdir_is_shown(dir, filename)
  return not dir.files_limit or dir.shown_subdir[filename]
end


local function show_max_files_warning(dir)
  local message = dir.slow_filesystem and
    "Filesystem is too slow: project files will not be indexed." or
    "Too many files in project directory: stopped reading at "..
    config.max_project_files.." files. For more information see "..
    "usage.md at https://github.com/lite-xl/lite-xl."
  if core.status_view then
    core.status_view:show_message("!", style.accent, message)
  end
end


-- bisects the sorted file list to get to things in ln(n)
local function file_bisect(files, is_superior, start_idx, end_idx)
  local inf, sup = start_idx or 1, end_idx or #files
  while sup - inf > 8 do
    local curr = math.floor((inf + sup) / 2)
    if is_superior(files[curr]) then
      sup = curr - 1
    else
      inf = curr
    end
  end
  while inf <= sup and not is_superior(files[inf]) do
    inf = inf + 1
  end
  return inf
end


local function file_search(files, info)
  local idx = file_bisect(files, function(file)
    return system.path_compare(info.filename, info.type, file.filename, file.type)
  end)
  if idx > 1 and files[idx-1].filename == info.filename then
    return idx - 1, true
  end
  return idx, false
end


local function files_info_equal(a, b)
  return (a == nil and b == nil) or (a and b and a.filename == b.filename and a.type == b.type)
end


local function project_subdir_bounds(dir, filename, start_index)
  local found = true
  if not start_index then
    start_index, found = file_search(dir.files, { type = "dir", filename = filename })
  end
  if found then
    local end_index = file_bisect(dir.files, function(file)
      return not common.path_belongs_to(file.filename, filename)
    end, start_index + 1)
    return start_index, end_index - start_index, dir.files[start_index]
  end
end


-- Should be called on any directory that registers a change, or on a directory we open if we're over the file limit.
-- Uses relative paths at the project root (i.e. target = "", target = "first-level-directory", target = "first-level-directory/second-level-directory")
local function refresh_directory(topdir, target)
  local directory_start_idx, directory_end_idx = 1, #topdir.files
  if target and target ~= "" then
    directory_start_idx, directory_end_idx = project_subdir_bounds(topdir, target)
    directory_end_idx = directory_start_idx + directory_end_idx - 1
    directory_start_idx = directory_start_idx + 1
  end

  local files = dirwatch.get_directory_files(topdir, topdir.name, (target or ""), {}, 0, function() return false end)
  local change = false

  -- If this file doesn't exist, we should be calling this on our parent directory, assume we'll do that.
  -- Unwatch just in case.
  if files == nil then
    topdir.watch:unwatch(topdir.name .. PATHSEP .. (target or ""))
    return true
  end

  local new_idx, old_idx = 1, directory_start_idx
  local new_directories = {}
  -- Run through each sorted list and compare them. If we find a new entry, insert it and flag as new. If we're missing an entry
  -- remove it and delete the entry from the list.
  while old_idx <= directory_end_idx or new_idx <= #files do
    local old_info, new_info = topdir.files[old_idx], files[new_idx]
    if not files_info_equal(new_info, old_info) then
      change = true
      -- If we're a new file, and we exist *before* the other file in the list, then add to the list.
      if not old_info or (new_info and system.path_compare(new_info.filename, new_info.type, old_info.filename, old_info.type)) then
        table.insert(topdir.files, old_idx, new_info)
        old_idx, new_idx = old_idx + 1, new_idx + 1
        if new_info.type == "dir" then
          table.insert(new_directories, new_info)
        end
        directory_end_idx = directory_end_idx + 1
      else
      -- If it's not there, remove the entry from the list as being out of order.
        table.remove(topdir.files, old_idx)
        if old_info.type == "dir" then
          topdir.watch:unwatch(topdir.name .. PATHSEP .. old_info.filename)
        end
        directory_end_idx = directory_end_idx - 1
      end
    else
      -- If this file is a directory, determine in ln(n) the size of the directory, and skip every file in it.
      local size = old_info and old_info.type == "dir" and select(2, project_subdir_bounds(topdir, old_info.filename, old_idx)) or 1
      old_idx, new_idx = old_idx + size, new_idx + 1
    end
  end
  for i, v in ipairs(new_directories) do
    topdir.watch:watch(topdir.name .. PATHSEP .. v.filename)
    if not topdir.files_limit or core.project_subdir_is_shown(topdir, v.filename) then
      refresh_directory(topdir, v.filename)
    end
  end
  if change then
    core.redraw = true
    topdir.is_dirty = true
  end
  return change
end


-- Predicate function to inhibit directory recursion in get_directory_files
-- based on a time limit and the number of files.
local function timed_max_files_pred(dir, filename, entries_count, t_elapsed)
  local n_limit = entries_count <= config.max_project_files
  local t_limit = t_elapsed < 20 / config.fps
  return n_limit and t_limit and core.project_subdir_is_shown(dir, filename)
end


function core.add_project_directory(path)
  -- top directories has a file-like "item" but the item.filename
  -- will be simply the name of the directory, without its path.
  -- The field item.topdir will identify it as a top level directory.
  path = common.normalize_volume(path)
  local topdir = {
    name = path,
    item = {filename = common.basename(path), type = "dir", topdir = true},
    files_limit = false,
    is_dirty = true,
    shown_subdir = {},
    watch_thread = nil,
    watch = dirwatch.new()
  }
  table.insert(core.project_directories, topdir)

  local fstype = PLATFORM == "Linux" and system.get_fs_type(topdir.name) or "unknown"
  topdir.force_scans = (fstype == "nfs" or fstype == "fuse")
  local t, complete, entries_count = dirwatch.get_directory_files(topdir, topdir.name, "", {}, 0, timed_max_files_pred)
  topdir.files = t
  if not complete then
    topdir.slow_filesystem = not complete and (entries_count <= config.max_project_files)
    topdir.files_limit = true
    show_max_files_warning(topdir)
    refresh_directory(topdir)
  else
    for i,v in ipairs(t) do
      if v.type == "dir" then topdir.watch:watch(path .. PATHSEP .. v.filename) end
    end
  end
  topdir.watch:watch(topdir.name)
  -- each top level directory gets a watch thread. if the project is small, or
  -- if the ablity to use directory watches hasn't been compromised in some way
  -- either through error, or amount of files, then this should be incredibly
  -- quick; essentially one syscall per check. Otherwise, this may take a bit of
  -- time; the watch will yield in this coroutine after 0.01 second, for 0.1 seconds.
  topdir.watch_thread = core.add_thread(function()
    while true do
      local changed = topdir.watch:check(function(target)
        if target == topdir.name then return refresh_directory(topdir) end
        local dirpath = target:sub(#topdir.name + 2)
        local abs_dirpath = topdir.name .. PATHSEP .. dirpath
        if dirpath then
          -- check if the directory is in the project files list, if not exit.
          local dir_index, dir_match = file_search(topdir.files, {filename = dirpath, type = "dir"})
          if not dir_match or not core.project_subdir_is_shown(topdir, topdir.files[dir_index].filename) then return end
        end
        return refresh_directory(topdir, dirpath)
      end, 0.01, 0.01)
      -- properly exit coroutine if project not open anymore to clear dir watch
      local project_dir_open = false
      for _, prj in ipairs(core.project_directories) do
        if topdir == prj then
          project_dir_open = true
          break
        end
      end
      if project_dir_open then
        coroutine.yield(changed and 0.05 or 0)
      else
        return
      end
    end
  end)

  if path == core.project_dir then
    core.project_files = topdir.files
  end
  core.redraw = true
  return topdir
end


-- The function below is needed to reload the project directories
-- when the project's module changes.
function core.rescan_project_directories()
  local save_project_dirs = {}
  local n = #core.project_directories
  for i = 1, n do
    local dir = core.project_directories[i]
    save_project_dirs[i] = {name = dir.name, shown_subdir = dir.shown_subdir}
  end
  core.project_directories = {}
  for i = 1, n do -- add again the directories in the project
    local dir = core.add_project_directory(save_project_dirs[i].name)
    if dir.files_limit then
      -- We need to sort the list of shown subdirectories so that higher level
      -- directories are populated first. We use the function system.path_compare
      -- because it order the entries in the appropriate order.
      -- TODO: we may consider storing the table shown_subdir as a sorted table
      -- since the beginning.
      local subdir_list = {}
      for subdir in pairs(save_project_dirs[i].shown_subdir) do
        table.insert(subdir_list, subdir)
      end
      table.sort(subdir_list, function(a, b) return system.path_compare(a, "dir", b, "dir") end)
      for _, subdir in ipairs(subdir_list) do
        local show = save_project_dirs[i].shown_subdir[subdir]
        for j = 1, #dir.files do
          if dir.files[j].filename == subdir then
            -- The instructions below match when happens in TreeView:on_mouse_pressed.
            -- We perform the operations only once iff the subdir is in dir.files.
            -- In theory set_show below may fail and return false but is it is listed
            -- there it means it succeeded before so we are optimistically assume it
            -- will not fail for the sake of simplicity.
            core.update_project_subdir(dir, subdir, show)
            break
          end
        end
      end
    end
  end
end


function core.project_dir_by_name(name)
  for i = 1, #core.project_directories do
    if core.project_directories[i].name == name then
      return core.project_directories[i]
    end
  end
end


function core.update_project_subdir(dir, filename, expanded)
  assert(dir.files_limit, "function should be called only when directory is in files limit mode")
  dir.shown_subdir[filename] = expanded
  if expanded then
    dir.watch:watch(dir.name .. PATHSEP .. filename)
  else
    dir.watch:unwatch(dir.name .. PATHSEP .. filename)
  end
  return refresh_directory(dir, filename)
end


-- Find files and directories recursively reading from the filesystem.
-- Filter files and yields file's directory and info table. This latter
-- is filled to be like required by project directories "files" list.
local function find_files_rec(root, path)
  local all = system.list_dir(root .. path) or {}
  for _, file in ipairs(all) do
    local file = path .. PATHSEP .. file
    local info = system.get_file_info(root .. file)
    if info then
      info.filename = strip_leading_path(file)
      if info.type == "file" then
        coroutine.yield(root, info)
      elseif not common.match_pattern(common.basename(info.filename), config.ignore_files) then
        find_files_rec(root, PATHSEP .. info.filename)
      end
    end
  end
end


-- Iterator function to list all project files
local function project_files_iter(state)
  local dir = core.project_directories[state.dir_index]
  if state.co then
    -- We have a coroutine to fetch for files, use the coroutine.
    -- Used for directories that exceeds the files nuumber limit.
    local ok, name, file = coroutine.resume(state.co, dir.name, "")
    if ok and name then
      return name, file
    else
      -- The coroutine terminated, increment file/dir counter to scan
      -- next project directory.
      state.co = false
      state.file_index = 1
      state.dir_index = state.dir_index + 1
      dir = core.project_directories[state.dir_index]
    end
  else
    -- Increase file/dir counter
    state.file_index = state.file_index + 1
    while dir and state.file_index > #dir.files do
      state.dir_index = state.dir_index + 1
      state.file_index = 1
      dir = core.project_directories[state.dir_index]
    end
  end
  if not dir then return end
  if dir.files_limit then
    -- The current project directory is files limited: create a couroutine
    -- to read files from the filesystem.
    state.co = coroutine.create(find_files_rec)
    return project_files_iter(state)
  end
  return dir.name, dir.files[state.file_index]
end


function core.get_project_files()
  local state = { dir_index = 1, file_index = 0 }
  return project_files_iter, state
end


function core.project_files_number()
  local n = 0
  for i = 1, #core.project_directories do
    if core.project_directories[i].files_limit then return end
    n = n + #core.project_directories[i].files
  end
  return n
end


-- create a directory using mkdir but may need to create the parent
-- directories as well.
local function create_user_directory()
  local success, err = common.mkdirp(USERDIR)
  if not success then
    error("cannot create directory \"" .. USERDIR .. "\": " .. err)
  end
  for _, modname in ipairs {'plugins', 'colors', 'fonts'} do
    local subdirname = USERDIR .. PATHSEP .. modname
    if not system.mkdir(subdirname) then
      error("cannot create directory: \"" .. subdirname .. "\"")
    end
  end
end


local function write_user_init_file(init_filename)
  local init_file = io.open(init_filename, "w")
  if not init_file then error("cannot create file: \"" .. init_filename .. "\"") end
  init_file:write([[
-- put user settings here
-- this module will be loaded after everything else when the application starts
-- it will be automatically reloaded when saved

local core = require "core"
local keymap = require "core.keymap"
local config = require "core.config"
local style = require "core.style"

------------------------------ Themes ----------------------------------------

-- light theme:
-- core.reload_module("colors.summer")

--------------------------- Key bindings -------------------------------------

-- key binding:
-- keymap.add { ["ctrl+escape"] = "core:quit" }

-- pass 'true' for second parameter to overwrite an existing binding
-- keymap.add({ ["ctrl+pageup"] = "root:switch-to-previous-tab" }, true)
-- keymap.add({ ["ctrl+pagedown"] = "root:switch-to-next-tab" }, true)

------------------------------- Fonts ----------------------------------------

-- customize fonts:
-- style.font = renderer.font.load(DATADIR .. "/fonts/FiraSans-Regular.ttf", 14 * SCALE)
-- style.code_font = renderer.font.load(DATADIR .. "/fonts/JetBrainsMono-Regular.ttf", 14 * SCALE)
--
-- DATADIR is the location of the installed Lite XL Lua code, default color
-- schemes and fonts.
-- USERDIR is the location of the Lite XL configuration directory.
--
-- font names used by lite:
-- style.font          : user interface
-- style.big_font      : big text in welcome screen
-- style.icon_font     : icons
-- style.icon_big_font : toolbar icons
-- style.code_font     : code
--
-- the function to load the font accept a 3rd optional argument like:
--
-- {antialiasing="grayscale", hinting="full", bold=true, italic=true, underline=true, smoothing=true, strikethrough=true}
--
-- possible values are:
-- antialiasing: grayscale, subpixel
-- hinting: none, slight, full
-- bold: true, false
-- italic: true, false
-- underline: true, false
-- smoothing: true, false
-- strikethrough: true, false

------------------------------ Plugins ----------------------------------------

-- enable or disable plugin loading setting config entries:

-- enable plugins.trimwhitespace, otherwise it is disabled by default:
-- config.plugins.trimwhitespace = true
--
-- disable detectindent, otherwise it is enabled by default
-- config.plugins.detectindent = false

---------------------------- Miscellaneous -------------------------------------

-- modify list of files to ignore when indexing the project:
-- config.ignore_files = {
--   -- folders
--   "^%.svn/",        "^%.git/",   "^%.hg/",        "^CVS/", "^%.Trash/", "^%.Trash%-.*/",
--   "^node_modules/", "^%.cache/", "^__pycache__/",
--   -- files
--   "%.pyc$",         "%.pyo$",       "%.exe$",        "%.dll$",   "%.obj$", "%.o$",
--   "%.a$",           "%.lib$",       "%.so$",         "%.dylib$", "%.ncb$", "%.sdf$",
--   "%.suo$",         "%.pdb$",       "%.idb$",        "%.class$", "%.psd$", "%.db$",
--   "^desktop%.ini$", "^%.DS_Store$", "^%.directory$",
-- }

]])
  init_file:close()
end


function core.write_init_project_module(init_filename)
  local init_file = io.open(init_filename, "w")
  if not init_file then error("cannot create file: \"" .. init_filename .. "\"") end
  init_file:write([[
-- Put project's module settings here.
-- This module will be loaded when opening a project, after the user module
-- configuration.
-- It will be automatically reloaded when saved.

local config = require "core.config"

-- you can add some patterns to ignore files within the project
-- config.ignore_files = {"^%.", <some-patterns>}

-- Patterns are normally applied to the file's or directory's name, without
-- its path. See below about how to apply filters on a path.
--
-- Here some examples:
--
-- "^%." match any file of directory whose basename begins with a dot.
--
-- When there is an '/' or a '/$' at the end the pattern it will only match
-- directories. When using such a pattern a final '/' will be added to the name
-- of any directory entry before checking if it matches.
--
-- "^%.git/" matches any directory named ".git" anywhere in the project.
--
-- If a "/" appears anywhere in the pattern except if it appears at the end or
-- is immediately followed by a '$' then the pattern will be applied to the full
-- path of the file or directory. An initial "/" will be prepended to the file's
-- or directory's path to indicate the project's root.
--
-- "^/node_modules/" will match a directory named "node_modules" at the project's root.
-- "^/build.*/" match any top level directory whose name begins with "build"
-- "^/subprojects/.+/" match any directory inside a top-level folder named "subprojects".

-- You may activate some plugins on a per-project basis to override the user's settings.
-- config.plugins.trimwitespace = true
]])
  init_file:close()
end


function core.load_user_directory()
  return core.try(function()
    local stat_dir = system.get_file_info(USERDIR)
    if not stat_dir then
      create_user_directory()
    end
    local init_filename = USERDIR .. "/init.lua"
    local stat_file = system.get_file_info(init_filename)
    if not stat_file then
      write_user_init_file(init_filename)
    end
    dofile(init_filename)
  end)
end


function core.remove_project_directory(path)
  -- skip the fist directory because it is the project's directory
  for i = 2, #core.project_directories do
    local dir = core.project_directories[i]
    if dir.name == path then
      table.remove(core.project_directories, i)
      return true
    end
  end
  return false
end


function core.configure_borderless_window()
  system.set_window_bordered(not config.borderless)
  core.title_view:configure_hit_test(config.borderless)
  core.title_view.visible = config.borderless
end


local function add_config_files_hooks()
  -- auto-realod style when user's module is saved by overriding Doc:Save()
  local doc_save = Doc.save
  local user_filename = system.absolute_path(USERDIR .. PATHSEP .. "init.lua")
  function Doc:save(filename, abs_filename)
    local module_filename = system.absolute_path(".lite_project.lua")
    doc_save(self, filename, abs_filename)
    if self.abs_filename == user_filename or self.abs_filename == module_filename then
      reload_customizations()
      core.rescan_project_directories()
      core.configure_borderless_window()
    end
  end
end


-- The function below works like system.absolute_path except it
-- doesn't fail if the file does not exist. We consider that the
-- current dir is core.project_dir so relative filename are considered
-- to be in core.project_dir.
-- Please note that .. or . in the filename are not taken into account.
-- This function should get only filenames normalized using
-- common.normalize_path function.
function core.project_absolute_path(filename)
  if common.is_absolute_path(filename) then
    return common.normalize_path(filename)
  elseif not core.project_dir then
    local cwd = system.absolute_path(".")
    return cwd .. PATHSEP .. common.normalize_path(filename)
  else
    return core.project_dir .. PATHSEP .. filename
  end
end


function core.init()
  command = require "core.command"
  keymap = require "core.keymap"
  dirwatch = require "core.dirwatch"
  ime = require "core.ime"
  RootView = require "core.rootview"
  StatusView = require "core.statusview"
  TitleView = require "core.titleview"
  CommandView = require "core.commandview"
  NagView = require "core.nagview"
  DocView = require "core.docview"
  Doc = require "core.doc"

  if PATHSEP == '\\' then
    USERDIR = common.normalize_volume(USERDIR)
    DATADIR = common.normalize_volume(DATADIR)
    EXEDIR  = common.normalize_volume(EXEDIR)
  end

  do
    local session = load_session()
    if session.window_mode == "normal" then
      system.set_window_size(table.unpack(session.window))
    elseif session.window_mode == "maximized" then
      system.set_window_mode("maximized")
    end
    core.recent_projects = session.recents or {}
    core.previous_find = session.previous_find or {}
    core.previous_replace = session.previous_replace or {}
  end

  local project_dir = core.recent_projects[1] or "."
  local project_dir_explicit = false
  local files = {}
  for i = 2, #ARGS do
    local arg_filename = strip_trailing_slash(ARGS[i])
    local info = system.get_file_info(arg_filename) or {}
    if info.type == "dir" then
      project_dir = arg_filename
      project_dir_explicit = true
    else
      -- on macOS we can get an argument like "-psn_0_52353" that we just ignore.
      if not ARGS[i]:match("^-psn") then
        local file_abs = core.project_absolute_path(arg_filename)
        if file_abs then
          table.insert(files, file_abs)
          project_dir = file_abs:match("^(.+)[/\\].+$")
        end
      end
    end
  end

  core.frame_start = 0
  core.clip_rect_stack = {{ 0,0,0,0 }}
  core.log_items = {}
  core.docs = {}
  core.cursor_clipboard = {}
  core.cursor_clipboard_whole_line = {}
  core.window_mode = "normal"
  core.threads = setmetatable({}, { __mode = "k" })
  core.blink_start = system.get_time()
  core.blink_timer = core.blink_start
  core.redraw = true
  core.visited_files = {}
  core.restart_request = false
  core.quit_request = false

  -- We load core views before plugins that may need them.
  ---@type core.rootview
  core.root_view = RootView()
  ---@type core.commandview
  core.command_view = CommandView()
  ---@type core.statusview
  core.status_view = StatusView()
  ---@type core.nagview
  core.nag_view = NagView()
  ---@type core.titleview
  core.title_view = TitleView()

  -- Some plugins (eg: console) require the nodes to be initialized to defaults
  local cur_node = core.root_view.root_node
  cur_node.is_primary_node = true
  cur_node:split("up", core.title_view, {y = true})
  cur_node = cur_node.b
  cur_node:split("up", core.nag_view, {y = true})
  cur_node = cur_node.b
  cur_node = cur_node:split("down", core.command_view, {y = true})
  cur_node = cur_node:split("down", core.status_view, {y = true})

  -- Load defaiult commands first so plugins can override them
  command.add_defaults()

  -- Load user module, plugins and project module
  local got_user_error, got_project_error = not core.load_user_directory()

  local project_dir_abs = system.absolute_path(project_dir)
  -- We prevent set_project_dir below to effectively add and scan the directory because the
  -- project module and its ignore files is not yet loaded.
  local set_project_ok = project_dir_abs and core.set_project_dir(project_dir_abs)
  if set_project_ok then
    got_project_error = not core.load_project_module()
    if project_dir_explicit then
      update_recents_project("add", project_dir_abs)
    end
  else
    if not project_dir_explicit then
      update_recents_project("remove", project_dir)
    end
    project_dir_abs = system.absolute_path(".")
    if not core.set_project_dir(project_dir_abs, function()
      got_project_error = not core.load_project_module()
    end) then
      system.show_fatal_error("Lite XL internal error", "cannot set project directory to cwd")
      os.exit(1)
    end
  end

  -- Load core plugins after user ones to let the user override them
  local plugins_success, plugins_refuse_list = core.load_plugins()

  do
    local pdir, pname = project_dir_abs:match("(.*)[/\\\\](.*)")
    core.log("Opening project %q from directory %s", pname, pdir)
  end

  -- We add the project directory now because the project's module is loaded.
  core.add_project_directory(project_dir_abs)

  -- We assume we have just a single project directory here. Now that StatusView
  -- is there show max files warning if needed.
  if core.project_directories[1].files_limit then
    show_max_files_warning(core.project_directories[1])
  end

  for _, filename in ipairs(files) do
    core.root_view:open_doc(core.open_doc(filename))
  end

  if not plugins_success or got_user_error or got_project_error then
    command.perform("core:open-log")
  end

  core.configure_borderless_window()

  if #plugins_refuse_list.userdir.plugins > 0 or #plugins_refuse_list.datadir.plugins > 0 then
    local opt = {
      { font = style.font, text = "Exit", default_no = true },
      { font = style.font, text = "Continue" , default_yes = true }
    }
    local msg = {}
    for _, entry in pairs(plugins_refuse_list) do
      if #entry.plugins > 0 then
        msg[#msg + 1] = string.format("Plugins from directory \"%s\":\n%s", common.home_encode(entry.dir), table.concat(entry.plugins, "\n"))
      end
    end
    core.nag_view:show(
      "Refused Plugins",
      string.format(
        "Some plugins are not loaded due to version mismatch.\n\n%s.\n\n" ..
        "Please download a recent version from https://github.com/lite-xl/lite-xl-plugins.",
        table.concat(msg, ".\n\n")),
      opt, function(item)
        if item.text == "Exit" then os.exit(1) end
      end)
  end

  add_config_files_hooks()
end


function core.confirm_close_docs(docs, close_fn, ...)
  local dirty_count = 0
  local dirty_name
  for _, doc in ipairs(docs or core.docs) do
    if doc:is_dirty() then
      dirty_count = dirty_count + 1
      dirty_name = doc:get_name()
    end
  end
  if dirty_count > 0 then
    local text
    if dirty_count == 1 then
      text = string.format("\"%s\" has unsaved changes. Quit anyway?", dirty_name)
    else
      text = string.format("%d docs have unsaved changes. Quit anyway?", dirty_count)
    end
    local args = {...}
    local opt = {
      { font = style.font, text = "Yes", default_yes = true },
      { font = style.font, text = "No" , default_no = true }
    }
    core.nag_view:show("Unsaved Changes", text, opt, function(item)
      if item.text == "Yes" then close_fn(table.unpack(args)) end
    end)
  else
    close_fn(...)
  end
end

local temp_uid = math.floor(system.get_time() * 1000) % 0xffffffff
local temp_file_prefix = string.format(".lite_temp_%08x", tonumber(temp_uid))
local temp_file_counter = 0

function core.delete_temp_files(dir)
  dir = type(dir) == "string" and common.normalize_path(dir) or USERDIR
  for _, filename in ipairs(system.list_dir(dir) or {}) do
    if filename:find(temp_file_prefix, 1, true) == 1 then
      os.remove(dir .. PATHSEP .. filename)
    end
  end
end

function core.temp_filename(ext, dir)
  dir = type(dir) == "string" and common.normalize_path(dir) or USERDIR
  temp_file_counter = temp_file_counter + 1
  return dir .. PATHSEP .. temp_file_prefix
      .. string.format("%06x", temp_file_counter) .. (ext or "")
end

-- override to perform an operation before quitting or entering the
-- current project
do
  local do_nothing = function() end
  core.on_quit_project = do_nothing
  core.on_enter_project = do_nothing
end


local function quit_with_function(quit_fn, force)
  if force then
    core.delete_temp_files()
    core.on_quit_project()
    save_session()
    quit_fn()
  else
    core.confirm_close_docs(core.docs, quit_with_function, quit_fn, true)
  end
end

function core.quit(force)
  quit_with_function(function() core.quit_request = true end, force)
end


function core.restart()
  quit_with_function(function() core.restart_request = true end)
end


local function get_plugin_details(filename)
  local info = system.get_file_info(filename)
  if info ~= nil and info.type == "dir" then
    filename = filename .. "/init.lua"
    info = system.get_file_info(filename)
  end
  if not info or not filename:match("%.lua$") then return false end
  local priority = false
  local version_match = false
  for line in io.lines(filename) do
    if not version_match then
      local mod_version = line:match('%-%-.*%f[%a]mod%-version%s*:%s*(%d+)')
      if mod_version then
        version_match = (mod_version == MOD_VERSION)
      end
    end
    if not priority then
      priority = line:match('%-%-.*%f[%a]priority%s*:%s*(%d+)')
      if priority then priority = tonumber(priority) end
    end
    if version_match then
      break
    end
  end
  return true, {
    version_match = version_match,
    priority = priority or 100
  }
end


function core.load_plugins()
  local no_errors = true
  local refused_list = {
    userdir = {dir = USERDIR, plugins = {}},
    datadir = {dir = DATADIR, plugins = {}},
  }
  local files, ordered = {}, {}
  for _, root_dir in ipairs {DATADIR, USERDIR} do
    local plugin_dir = root_dir .. "/plugins"
    for _, filename in ipairs(system.list_dir(plugin_dir) or {}) do
      if not files[filename] then
        table.insert(
          ordered, {file = filename}
        )
      end
      -- user plugins will always replace system plugins
      files[filename] = plugin_dir
    end
  end

  for _, plugin in ipairs(ordered) do
    local dir = files[plugin.file]
    local name = plugin.file:match("(.-)%.lua$") or plugin.file
    local is_lua_file, details = get_plugin_details(dir .. '/' .. plugin.file)

    plugin.valid = is_lua_file
    plugin.name = name
    plugin.dir = dir
    plugin.priority = details and details.priority or 100
    plugin.version_match = details and details.version_match or false
  end

  -- sort by priority or name for plugins that have same priority
  table.sort(ordered, function(a, b)
    if a.priority ~= b.priority then
      return a.priority < b.priority
    end
    return a.name < b.name
  end)

  local load_start = system.get_time()
  for _, plugin in ipairs(ordered) do
    if plugin.valid then
      if not config.skip_plugins_version and not plugin.version_match then
        core.log_quiet(
          "Version mismatch for plugin %q from %s",
          plugin.name,
          plugin.dir
        )
        local rlist = plugin.dir:find(USERDIR, 1, true) == 1
          and 'userdir' or 'datadir'
        local list = refused_list[rlist].plugins
        table.insert(list, plugin.file)
      elseif config.plugins[plugin.name] ~= false then
        local start = system.get_time()
        local ok = core.try(require, "plugins." .. plugin.name)
        if ok then
          core.log_quiet(
            "Loaded plugin %q from %s in %.1fms",
            plugin.name,
            plugin.dir,
            (system.get_time() - start) * 1000
          )
        end
        if not ok then
          no_errors = false
        end
      end
    end
  end
  core.log_quiet(
    "Loaded all plugins in %.1fms",
    (system.get_time() - load_start) * 1000
  )
  return no_errors, refused_list
end


function core.load_project_module()
  local filename = ".lite_project.lua"
  if system.get_file_info(filename) then
    return core.try(function()
      local fn, err = loadfile(filename)
      if not fn then error("Error when loading project module:\n\t" .. err) end
      fn()
      core.log_quiet("Loaded project module")
    end)
  end
  return true
end


function core.reload_module(name)
  local old = package.loaded[name]
  package.loaded[name] = nil
  local new = require(name)
  if type(old) == "table" then
    for k, v in pairs(new) do old[k] = v end
    package.loaded[name] = old
  end
end


function core.set_visited(filename)
  for i = 1, #core.visited_files do
    if core.visited_files[i] == filename then
      table.remove(core.visited_files, i)
      break
    end
  end
  table.insert(core.visited_files, 1, filename)
end


function core.set_active_view(view)
  assert(view, "Tried to set active view to nil")
  -- Reset the IME even if the focus didn't change
  ime.stop()
  if view ~= core.active_view then
    if core.active_view and core.active_view.force_focus then
      core.next_active_view = view
      return
    end
    core.next_active_view = nil
    if view.doc and view.doc.filename then
      core.set_visited(view.doc.filename)
    end
    core.last_active_view = core.active_view
    core.active_view = view
  end
end


function core.show_title_bar(show)
  core.title_view.visible = show
end


function core.add_thread(f, weak_ref, ...)
  local key = weak_ref or #core.threads + 1
  local args = {...}
  local fn = function() return core.try(f, table.unpack(args)) end
  core.threads[key] = { cr = coroutine.create(fn), wake = 0 }
  return key
end


function core.push_clip_rect(x, y, w, h)
  local x2, y2, w2, h2 = table.unpack(core.clip_rect_stack[#core.clip_rect_stack])
  local r, b, r2, b2 = x+w, y+h, x2+w2, y2+h2
  x, y = math.max(x, x2), math.max(y, y2)
  b, r = math.min(b, b2), math.min(r, r2)
  w, h = r-x, b-y
  table.insert(core.clip_rect_stack, { x, y, w, h })
  renderer.set_clip_rect(x, y, w, h)
end


function core.pop_clip_rect()
  table.remove(core.clip_rect_stack)
  local x, y, w, h = table.unpack(core.clip_rect_stack[#core.clip_rect_stack])
  renderer.set_clip_rect(x, y, w, h)
end


function core.normalize_to_project_dir(filename)
  filename = common.normalize_path(filename)
  if common.path_belongs_to(filename, core.project_dir) then
    filename = common.relative_path(core.project_dir, filename)
  end
  return filename
end


function core.open_doc(filename)
  local new_file = not filename or not system.get_file_info(filename)
  local abs_filename
  if filename then
    -- normalize filename and set absolute filename then
    -- try to find existing doc for filename
    filename = core.normalize_to_project_dir(filename)
    abs_filename = core.project_absolute_path(filename)
    for _, doc in ipairs(core.docs) do
      if doc.abs_filename and abs_filename == doc.abs_filename then
        return doc
      end
    end
  end
  -- no existing doc for filename; create new
  local doc = Doc(filename, abs_filename, new_file)
  table.insert(core.docs, doc)
  core.log_quiet(filename and "Opened doc \"%s\"" or "Opened new doc", filename)
  return doc
end


function core.get_views_referencing_doc(doc)
  local res = {}
  local views = core.root_view.root_node:get_children()
  for _, view in ipairs(views) do
    if view.doc == doc then table.insert(res, view) end
  end
  return res
end


function core.custom_log(level, show, backtrace, fmt, ...)
  local text = string.format(fmt, ...)
  if show then
    local s = style.log[level]
    core.status_view:show_message(s.icon, s.color, text)
  end

  local info = debug.getinfo(2, "Sl")
  local at = string.format("%s:%d", info.short_src, info.currentline)
  local item = {
    level = level,
    text = text,
    time = os.time(),
    at = at,
    info = backtrace and debug.traceback("", 2):gsub("\t", "")
  }
  table.insert(core.log_items, item)
  if #core.log_items > config.max_log_items then
    table.remove(core.log_items, 1)
  end
  return item
end


function core.log(...)
  return core.custom_log("INFO", true, false, ...)
end


function core.log_quiet(...)
  return core.custom_log("INFO", false, false, ...)
end

function core.warn(...)
  return core.custom_log("WARN", true, true, ...)
end

function core.error(...)
  return core.custom_log("ERROR", true, true, ...)
end


function core.get_log(i)
  if i == nil then
    local r = {}
    for _, item in ipairs(core.log_items) do
      table.insert(r, core.get_log(item))
    end
    return table.concat(r, "\n")
  end
  local item = type(i) == "number" and core.log_items[i] or i
  local text = string.format("%s [%s] %s at %s", os.date(nil, item.time), item.level, item.text, item.at)
  if item.info then
    text = string.format("%s\n%s\n", text, item.info)
  end
  return text
end


function core.try(fn, ...)
  local err
  local ok, res = xpcall(fn, function(msg)
    local item = core.error("%s", msg)
    item.info = debug.traceback("", 2):gsub("\t", "")
    err = msg
  end, ...)
  if ok then
    return true, res
  end
  return false, err
end

function core.on_event(type, ...)
  local did_keymap = false
  if type == "textinput" then
    core.root_view:on_text_input(...)
  elseif type == "textediting" then
    ime.on_text_editing(...)
  elseif type == "keypressed" then
    did_keymap = keymap.on_key_pressed(...)
  elseif type == "keyreleased" then
    keymap.on_key_released(...)
  elseif type == "mousemoved" then
    core.root_view:on_mouse_moved(...)
  elseif type == "mousepressed" then
    if not core.root_view:on_mouse_pressed(...) then
      did_keymap = keymap.on_mouse_pressed(...)
    end
  elseif type == "mousereleased" then
    core.root_view:on_mouse_released(...)
  elseif type == "mouseleft" then
    core.root_view:on_mouse_left()
  elseif type == "mousewheel" then
    if not core.root_view:on_mouse_wheel(...) then
      did_keymap = keymap.on_mouse_wheel(...)
    end
  elseif type == "resized" then
    core.window_mode = system.get_window_mode()
  elseif type == "minimized" or type == "maximized" or type == "restored" then
    core.window_mode = type == "restored" and "normal" or type
  elseif type == "filedropped" then
    if not core.root_view:on_file_dropped(...) then
      local filename, mx, my = ...
      local info = system.get_file_info(filename)
      if info and info.type == "dir" then
        system.exec(string.format("%q %q", EXEFILE, filename))
      else
        local ok, doc = core.try(core.open_doc, filename)
        if ok then
          local node = core.root_view.root_node:get_child_overlapping_point(mx, my)
          node:set_active_view(node.active_view)
          core.root_view:open_doc(doc)
        end
      end
    end
  elseif type == "focuslost" then
    core.root_view:on_focus_lost(...)
  elseif type == "quit" then
    core.quit()
  end
  return did_keymap
end


local function get_title_filename(view)
  local doc_filename = view.get_filename and view:get_filename() or view:get_name()
  if doc_filename ~= "---" then return doc_filename end
  return ""
end


function core.compose_window_title(title)
  return (title == "" or title == nil) and "Lite XL" or title .. " - Lite XL"
end


function core.step()
  -- handle events
  local did_keymap = false

  for type, a,b,c,d in system.poll_event do
    if type == "textinput" and did_keymap then
      did_keymap = false
    elseif type == "mousemoved" then
      core.try(core.on_event, type, a, b, c, d)
    else
      local _, res = core.try(core.on_event, type, a, b, c, d)
      did_keymap = res or did_keymap
    end
    core.redraw = true
  end

  local width, height = renderer.get_size()

  -- update
  core.root_view.size.x, core.root_view.size.y = width, height
  core.root_view:update()
  if not core.redraw then return false end
  core.redraw = false

  -- close unreferenced docs
  for i = #core.docs, 1, -1 do
    local doc = core.docs[i]
    if #core.get_views_referencing_doc(doc) == 0 then
      table.remove(core.docs, i)
      doc:on_close()
    end
  end

  -- update window title
  local current_title = get_title_filename(core.active_view)
  if current_title ~= nil and current_title ~= core.window_title then
    system.set_window_title(core.compose_window_title(current_title))
    core.window_title = current_title
  end

  -- draw
  renderer.begin_frame()
  core.clip_rect_stack[1] = { 0, 0, width, height }
  renderer.set_clip_rect(table.unpack(core.clip_rect_stack[1]))
  core.root_view:draw()
  renderer.end_frame()
  return true
end


local run_threads = coroutine.wrap(function()
  while true do
    local max_time = 1 / config.fps - 0.004
    local need_more_work = false

    for k, thread in pairs(core.threads) do
      -- run thread
      if thread.wake < system.get_time() then
        local _, wait = assert(coroutine.resume(thread.cr))
        if coroutine.status(thread.cr) == "dead" then
          if type(k) == "number" then
            table.remove(core.threads, k)
          else
            core.threads[k] = nil
          end
        elseif wait then
          thread.wake = system.get_time() + wait
        else
          need_more_work = true
        end
      end

      -- stop running threads if we're about to hit the end of frame
      if system.get_time() - core.frame_start > max_time then
        coroutine.yield(true)
      end
    end

    if not need_more_work then coroutine.yield(false) end
  end
end)


function core.run()
  local idle_iterations = 0
  while true do
    core.frame_start = system.get_time()
    local need_more_work = run_threads()
    local did_redraw = core.step()
    if core.restart_request or core.quit_request then break end
    if not did_redraw and not need_more_work then
      idle_iterations = idle_iterations + 1
      -- do not wait of events at idle_iterations = 1 to give a chance at core.step to run
      -- and set "redraw" flag.
      if idle_iterations > 1 then
        if system.window_has_focus() then
          -- keep running even with no events to make the cursor blinks
          local t = system.get_time() - core.blink_start
          local h = config.blink_period / 2
          local dt = math.ceil(t / h) * h - t
          system.wait_event(dt + 1 / config.fps)
        else
          system.wait_event()
        end
      end
    else
      idle_iterations = 0
      local elapsed = system.get_time() - core.frame_start
      system.sleep(math.max(0, 1 / config.fps - elapsed))
    end
  end
end


function core.blink_reset()
  core.blink_start = system.get_time()
end


function core.request_cursor(value)
  core.cursor_change_req = value
end


function core.on_error(err)
  -- write error to file
  local fp = io.open(USERDIR .. "/error.txt", "wb")
  fp:write("Error: " .. tostring(err) .. "\n")
  fp:write(debug.traceback("", 4) .. "\n")
  fp:close()
  -- save copy of all unsaved documents
  for _, doc in ipairs(core.docs) do
    if doc:is_dirty() and doc.filename then
      doc:save(doc.filename .. "~")
    end
  end
end


return core
local function keymap_macos(keymap)
  keymap.add_direct {
    ["cmd+shift+p"] = "core:find-command",
    ["cmd+p"] = "core:find-file",
    ["cmd+o"] = "core:open-file",
    ["cmd+n"] = "core:new-doc",
    ["cmd+shift+c"] = "core:change-project-folder",
    ["cmd+shift+o"] = "core:open-project-folder",
    ["cmd+option+r"] = "core:restart",
    ["cmd+ctrl+return"] = "core:toggle-fullscreen",

    ["cmd+ctrl+shift+j"] = "root:split-left",
    ["cmd+ctrl+shift+l"] = "root:split-right",
    ["cmd+ctrl+shift+i"] = "root:split-up",
    ["cmd+ctrl+shift+k"] = "root:split-down",
    ["cmd+ctrl+j"] = "root:switch-to-left",
    ["cmd+ctrl+l"] = "root:switch-to-right",
    ["cmd+ctrl+i"] = "root:switch-to-up",
    ["cmd+ctrl+k"] = "root:switch-to-down",


    ["cmd+w"] = "root:close-or-quit",
    ["ctrl+tab"] = "root:switch-to-next-tab",
    ["ctrl+shift+tab"] = "root:switch-to-previous-tab",
    ["cmd+pageup"] = "root:move-tab-left",
    ["cmd+pagedown"] = "root:move-tab-right",
    ["cmd+1"] = "root:switch-to-tab-1",
    ["cmd+2"] = "root:switch-to-tab-2",
    ["cmd+3"] = "root:switch-to-tab-3",
    ["cmd+4"] = "root:switch-to-tab-4",
    ["cmd+5"] = "root:switch-to-tab-5",
    ["cmd+6"] = "root:switch-to-tab-6",
    ["cmd+7"] = "root:switch-to-tab-7",
    ["cmd+8"] = "root:switch-to-tab-8",
    ["cmd+9"] = "root:switch-to-tab-9",
    ["wheel"] = "root:scroll",
    ["hwheel"] = "root:horizontal-scroll",
    ["shift+hwheel"] = "root:horizontal-scroll",

    ["cmd+f"] = "find-replace:find",
    ["cmd+r"] = "find-replace:replace",
    ["f3"] = "find-replace:repeat-find",
    ["shift+f3"] = "find-replace:previous-find",
    ["cmd+g"] = "doc:go-to-line",
    ["cmd+s"] = "doc:save",
    ["cmd+shift+s"] = "doc:save-as",

    ["cmd+z"] = "doc:undo",
    ["cmd+y"] = "doc:redo",
    ["cmd+x"] = "doc:cut",
    ["cmd+c"] = "doc:copy",
    ["cmd+v"] = "doc:paste",
    ["ctrl+insert"] = "doc:copy",
    ["shift+insert"] = "doc:paste",
    ["escape"] = { "command:escape", "doc:select-none", "dialog:select-no" },
    ["tab"] = { "command:complete", "doc:indent" },
    ["shift+tab"] = "doc:unindent",
    ["backspace"] = "doc:backspace",
    ["shift+backspace"] = "doc:backspace",
    ["option+backspace"] = "doc:delete-to-previous-word-start",
    ["cmd+shift+backspace"] = "doc:delete-to-previous-word-start",
    ["cmd+backspace"] = "doc:delete-to-start-of-indentation",
    ["delete"] = "doc:delete",
    ["shift+delete"] = "doc:delete",
    ["option+delete"] = "doc:delete-to-next-word-end",
    ["cmd+shift+delete"] = "doc:delete-to-next-word-end",
    ["cmd+delete"] = "doc:delete-to-end-of-line",
    ["return"] = { "command:submit", "doc:newline", "dialog:select" },
    ["keypad enter"] = { "command:submit", "doc:newline", "dialog:select" },
    ["cmd+return"] = "doc:newline-below",
    ["cmd+shift+return"] = "doc:newline-above",
    ["cmd+j"] = "doc:join-lines",
    ["cmd+a"] = "doc:select-all",
    ["cmd+d"] = { "find-replace:select-add-next", "doc:select-word" },
    ["cmd+f3"] = "find-replace:select-next",
    ["cmd+l"] = "doc:select-lines",
    ["cmd+shift+l"] = { "find-replace:select-add-all", "doc:select-word" },
    ["cmd+/"] = "doc:toggle-line-comments",
    ["option+up"] = "doc:move-lines-up",
    ["option+down"] = "doc:move-lines-down",
    ["cmd+shift+d"] = "doc:duplicate-lines",
    ["cmd+shift+k"] = "doc:delete-lines",

    ["left"] = { "doc:move-to-previous-char", "dialog:previous-entry" },
    ["right"] = { "doc:move-to-next-char", "dialog:next-entry"},
    ["up"] = { "command:select-previous", "doc:move-to-previous-line" },
    ["down"] = { "command:select-next", "doc:move-to-next-line" },
    ["option+left"] = "doc:move-to-previous-word-start",
    ["option+right"] = "doc:move-to-next-word-end",
    ["cmd+left"] = "doc:move-to-start-of-indentation",
    ["cmd+right"] = "doc:move-to-end-of-line",
    ["cmd+["] = "doc:move-to-previous-block-start",
    ["cmd+]"] = "doc:move-to-next-block-end",
    ["home"] = "doc:move-to-start-of-indentation",
    ["end"] = "doc:move-to-end-of-line",
    ["cmd+up"] = "doc:move-to-start-of-doc",
    ["cmd+down"] = "doc:move-to-end-of-doc",
    ["pageup"] = "doc:move-to-previous-page",
    ["pagedown"] = "doc:move-to-next-page",

    ["shift+1lclick"] = "doc:select-to-cursor",
    ["ctrl+1lclick"] = "doc:split-cursor",
    ["1lclick"] = "doc:set-cursor",
    ["2lclick"] = "doc:set-cursor-word",
    ["3lclick"] = "doc:set-cursor-line",
    ["shift+left"] = "doc:select-to-previous-char",
    ["shift+right"] = "doc:select-to-next-char",
    ["shift+up"] = "doc:select-to-previous-line",
    ["shift+down"] = "doc:select-to-next-line",
    ["option+shift+left"] = "doc:select-to-previous-word-start",
    ["option+shift+right"] = "doc:select-to-next-word-end",
    ["cmd+shift+left"] = "doc:select-to-start-of-indentation",
    ["cmd+shift+right"] = "doc:select-to-end-of-line",
    ["cmd+shift+["] = "doc:select-to-previous-block-start",
    ["cmd+shift+]"] = "doc:select-to-next-block-end",
    ["shift+home"] = "doc:select-to-start-of-indentation",
    ["shift+end"] = "doc:select-to-end-of-line",
    ["cmd+shift+up"] = "doc:select-to-start-of-doc",
    ["cmd+shift+down"] = "doc:select-to-end-of-doc",
    ["shift+pageup"] = "doc:select-to-previous-page",
    ["shift+pagedown"] = "doc:select-to-next-page",
    ["cmd+option+up"] = "doc:create-cursor-previous-line",
    ["cmd+option+down"] = "doc:create-cursor-next-line"
  }
end

return keymap_macos
local core = require "core"
local command = require "core.command"
local config = require "core.config"
local ime = require "core.ime"
local keymap = {}

---@alias keymap.shortcut string
---@alias keymap.command string
---@alias keymap.modkey string
---@alias keymap.pressed boolean
---@alias keymap.map table<keymap.shortcut,keymap.command|keymap.command[]>
---@alias keymap.rmap table<keymap.command, keymap.shortcut|keymap.shortcut[]>

---Pressed status of mod keys.
---@type table<keymap.modkey, keymap.pressed>
keymap.modkeys = {}

---List of commands assigned to a shortcut been the key of the map the shortcut.
---@type keymap.map
keymap.map = {}

---List of shortcuts assigned to a command been the key of the map the command.
---@type keymap.rmap
keymap.reverse_map = {}

local macos = PLATFORM == "Mac OS X"

-- Thanks to mathewmariani, taken from his lite-macos github repository.
local modkeys_os = require("core.modkeys-" .. (macos and "macos" or "generic"))

---@type table<keymap.modkey, keymap.modkey>
local modkey_map = modkeys_os.map

---@type keymap.modkey[]
local modkeys = modkeys_os.keys


---Generates a stroke sequence including currently pressed mod keys.
---@param key string
---@return string
local function key_to_stroke(key)
  local stroke = ""
  for _, mk in ipairs(modkeys) do
    if keymap.modkeys[mk] then
      stroke = stroke .. mk .. "+"
    end
  end
  return stroke .. key
end


---Remove the given value from an array associated to a key in a table.
---@param tbl table<string, string> The table containing the key
---@param k string The key containing the array
---@param v? string The value to remove from the array
local function remove_only(tbl, k, v)
  if tbl[k] then
    if v then
      local j = 0
      for i=1, #tbl[k] do
        while tbl[k][i + j] == v do
          j = j + 1
        end
        tbl[k][i] = tbl[k][i + j]
      end
    else
      tbl[k] = nil
    end
  end
end


---Removes from a keymap.map the bindings that are already registered.
---@param map keymap.map
local function remove_duplicates(map)
  for stroke, commands in pairs(map) do
    if type(commands) == "string" or type(commands) == "function" then
      commands = { commands }
    end
    if keymap.map[stroke] then
      for _, registered_cmd in ipairs(keymap.map[stroke]) do
        local j = 0
        for i=1, #commands do
          while commands[i + j] == registered_cmd do
            j = j + 1
          end
          commands[i] = commands[i + j]
        end
      end
    end
    if #commands < 1 then
      map[stroke] = nil
    else
      map[stroke] = commands
    end
  end
end


---Add bindings by replacing commands that were previously assigned to a shortcut.
---@param map keymap.map
function keymap.add_direct(map)
  for stroke, commands in pairs(map) do
    if type(commands) == "string" or type(commands) == "function" then
      commands = { commands }
    end
    if keymap.map[stroke] then
      for _, cmd in ipairs(keymap.map[stroke]) do
        remove_only(keymap.reverse_map, cmd, stroke)
      end
    end
    keymap.map[stroke] = commands
    for _, cmd in ipairs(commands) do
      keymap.reverse_map[cmd] = keymap.reverse_map[cmd] or {}
      table.insert(keymap.reverse_map[cmd], stroke)
    end
  end
end


---Adds bindings by appending commands to already registered shortcut or by
---replacing currently assigned commands if overwrite is specified.
---@param map keymap.map
---@param overwrite? boolean
function keymap.add(map, overwrite)
  remove_duplicates(map)
  for stroke, commands in pairs(map) do
    if macos then
      stroke = stroke:gsub("%f[%a]ctrl%f[%A]", "cmd")
    end
    if overwrite then
      if keymap.map[stroke] then
        for _, cmd in ipairs(keymap.map[stroke]) do
          remove_only(keymap.reverse_map, cmd, stroke)
        end
      end
      keymap.map[stroke] = commands
    else
      keymap.map[stroke] = keymap.map[stroke] or {}
      for i = #commands, 1, -1 do
        table.insert(keymap.map[stroke], 1, commands[i])
      end
    end
    for _, cmd in ipairs(commands) do
      keymap.reverse_map[cmd] = keymap.reverse_map[cmd] or {}
      table.insert(keymap.reverse_map[cmd], stroke)
    end
  end
end


---Unregisters the given shortcut and associated command.
---@param shortcut string
---@param cmd string
function keymap.unbind(shortcut, cmd)
  remove_only(keymap.map, shortcut, cmd)
  remove_only(keymap.reverse_map, cmd, shortcut)
end


---Returns all the shortcuts associated to a command unpacked for easy assignment.
---@param cmd string
---@return ...
function keymap.get_binding(cmd)
  return table.unpack(keymap.reverse_map[cmd] or {})
end


---Returns all the shortcuts associated to a command packed in a table.
---@param cmd string
---@return table<integer, string> | nil shortcuts
function keymap.get_bindings(cmd)
  return keymap.reverse_map[cmd]
end


--------------------------------------------------------------------------------
-- Events listening
--------------------------------------------------------------------------------
function keymap.on_key_pressed(k, ...)
  -- In MacOS and Windows during IME composition input is still sent to us
  -- so we just ignore it
  if PLATFORM ~= "Linux" and ime.editing then return false end

  local mk = modkey_map[k]
  if mk then
    keymap.modkeys[mk] = true
    -- work-around for windows where `altgr` is treated as `ctrl+alt`
    if mk == "altgr" then
      keymap.modkeys["ctrl"] = false
    end
  else
    local stroke = key_to_stroke(k)
    local commands, performed = keymap.map[stroke], false
    if commands then
      for _, cmd in ipairs(commands) do
        if type(cmd) == "function" then
          local ok, res = core.try(cmd, ...)
          if ok then
            performed = not (res == false)
          else
            performed = true
          end
        else
          performed = command.perform(cmd, ...)
        end
        if performed then break end
      end
      return performed
    end
  end
  return false
end

function keymap.on_mouse_wheel(delta_y, delta_x, ...)
  local y_direction = delta_y > 0 and "up" or "down"
  local x_direction = delta_x > 0 and "left" or "right"
  -- Try sending a "cumulative" event for both scroll directions
  if delta_y ~= 0 and delta_x ~= 0 then
    local result = keymap.on_key_pressed("wheel" .. y_direction .. x_direction, delta_y, delta_x, ...)
    if not result then
      result = keymap.on_key_pressed("wheelyx", delta_y, delta_x, ...)
    end
    if result then return true end
  end
  -- Otherwise send each direction as its own separate event
  local y_result, x_result
  if delta_y ~= 0 then
    y_result = keymap.on_key_pressed("wheel" .. y_direction, delta_y, ...)
    if not y_result then
      y_result = keymap.on_key_pressed("wheel", delta_y, ...)
    end
  end
  if delta_x ~= 0 then
    x_result = keymap.on_key_pressed("wheel" .. x_direction, delta_x, ...)
    if not x_result then
      x_result = keymap.on_key_pressed("hwheel", delta_x, ...)
    end
  end
  return y_result or x_result
end

function keymap.on_mouse_pressed(button, x, y, clicks)
  local click_number = (((clicks - 1) % config.max_clicks) + 1)
  return not (keymap.on_key_pressed(click_number  .. button:sub(1,1) .. "click", x, y, clicks) or
    keymap.on_key_pressed(button:sub(1,1) .. "click", x, y, clicks) or
    keymap.on_key_pressed(click_number .. "click", x, y, clicks) or
    keymap.on_key_pressed("click", x, y, clicks))
end

function keymap.on_key_released(k)
  local mk = modkey_map[k]
  if mk then
    keymap.modkeys[mk] = false
  end
end


--------------------------------------------------------------------------------
-- Register default bindings
--------------------------------------------------------------------------------
if macos then
  local keymap_macos = require("core.keymap-macos")
  keymap_macos(keymap)
  return keymap
end

keymap.add_direct {
  ["ctrl+shift+p"] = "core:find-command",
  ["ctrl+p"] = "core:find-file",
  ["ctrl+o"] = "core:open-file",
  ["ctrl+n"] = "core:new-doc",
  ["ctrl+shift+c"] = "core:change-project-folder",
  ["ctrl+shift+o"] = "core:open-project-folder",
  ["ctrl+alt+r"] = "core:restart",
  ["alt+return"] = "core:toggle-fullscreen",
  ["f11"] = "core:toggle-fullscreen",

  ["alt+shift+j"] = "root:split-left",
  ["alt+shift+l"] = "root:split-right",
  ["alt+shift+i"] = "root:split-up",
  ["alt+shift+k"] = "root:split-down",
  ["alt+j"] = "root:switch-to-left",
  ["alt+l"] = "root:switch-to-right",
  ["alt+i"] = "root:switch-to-up",
  ["alt+k"] = "root:switch-to-down",

  ["ctrl+w"] = "root:close",
  ["ctrl+tab"] = "root:switch-to-next-tab",
  ["ctrl+shift+tab"] = "root:switch-to-previous-tab",
  ["ctrl+pageup"] = "root:move-tab-left",
  ["ctrl+pagedown"] = "root:move-tab-right",
  ["alt+1"] = "root:switch-to-tab-1",
  ["alt+2"] = "root:switch-to-tab-2",
  ["alt+3"] = "root:switch-to-tab-3",
  ["alt+4"] = "root:switch-to-tab-4",
  ["alt+5"] = "root:switch-to-tab-5",
  ["alt+6"] = "root:switch-to-tab-6",
  ["alt+7"] = "root:switch-to-tab-7",
  ["alt+8"] = "root:switch-to-tab-8",
  ["alt+9"] = "root:switch-to-tab-9",
  ["wheel"] = "root:scroll",
  ["hwheel"] = "root:horizontal-scroll",
  ["shift+wheel"] = "root:horizontal-scroll",

  ["ctrl+f"] = "find-replace:find",
  ["ctrl+r"] = "find-replace:replace",
  ["f3"] = "find-replace:repeat-find",
  ["shift+f3"] = "find-replace:previous-find",
  ["ctrl+i"] = "find-replace:toggle-sensitivity",
  ["ctrl+shift+i"] = "find-replace:toggle-regex",
  ["ctrl+g"] = "doc:go-to-line",
  ["ctrl+s"] = "doc:save",
  ["ctrl+shift+s"] = "doc:save-as",

  ["ctrl+z"] = "doc:undo",
  ["ctrl+y"] = "doc:redo",
  ["ctrl+x"] = "doc:cut",
  ["ctrl+c"] = "doc:copy",
  ["ctrl+v"] = "doc:paste",
  ["ctrl+insert"] = "doc:copy",
  ["shift+insert"] = "doc:paste",
  ["escape"] = { "command:escape", "doc:select-none", "dialog:select-no" },
  ["tab"] = { "command:complete", "doc:indent" },
  ["shift+tab"] = "doc:unindent",
  ["backspace"] = "doc:backspace",
  ["shift+backspace"] = "doc:backspace",
  ["ctrl+backspace"] = "doc:delete-to-previous-word-start",
  ["ctrl+shift+backspace"] = "doc:delete-to-previous-word-start",
  ["delete"] = "doc:delete",
  ["shift+delete"] = "doc:delete",
  ["ctrl+delete"] = "doc:delete-to-next-word-end",
  ["ctrl+shift+delete"] = "doc:delete-to-next-word-end",
  ["return"] = { "command:submit", "doc:newline", "dialog:select" },
  ["keypad enter"] = { "command:submit", "doc:newline", "dialog:select" },
  ["ctrl+return"] = "doc:newline-below",
  ["ctrl+shift+return"] = "doc:newline-above",
  ["ctrl+j"] = "doc:join-lines",
  ["ctrl+a"] = "doc:select-all",
  ["ctrl+d"] = { "find-replace:select-add-next", "doc:select-word" },
  ["ctrl+f3"] = "find-replace:select-next",
  ["ctrl+shift+f3"] = "find-replace:select-previous",
  ["ctrl+l"] = "doc:select-lines",
  ["ctrl+shift+l"] = { "find-replace:select-add-all", "doc:select-word" },
  ["ctrl+/"] = "doc:toggle-line-comments",
  ["ctrl+shift+/"] = "doc:toggle-block-comments",
  ["ctrl+up"] = "doc:move-lines-up",
  ["ctrl+down"] = "doc:move-lines-down",
  ["ctrl+shift+d"] = "doc:duplicate-lines",
  ["ctrl+shift+k"] = "doc:delete-lines",

  ["left"] = { "doc:move-to-previous-char", "dialog:previous-entry" },
  ["right"] = { "doc:move-to-next-char", "dialog:next-entry"},
  ["up"] = { "command:select-previous", "doc:move-to-previous-line" },
  ["down"] = { "command:select-next", "doc:move-to-next-line" },
  ["ctrl+left"] = "doc:move-to-previous-word-start",
  ["ctrl+right"] = "doc:move-to-next-word-end",
  ["ctrl+["] = "doc:move-to-previous-block-start",
  ["ctrl+]"] = "doc:move-to-next-block-end",
  ["home"] = "doc:move-to-start-of-indentation",
  ["end"] = "doc:move-to-end-of-line",
  ["ctrl+home"] = "doc:move-to-start-of-doc",
  ["ctrl+end"] = "doc:move-to-end-of-doc",
  ["pageup"] = "doc:move-to-previous-page",
  ["pagedown"] = "doc:move-to-next-page",

  ["shift+1lclick"] = "doc:select-to-cursor",
  ["ctrl+1lclick"] = "doc:split-cursor",
  ["1lclick"] = "doc:set-cursor",
  ["2lclick"] = "doc:set-cursor-word",
  ["3lclick"] = "doc:set-cursor-line",
  ["shift+left"] = "doc:select-to-previous-char",
  ["shift+right"] = "doc:select-to-next-char",
  ["shift+up"] = "doc:select-to-previous-line",
  ["shift+down"] = "doc:select-to-next-line",
  ["ctrl+shift+left"] = "doc:select-to-previous-word-start",
  ["ctrl+shift+right"] = "doc:select-to-next-word-end",
  ["ctrl+shift+["] = "doc:select-to-previous-block-start",
  ["ctrl+shift+]"] = "doc:select-to-next-block-end",
  ["shift+home"] = "doc:select-to-start-of-indentation",
  ["shift+end"] = "doc:select-to-end-of-line",
  ["ctrl+shift+home"] = "doc:select-to-start-of-doc",
  ["ctrl+shift+end"] = "doc:select-to-end-of-doc",
  ["shift+pageup"] = "doc:select-to-previous-page",
  ["shift+pagedown"] = "doc:select-to-next-page",
  ["ctrl+shift+up"] = "doc:create-cursor-previous-line",
  ["ctrl+shift+down"] = "doc:create-cursor-next-line"
}

return keymap
local core = require "core"
local common = require "core.common"
local config = require "core.config"
local keymap = require "core.keymap"
local style = require "core.style"
local View = require "core.view"


local function lines(text)
  if text == "" then return 0 end
  local l = 1
  for _ in string.gmatch(text, "\n") do
    l = l + 1
  end
  return l
end


local item_height_result = {}


local function get_item_height(item)
  local h = item_height_result[item]
  if not h then
    h = {}
    local l = 1 + lines(item.text) + lines(item.info or "")
    h.normal = style.font:get_height() + style.padding.y
    h.expanded = l * style.font:get_height() + style.padding.y
    h.current = h.normal
    h.target = h.current
    item_height_result[item] = h
  end
  return h
end


local LogView = View:extend()

LogView.context = "session"


function LogView:new()
  LogView.super.new(self)
  self.last_item = core.log_items[#core.log_items]
  self.expanding = {}
  self.scrollable = true
  self.yoffset = 0

  core.status_view:show_message("i", style.text, "ctrl+click to copy entry")
end


function LogView:get_name()
  return "Log"
end


local function is_expanded(item)
  local item_height = get_item_height(item)
  return item_height.target == item_height.expanded
end


function LogView:expand_item(item)
  item = get_item_height(item)
  item.target = item.target == item.expanded and item.normal or item.expanded
  table.insert(self.expanding, item)
end


function LogView:each_item()
  local x, y = self:get_content_offset()
  y = y + style.padding.y + self.yoffset
  return coroutine.wrap(function()
    for i = #core.log_items, 1, -1 do
      local item = core.log_items[i]
      local h = get_item_height(item).current
      coroutine.yield(i, item, x, y, self.size.x, h)
      y = y + h
    end
  end)
end


function LogView:get_scrollable_size()
  local _, y_off = self:get_content_offset()
  local last_y, last_h = 0, 0
  for i, item, x, y, w, h in self:each_item() do
    last_y, last_h = y, h
  end
  if not config.scroll_past_end then
    return last_y + last_h - y_off + style.padding.y
  end
  return last_y + self.size.y - y_off
end


function LogView:on_mouse_pressed(button, px, py, clicks)
  if LogView.super.on_mouse_pressed(self, button, px, py, clicks) then
    return true
  end

  local index, selected
  for i, item, x, y, w, h in self:each_item() do
    if px >= x and py >= y and px < x + w and py < y + h then
      index = i
      selected = item
      break
    end
  end

  if selected then
    if keymap.modkeys["ctrl"] then
      system.set_clipboard(core.get_log(selected))
      core.status_view:show_message("i", style.text, "copied entry #"..index.." to clipboard.")
    else
      self:expand_item(selected)
    end
  end

  return true
end


function LogView:update()
  local item = core.log_items[#core.log_items]
  if self.last_item ~= item then
    self.last_item = item
    self.scroll.to.y = 0
    self.yoffset = -(style.font:get_height() + style.padding.y)
  end

  local expanding = self.expanding[1]
  if expanding then
    self:move_towards(expanding, "current", expanding.target, nil, "logview")
    if expanding.current == expanding.target then
      table.remove(self.expanding, 1)
    end
  end

  self:move_towards("yoffset", 0, nil, "logview")

  LogView.super.update(self)
end


local function draw_text_multiline(font, text, x, y, color)
  local th = font:get_height()
  local resx = x
  for line in text:gmatch("[^\n]+") do
    resx = renderer.draw_text(style.font, line, x, y, color)
    y = y + th
  end
  return resx, y
end

-- this is just to get a date string that's consistent
local datestr = os.date()
function LogView:draw()
  self:draw_background(style.background)

  local th = style.font:get_height()
  local lh = th + style.padding.y -- for one line
  local iw = math.max(
    style.icon_font:get_width(style.log.ERROR.icon),
    style.icon_font:get_width(style.log.INFO.icon)
  )

  local tw = style.font:get_width(datestr)
  for _, item, x, y, w, h in self:each_item() do
    if y + h >= self.position.y and y <= self.position.y + self.size.y then
      core.push_clip_rect(x, y, w, h)
      x = x + style.padding.x

      x = common.draw_text(
        style.icon_font,
        style.log[item.level].color,
        style.log[item.level].icon,
        "center",
        x, y, iw, lh
      )
      x = x + style.padding.x

      -- timestamps are always 15% of the width
      local time = os.date(nil, item.time)
      common.draw_text(style.font, style.dim, time, "left", x, y, tw, lh)
      x = x + tw + style.padding.x

      w = w - (x - self:get_content_offset())

      if is_expanded(item) then
        y = y + common.round(style.padding.y / 2)
        _, y = draw_text_multiline(style.font, item.text, x, y, style.text)

        local at = "at " .. common.home_encode(item.at)
        _, y = common.draw_text(style.font, style.dim, at, "left", x, y, w, lh)

        if item.info then
          _, y = draw_text_multiline(style.font, item.info, x, y, style.dim)
        end
      else
        local line, has_newline = string.match(item.text, "([^\n]+)(\n?)")
        if has_newline ~= "" then
          line = line .. " ..."
        end
        _, y = common.draw_text(style.font, style.text, line, "left", x, y, w, lh)
      end

      core.pop_clip_rect()
    end
  end
  LogView.super.draw_scrollbar(self)
end


return LogView
local modkeys = {}

modkeys.map = {
  ["left ctrl"]   = "ctrl",
  ["right ctrl"]  = "ctrl",
  ["left shift"]  = "shift",
  ["right shift"] = "shift",
  ["left alt"]    = "alt",
  ["right alt"]   = "altgr",
}

modkeys.keys = { "ctrl", "alt", "altgr", "shift" }

return modkeys
local modkeys = {}

modkeys.map = {
  ["left command"]   = "cmd",
  ["right command"]  = "cmd",
  ["left ctrl"]      = "ctrl",
  ["right ctrl"]     = "ctrl",
  ["left shift"]     = "shift",
  ["right shift"]    = "shift",
  ["left option"]    = "option",
  ["right option"]   = "option",
  ["left alt"]       = "alt",
  ["right alt"]      = "altgr",
}

modkeys.keys = { "cmd", "ctrl", "alt", "option", "altgr", "shift" }

return modkeys
local core = require "core"
local command = require "core.command"
local common = require "core.common"
local config = require "core.config"
local View = require "core.view"
local style = require "core.style"

local BORDER_WIDTH = common.round(1 * SCALE)
local UNDERLINE_WIDTH = common.round(2 * SCALE)
local UNDERLINE_MARGIN = common.round(1 * SCALE)

local noop = function() end

---@class core.nagview : core.view
---@field super core.view
local NagView = View:extend()

function NagView:new()
  NagView.super.new(self)
  self.size.y = 0
  self.show_height = 0
  self.force_focus = false
  self.queue = {}
  self.scrollable = true
  self.target_height = 0
  self.on_mouse_pressed_root = nil
end

function NagView:get_title()
  return self.title
end

-- The two methods below are duplicated from DocView
function NagView:get_line_height()
  return math.floor(style.font:get_height() * config.line_height)
end

function NagView:get_line_text_y_offset()
  local lh = self:get_line_height()
  local th = style.font:get_height()
  return (lh - th) / 2
end

-- Buttons height without padding
function NagView:get_buttons_height()
  local lh = style.font:get_height()
  local bt_padding = lh / 2
  return lh + 2 * BORDER_WIDTH + 2 * bt_padding
end

function NagView:get_target_height()
  return self.target_height + 2 * style.padding.y
end

function NagView:get_scrollable_size()
  local w, h = system.get_window_size()
  if self.visible and self:get_target_height() > h then
    self.size.y = h
    return self:get_target_height()
  else
    self.size.y = 0
  end
  return 0
end

function NagView:dim_window_content()
  local ox, oy = self:get_content_offset()
  oy = oy + self.show_height
  local w, h = core.root_view.size.x, core.root_view.size.y - oy
  core.root_view:defer_draw(function()
    renderer.draw_rect(ox, oy, w, h, style.nagbar_dim)
  end)
end

function NagView:change_hovered(i)
  if i ~= self.hovered_item then
    self.hovered_item = i
    self.underline_progress = 0
    core.redraw = true
  end
end

function NagView:each_option()
  return coroutine.wrap(function()
    if not self.options then return end
    local opt, bw,bh,ox,oy
    bh = self:get_buttons_height()
    ox,oy = self:get_content_offset()
    ox = ox + self.size.x
    oy = oy + self.show_height - bh - style.padding.y

    for i = #self.options, 1, -1 do
      opt = self.options[i]
      bw = opt.font:get_width(opt.text) + 2 * BORDER_WIDTH + style.padding.x

      ox = ox - bw - style.padding.x
      coroutine.yield(i, opt, ox,oy,bw,bh)
    end
  end)
end

function NagView:on_mouse_moved(mx, my, ...)
  if not self.visible then return end
  core.set_active_view(self)
  NagView.super.on_mouse_moved(self, mx, my, ...)
  for i, _, x,y,w,h in self:each_option() do
    if mx >= x and my >= y and mx < x + w and my < y + h then
      self:change_hovered(i)
      break
    end
  end
end

local function register_mouse_pressed(self)
  if self.on_mouse_pressed_root then return end
  -- RootView is loaded locally to avoid NagView and RootView being
  -- mutually recursive
  local RootView = require "core.rootview"
  self.on_mouse_pressed_root = RootView.on_mouse_pressed
  local this = self
  function RootView:on_mouse_pressed(button, x, y, clicks)
    if
      not this:on_mouse_pressed(button, x, y, clicks)
    then
      return this.on_mouse_pressed_root(self, button, x, y, clicks)
    else
      return true
    end
  end
  self.new_on_mouse_pressed_root = RootView.on_mouse_pressed
end

local function unregister_mouse_pressed(self)
  local RootView = require "core.rootview"
  if
    self.on_mouse_pressed_root
    and
    -- just in case prevent overwriting what something else may
    -- have overwrote after us, but after testing with various
    -- plugins this doesn't seems to happen, but just in case
    self.new_on_mouse_pressed_root == RootView.on_mouse_pressed
  then
    RootView.on_mouse_pressed = self.on_mouse_pressed_root
    self.on_mouse_pressed_root = nil
    self.new_on_mouse_pressed_root = nil
  end
end

function NagView:on_mouse_pressed(button, mx, my, clicks)
  if not self.visible then return false end
  if NagView.super.on_mouse_pressed(self, button, mx, my, clicks) then return true end
  for i, _, x,y,w,h in self:each_option() do
    if mx >= x and my >= y and mx < x + w and my < y + h then
      self:change_hovered(i)
      command.perform "dialog:select"
    end
  end
  return true
end

function NagView:on_text_input(text)
  if not self.visible then return end
  if text:lower() == "y" then
    command.perform "dialog:select-yes"
  elseif text:lower() == "n" then
    command.perform "dialog:select-no"
  end
end

function NagView:update()
  if not self.visible and self.show_height <= 0 then return end
  NagView.super.update(self)

  if self.visible and core.active_view == self and self.title then
    self:move_towards(self, "show_height", self:get_target_height(), nil, "nagbar")
    self:move_towards(self, "underline_progress", 1, nil, "nagbar")
  else
    self:move_towards(self, "show_height", 0, nil, "nagbar")
    if self.show_height <= 0 then
      self.title = nil
      self.message = nil
      self.options = nil
      self.on_selected = nil
    end
  end
end

local function draw_nagview_message(self)
  self:dim_window_content()

  -- draw message's background
  local ox, oy = self:get_content_offset()
  renderer.draw_rect(ox, oy, self.size.x, self.show_height, style.nagbar)

  ox = ox + style.padding.x

  core.push_clip_rect(ox, oy, self.size.x, self.show_height)

  -- if there are other items, show it
  if #self.queue > 0 then
    local str = string.format("[%d]", #self.queue)
    ox = common.draw_text(style.font, style.nagbar_text, str, "left", ox, oy, self.size.x, self.show_height)
    ox = ox + style.padding.x
  end

  -- draw message
  local lh = style.font:get_height() * config.line_height
  oy = oy + style.padding.y + (self.target_height - self:get_message_height()) / 2
  for msg_line in self.message:gmatch("(.-)\n") do
    local ty = oy + self:get_line_text_y_offset()
    renderer.draw_text(style.font, msg_line, ox, ty, style.nagbar_text)
    oy = oy + lh
  end

  -- draw buttons
  for i, opt, bx,by,bw,bh in self:each_option() do
    local fw,fh = bw - 2 * BORDER_WIDTH, bh - 2 * BORDER_WIDTH
    local fx,fy = bx + BORDER_WIDTH, by + BORDER_WIDTH

    -- draw the button
    renderer.draw_rect(bx,by,bw,bh, style.nagbar_text)
    renderer.draw_rect(fx,fy,fw,fh, style.nagbar)

    if i == self.hovered_item then -- draw underline
      local uw = fw - 2 * UNDERLINE_MARGIN
      local halfuw = uw / 2
      local lx = fx + UNDERLINE_MARGIN + halfuw - (halfuw * self.underline_progress)
      local ly = fy + fh - UNDERLINE_MARGIN - UNDERLINE_WIDTH
      uw = uw * self.underline_progress
      renderer.draw_rect(lx,ly,uw,UNDERLINE_WIDTH, style.nagbar_text)
    end

    common.draw_text(opt.font, style.nagbar_text, opt.text, "center", fx,fy,fw,fh)
  end

  self:draw_scrollbar()

  core.pop_clip_rect()
end

function NagView:draw()
  if (not self.visible and self.show_height <= 0) or not self.title then
    return
  end
  core.root_view:defer_draw(draw_nagview_message, self)
end

function NagView:get_message_height()
  local h = 0
  for str in string.gmatch(self.message, "(.-)\n") do
    h = h + style.font:get_height() * config.line_height
  end
  return h
end

function NagView:next()
  local opts = table.remove(self.queue, 1) or {}
  if opts.title and opts.message and opts.options then
    self.visible = true
    self.title = opts.title
    self.message = opts.message and opts.message .. "\n"
    self.options = opts.options
    self.on_selected = opts.on_selected

    local message_height = self:get_message_height()
    -- self.target_height is the nagview height needed to display the message and
    -- the buttons, excluding the top and bottom padding space.
    self.target_height = math.max(message_height, self:get_buttons_height())
    self:change_hovered(common.find_index(self.options, "default_yes"))

    self.force_focus = true
    core.set_active_view(self)
    -- We add a hook to manage all the mouse_pressed events.
    register_mouse_pressed(self)
  else
    self.force_focus = false
    core.set_active_view(core.next_active_view or core.last_active_view)
    self.visible = false
    unregister_mouse_pressed(self)
  end
end

function NagView:show(title, message, options, on_select)
  local opts = {}
  opts.title = assert(title, "No title")
  opts.message = assert(message, "No message")
  opts.options = assert(options, "No options")
  opts.on_selected = on_select or noop
  table.insert(self.queue, opts)
  self:next()
end

return NagView
local core = require "core"
local common = require "core.common"
local config = require "core.config"
local style = require "core.style"
local Object = require "core.object"
local EmptyView = require "core.emptyview"
local View = require "core.view"

---@class core.node : core.object
local Node = Object:extend()

function Node:new(type)
  self.type = type or "leaf"
  self.position = { x = 0, y = 0 }
  self.size = { x = 0, y = 0 }
  self.views = {}
  self.divider = 0.5
  if self.type == "leaf" then
    self:add_view(EmptyView())
  end
  self.hovered = {x = -1, y = -1 }
  self.hovered_close = 0
  self.tab_shift = 0
  self.tab_offset = 1
  self.tab_width = style.tab_width
  self.move_towards = View.move_towards
end


function Node:propagate(fn, ...)
  self.a[fn](self.a, ...)
  self.b[fn](self.b, ...)
end


function Node:on_mouse_moved(x, y, ...)
  if self.type == "leaf" then
    self.hovered.x, self.hovered.y = x, y
    self.active_view:on_mouse_moved(x, y, ...)
  else
    self:propagate("on_mouse_moved", x, y, ...)
  end
end


function Node:on_mouse_released(...)
  if self.type == "leaf" then
    self.active_view:on_mouse_released(...)
  else
    self:propagate("on_mouse_released", ...)
  end
end


function Node:on_mouse_left()
  if self.type == "leaf" then
    self.active_view:on_mouse_left()
  else
    self:propagate("on_mouse_left")
  end
end


function Node:consume(node)
  for k, _ in pairs(self) do self[k] = nil end
  for k, v in pairs(node) do self[k] = v   end
end


local type_map = { up="vsplit", down="vsplit", left="hsplit", right="hsplit" }

-- The "locked" argument below should be in the form {x = <boolean>, y = <boolean>}
-- and it indicates if the node want to have a fixed size along the axis where the
-- boolean is true. If not it will be expanded to take all the available space.
-- The "resizable" flag indicates if, along the "locked" axis the node can be resized
-- by the user. If the node is marked as resizable their view should provide a
-- set_target_size method.
function Node:split(dir, view, locked, resizable)
  assert(self.type == "leaf", "Tried to split non-leaf node")
  local node_type = assert(type_map[dir], "Invalid direction")
  local last_active = core.active_view
  local child = Node()
  child:consume(self)
  self:consume(Node(node_type))
  self.a = child
  self.b = Node()
  if view then self.b:add_view(view) end
  if locked then
    assert(type(locked) == 'table')
    self.b.locked = locked
    self.b.resizable = resizable or false
    core.set_active_view(last_active)
  end
  if dir == "up" or dir == "left" then
    self.a, self.b = self.b, self.a
    return self.a
  end
  return self.b
end

function Node:remove_view(root, view)
  if #self.views > 1 then
    local idx = self:get_view_idx(view)
    if idx < self.tab_offset then
      self.tab_offset = self.tab_offset - 1
    end
    table.remove(self.views, idx)
    if self.active_view == view then
      self:set_active_view(self.views[idx] or self.views[#self.views])
    end
  else
    local parent = self:get_parent_node(root)
    local is_a = (parent.a == self)
    local other = parent[is_a and "b" or "a"]
    local locked_size_x, locked_size_y = other:get_locked_size()
    local locked_size
    if parent.type == "hsplit" then
      locked_size = locked_size_x
    else
      locked_size = locked_size_y
    end
    local next_primary
    if self.is_primary_node then
      next_primary = core.root_view:select_next_primary_node()
    end
    if locked_size or (self.is_primary_node and not next_primary) then
      self.views = {}
      self:add_view(EmptyView())
    else
      if other == next_primary then
        next_primary = parent
      end
      parent:consume(other)
      local p = parent
      while p.type ~= "leaf" do
        p = p[is_a and "a" or "b"]
      end
      p:set_active_view(p.active_view)
      if self.is_primary_node then
        next_primary.is_primary_node = true
      end
    end
  end
  core.last_active_view = nil
end

function Node:close_view(root, view)
  local do_close = function()
    self:remove_view(root, view)
  end
  view:try_close(do_close)
end


function Node:close_active_view(root)
  self:close_view(root, self.active_view)
end


function Node:add_view(view, idx)
  assert(self.type == "leaf", "Tried to add view to non-leaf node")
  assert(not self.locked, "Tried to add view to locked node")
  if self.views[1] and self.views[1]:is(EmptyView) then
    table.remove(self.views)
  end
  table.insert(self.views, idx or (#self.views + 1), view)
  self:set_active_view(view)
end


function Node:set_active_view(view)
  assert(self.type == "leaf", "Tried to set active view on non-leaf node")
  local last_active_view = self.active_view
  self.active_view = view
  core.set_active_view(view)
  if last_active_view and last_active_view ~= view then
    last_active_view:on_mouse_left()
  end
end


function Node:get_view_idx(view)
  for i, v in ipairs(self.views) do
    if v == view then return i end
  end
end


function Node:get_node_for_view(view)
  for _, v in ipairs(self.views) do
    if v == view then return self end
  end
  if self.type ~= "leaf" then
    return self.a:get_node_for_view(view) or self.b:get_node_for_view(view)
  end
end


function Node:get_parent_node(root)
  if root.a == self or root.b == self then
    return root
  elseif root.type ~= "leaf" then
    return self:get_parent_node(root.a) or self:get_parent_node(root.b)
  end
end


function Node:get_children(t)
  t = t or {}
  for _, view in ipairs(self.views) do
    table.insert(t, view)
  end
  if self.a then self.a:get_children(t) end
  if self.b then self.b:get_children(t) end
  return t
end


-- return the width including the padding space and separately
-- the padding space itself
local function get_scroll_button_width()
  local w = style.icon_font:get_width(">")
  local pad = w
  return w + 2 * pad, pad
end


function Node:get_divider_overlapping_point(px, py)
  if self.type ~= "leaf" then
    local axis = self.type == "hsplit" and "x" or "y"
    if self.a:is_resizable(axis) and self.b:is_resizable(axis) then
      local p = 6
      local x, y, w, h = self:get_divider_rect()
      x, y = x - p, y - p
      w, h = w + p * 2, h + p * 2
      if px > x and py > y and px < x + w and py < y + h then
        return self
      end
    end
    return self.a:get_divider_overlapping_point(px, py)
        or self.b:get_divider_overlapping_point(px, py)
  end
end


function Node:get_visible_tabs_number()
  return math.min(#self.views - self.tab_offset + 1, config.max_tabs)
end


function Node:get_tab_overlapping_point(px, py)
  if not self:should_show_tabs() then return nil end
  local tabs_number = self:get_visible_tabs_number()
  local x1, y1, w, h = self:get_tab_rect(self.tab_offset)
  local x2, y2 = self:get_tab_rect(self.tab_offset + tabs_number)
  if px >= x1 and py >= y1 and px < x2 and py < y1 + h then
    return math.floor((px - x1) / w) + self.tab_offset
  end
end


function Node:should_show_tabs()
  if self.locked then return false end
  local dn = core.root_view.dragged_node
  if #self.views > 1
     or (dn and dn.dragging) then -- show tabs while dragging
    return true
  elseif config.always_show_tabs then
    return not self.views[1]:is(EmptyView)
  end
  return false
end


local function close_button_location(x, w)
  local cw = style.icon_font:get_width("C")
  local pad = style.padding.x / 2
  return x + w - cw - pad, cw, pad
end


function Node:get_scroll_button_index(px, py)
  if #self.views == 1 then return end
  for i = 1, 2 do
    local x, y, w, h = self:get_scroll_button_rect(i)
    if px >= x and px < x + w and py >= y and py < y + h then
      return i
    end
  end
end


function Node:tab_hovered_update(px, py)
  local tab_index = self:get_tab_overlapping_point(px, py)
  self.hovered_tab = tab_index
  self.hovered_close = 0
  self.hovered_scroll_button = 0
  if tab_index then
    local x, y, w, h = self:get_tab_rect(tab_index)
    local cx, cw = close_button_location(x, w)
    if px >= cx and px < cx + cw and py >= y and py < y + h and config.tab_close_button then
      self.hovered_close = tab_index
    end
  else
    self.hovered_scroll_button = self:get_scroll_button_index(px, py) or 0
  end
end


function Node:get_child_overlapping_point(x, y)
  local child
  if self.type == "leaf" then
    return self
  elseif self.type == "hsplit" then
    child = (x < self.b.position.x) and self.a or self.b
  elseif self.type == "vsplit" then
    child = (y < self.b.position.y) and self.a or self.b
  end
  return child:get_child_overlapping_point(x, y)
end


function Node:get_scroll_button_rect(index)
  local w, pad = get_scroll_button_width()
  local h = style.font:get_height() + style.padding.y * 2
  local x = self.position.x + (index == 1 and self.size.x - w * 2 or self.size.x - w)
  return x, self.position.y, w, h, pad
end


function Node:get_tab_rect(idx)
  local maxw = self.size.x
  local x0 = self.position.x
  local x1 = x0 + common.clamp(self.tab_width * (idx - 1) - self.tab_shift, 0, maxw)
  local x2 = x0 + common.clamp(self.tab_width * idx - self.tab_shift, 0, maxw)
  local h = style.font:get_height() + style.padding.y * 2
  return x1, self.position.y, x2 - x1, h
end


function Node:get_divider_rect()
  local x, y = self.position.x, self.position.y
  if self.type == "hsplit" then
    return x + self.a.size.x, y, style.divider_size, self.size.y
  elseif self.type == "vsplit" then
    return x, y + self.a.size.y, self.size.x, style.divider_size
  end
end


-- Return two values for x and y axis and each of them is either falsy or a number.
-- A falsy value indicate no fixed size along the corresponding direction.
function Node:get_locked_size()
  if self.type == "leaf" then
    if self.locked then
      local size = self.active_view.size
      -- The values below should be either a falsy value or a number
      local sx = (self.locked and self.locked.x) and size.x
      local sy = (self.locked and self.locked.y) and size.y
      return sx, sy
    end
  else
    local x1, y1 = self.a:get_locked_size()
    local x2, y2 = self.b:get_locked_size()
    -- The values below should be either a falsy value or a number
    local sx, sy
    if self.type == 'hsplit' then
      if x1 and x2 then
        local dsx = (x1 < 1 or x2 < 1) and 0 or style.divider_size
        sx = x1 + x2 + dsx
      end
      sy = y1 or y2
    else
      if y1 and y2 then
        local dsy = (y1 < 1 or y2 < 1) and 0 or style.divider_size
        sy = y1 + y2 + dsy
      end
      sx = x1 or x2
    end
    return sx, sy
  end
end


function Node.copy_position_and_size(dst, src)
  dst.position.x, dst.position.y = src.position.x, src.position.y
  dst.size.x, dst.size.y = src.size.x, src.size.y
end


-- calculating the sizes is the same for hsplits and vsplits, except the x/y
-- axis are swapped; this function lets us use the same code for both
local function calc_split_sizes(self, x, y, x1, x2, y1, y2)
  local ds = ((x1 and x1 < 1) or (x2 and x2 < 1)) and 0 or style.divider_size
  local n = x1 and x1 + ds or (x2 and self.size[x] - x2 or math.floor(self.size[x] * self.divider))
  self.a.position[x] = self.position[x]
  self.a.position[y] = self.position[y]
  self.a.size[x] = n - ds
  self.a.size[y] = self.size[y]
  self.b.position[x] = self.position[x] + n
  self.b.position[y] = self.position[y]
  self.b.size[x] = self.size[x] - n
  self.b.size[y] = self.size[y]
end


function Node:update_layout()
  if self.type == "leaf" then
    local av = self.active_view
    if self:should_show_tabs() then
      local _, _, _, th = self:get_tab_rect(1)
      av.position.x, av.position.y = self.position.x, self.position.y + th
      av.size.x, av.size.y = self.size.x, self.size.y - th
    else
      Node.copy_position_and_size(av, self)
    end
  else
    local x1, y1 = self.a:get_locked_size()
    local x2, y2 = self.b:get_locked_size()
    if self.type == "hsplit" then
      calc_split_sizes(self, "x", "y", x1, x2)
    elseif self.type == "vsplit" then
      calc_split_sizes(self, "y", "x", y1, y2)
    end
    self.a:update_layout()
    self.b:update_layout()
  end
end


function Node:scroll_tabs_to_visible()
  local index = self:get_view_idx(self.active_view)
  if index then
    local tabs_number = self:get_visible_tabs_number()
    if self.tab_offset > index then
      self.tab_offset = index
    elseif self.tab_offset + tabs_number - 1 < index then
      self.tab_offset = index - tabs_number + 1
    elseif tabs_number < config.max_tabs and self.tab_offset > 1 then
      self.tab_offset = #self.views - config.max_tabs + 1
    end
  end
end


function Node:scroll_tabs(dir)
  local view_index = self:get_view_idx(self.active_view)
  if dir == 1 then
    if self.tab_offset > 1 then
      self.tab_offset = self.tab_offset - 1
      local last_index = self.tab_offset + self:get_visible_tabs_number() - 1
      if view_index > last_index then
        self:set_active_view(self.views[last_index])
      end
    end
  elseif dir == 2 then
    local tabs_number = self:get_visible_tabs_number()
    if self.tab_offset + tabs_number - 1 < #self.views then
      self.tab_offset = self.tab_offset + 1
      local view_index = self:get_view_idx(self.active_view)
      if view_index < self.tab_offset then
        self:set_active_view(self.views[self.tab_offset])
      end
    end
  end
end


function Node:target_tab_width()
  local n = self:get_visible_tabs_number()
  local w = self.size.x
  if #self.views > n then
    w = self.size.x - get_scroll_button_width() * 2
  end
  return common.clamp(style.tab_width, w / config.max_tabs, w / n)
end


function Node:update()
  if self.type == "leaf" then
    self:scroll_tabs_to_visible()
    for _, view in ipairs(self.views) do
      view:update()
    end
    self:tab_hovered_update(self.hovered.x, self.hovered.y)
    local tab_width = self:target_tab_width()
    self:move_towards("tab_shift", tab_width * (self.tab_offset - 1), nil, "tabs")
    self:move_towards("tab_width", tab_width, nil, "tabs")
  else
    self.a:update()
    self.b:update()
  end
end

function Node:draw_tab_title(view, font, is_active, is_hovered, x, y, w, h)
  local text = view and view:get_name() or ""
  local dots_width = font:get_width("")
  local align = "center"
  if font:get_width(text) > w then
    align = "left"
    for i = 1, #text do
      local reduced_text = text:sub(1, #text - i)
      if font:get_width(reduced_text) + dots_width <= w then
        text = reduced_text .. ""
        break
      end
    end
  end
  local color = style.dim
  if is_active then color = style.text end
  if is_hovered then color = style.text end
  common.draw_text(font, color, text, align, x, y, w, h)
end

function Node:draw_tab_borders(view, is_active, is_hovered, x, y, w, h, standalone)
  -- Tabs deviders
  local ds = style.divider_size
  local color = style.dim
  local padding_y = style.padding.y
  renderer.draw_rect(x + w, y + padding_y, ds, h - padding_y*2, style.dim)
  if standalone then
    renderer.draw_rect(x-1, y-1, w+2, h+2, style.background2)
  end
  -- Full border
  if is_active then
    color = style.text
    renderer.draw_rect(x, y, w, h, style.background)
    renderer.draw_rect(x + w, y, ds, h, style.divider)
    renderer.draw_rect(x - ds, y, ds, h, style.divider)
  end
  return x + ds, y, w - ds*2, h
end

function Node:draw_tab(view, is_active, is_hovered, is_close_hovered, x, y, w, h, standalone)
  x, y, w, h = self:draw_tab_borders(view, is_active, is_hovered, x, y, w, h, standalone)
  -- Close button
  local cx, cw, cpad = close_button_location(x, w)
  local show_close_button = ((is_active or is_hovered) and not standalone and config.tab_close_button)
  if show_close_button then
    local close_style = is_close_hovered and style.text or style.dim
    common.draw_text(style.icon_font, close_style, "C", nil, cx, y, cw, h)
  end
  -- Title
  x = x + cpad
  w = cx - x
  core.push_clip_rect(x, y, w, h)
  self:draw_tab_title(view, style.font, is_active, is_hovered, x, y, w, h)
  core.pop_clip_rect()
end

function Node:draw_tabs()
  local _, y, w, h, scroll_padding = self:get_scroll_button_rect(1)
  local x = self.position.x
  local ds = style.divider_size
  local dots_width = style.font:get_width("")
  core.push_clip_rect(x, y, self.size.x, h)
  renderer.draw_rect(x, y, self.size.x, h, style.background2)
  renderer.draw_rect(x, y + h - ds, self.size.x, ds, style.divider)
  local tabs_number = self:get_visible_tabs_number()

  for i = self.tab_offset, self.tab_offset + tabs_number - 1 do
    local view = self.views[i]
    local x, y, w, h = self:get_tab_rect(i)
    self:draw_tab(view, view == self.active_view,
                  i == self.hovered_tab, i == self.hovered_close,
                  x, y, w, h)
  end

  if #self.views > tabs_number then
    local _, pad = get_scroll_button_width()
    local xrb, yrb, wrb, hrb = self:get_scroll_button_rect(1)
    renderer.draw_rect(xrb + pad, yrb, wrb * 2, hrb, style.background2)
    local left_button_style = (self.hovered_scroll_button == 1 and self.tab_offset > 1) and style.text or style.dim
    common.draw_text(style.icon_font, left_button_style, "<", nil, xrb + scroll_padding, yrb, 0, h)

    xrb, yrb, wrb = self:get_scroll_button_rect(2)
    local right_button_style = (self.hovered_scroll_button == 2 and #self.views > self.tab_offset + tabs_number - 1) and style.text or style.dim
    common.draw_text(style.icon_font, right_button_style, ">", nil, xrb + scroll_padding, yrb, 0, h)
  end

  core.pop_clip_rect()
end


function Node:draw()
  if self.type == "leaf" then
    if self:should_show_tabs() then
      self:draw_tabs()
    end
    local pos, size = self.active_view.position, self.active_view.size
    core.push_clip_rect(pos.x, pos.y, size.x, size.y)
    self.active_view:draw()
    core.pop_clip_rect()
  else
    local x, y, w, h = self:get_divider_rect()
    renderer.draw_rect(x, y, w, h, style.divider)
    self:propagate("draw")
  end
end


function Node:is_empty()
  if self.type == "leaf" then
    return #self.views == 0 or (#self.views == 1 and self.views[1]:is(EmptyView))
  else
    return self.a:is_empty() and self.b:is_empty()
  end
end


function Node:close_all_docviews(keep_active)
  local node_active_view = self.active_view
  local lost_active_view = false
  if self.type == "leaf" then
    local i = 1
    while i <= #self.views do
      local view = self.views[i]
      if view.context == "session" and (not keep_active or view ~= self.active_view) then
        table.remove(self.views, i)
        if view == node_active_view then
          lost_active_view = true
        end
      else
        i = i + 1
      end
    end
    self.tab_offset = 1
    if #self.views == 0 and self.is_primary_node then
      -- if we are not the primary view and we had the active view it doesn't
      -- matter to reattribute the active view because, within the close_all_docviews
      -- top call, the primary node will take the active view anyway.
      -- Set the empty view and takes the active view.
      self:add_view(EmptyView())
    elseif #self.views > 0 and lost_active_view then
      -- In practice we never get there but if a view remain we need
      -- to reset the Node's active view.
      self:set_active_view(self.views[1])
    end
  else
    self.a:close_all_docviews(keep_active)
    self.b:close_all_docviews(keep_active)
    if self.a:is_empty() and not self.a.is_primary_node then
      self:consume(self.b)
    elseif self.b:is_empty() and not self.b.is_primary_node then
      self:consume(self.a)
    end
  end
end

-- Returns true for nodes that accept either "proportional" resizes (based on the
-- node.divider) or "locked" resizable nodes (along the resize axis).
function Node:is_resizable(axis)
  if self.type == 'leaf' then
    return not self.locked or not self.locked[axis] or self.resizable
  else
    local a_resizable = self.a:is_resizable(axis)
    local b_resizable = self.b:is_resizable(axis)
    return a_resizable and b_resizable
  end
end


-- Return true iff it is a locked pane along the rezise axis and is
-- declared "resizable".
function Node:is_locked_resizable(axis)
  return self.locked and self.locked[axis] and self.resizable
end


function Node:resize(axis, value)
  -- the application works fine with non-integer values but to have pixel-perfect
  -- placements of view elements, like the scrollbar, we round the value to be
  -- an integer.
  value = math.floor(value)
  if self.type == 'leaf' then
    -- If it is not locked we don't accept the
    -- resize operation here because for proportional panes the resize is
    -- done using the "divider" value of the parent node.
    if self:is_locked_resizable(axis) then
      return self.active_view:set_target_size(axis, value)
    end
  else
    if self.type == (axis == "x" and "hsplit" or "vsplit") then
      -- we are resizing a node that is splitted along the resize axis
      if self.a:is_locked_resizable(axis) and self.b:is_locked_resizable(axis) then
        local rem_value = value - self.a.size[axis]
        if rem_value >= 0 then
          return self.b.active_view:set_target_size(axis, rem_value)
        else
          self.b.active_view:set_target_size(axis, 0)
          return self.a.active_view:set_target_size(axis, value)
        end
      end
    else
      -- we are resizing a node that is splitted along the axis perpendicular
      -- to the resize axis
      local a_resizable = self.a:is_resizable(axis)
      local b_resizable = self.b:is_resizable(axis)
      if a_resizable and b_resizable then
        self.a:resize(axis, value)
        self.b:resize(axis, value)
      end
    end
  end
end


function Node:get_split_type(mouse_x, mouse_y)
  local x, y = self.position.x, self.position.y
  local w, h = self.size.x, self.size.y
  local _, _, _, tab_h = self:get_scroll_button_rect(1)
  y = y + tab_h
  h = h - tab_h

  local local_mouse_x = mouse_x - x
  local local_mouse_y = mouse_y - y

  if local_mouse_y < 0 then
    return "tab"
  else
    local left_pct = local_mouse_x * 100 / w
    local top_pct = local_mouse_y * 100 / h
    if left_pct <= 30 then
      return "left"
    elseif left_pct >= 70 then
      return "right"
    elseif top_pct <= 30 then
      return "up"
    elseif top_pct >= 70 then
      return "down"
    end
    return "middle"
  end
end


function Node:get_drag_overlay_tab_position(x, y, dragged_node, dragged_index)
  local tab_index = self:get_tab_overlapping_point(x, y)
  if not tab_index then
    local first_tab_x = self:get_tab_rect(1)
    if x < first_tab_x then
      -- mouse before first visible tab
      tab_index = self.tab_offset or 1
    else
      -- mouse after last visible tab
      tab_index = self:get_visible_tabs_number() + (self.tab_offset - 1 or 0)
    end
  end
  local tab_x, tab_y, tab_w, tab_h = self:get_tab_rect(tab_index)
  if x > tab_x + tab_w / 2 and tab_index <= #self.views then
    -- use next tab
    tab_x = tab_x + tab_w
    tab_index = tab_index + 1
  end
  if self == dragged_node and dragged_index and tab_index > dragged_index then
    -- the tab we are moving is counted in tab_index
    tab_index = tab_index - 1
    tab_x = tab_x - tab_w
  end
  return tab_index, tab_x, tab_y, tab_w, tab_h
end

return Node
---@class core.object
---@field super core.object
local Object = {}
Object.__index = Object

---Can be overrided by child objects to implement a constructor.
function Object:new() end

---@return core.object
function Object:extend()
  local cls = {}
  for k, v in pairs(self) do
    if k:find("__") == 1 then
      cls[k] = v
    end
  end
  cls.__index = cls
  cls.super = self
  setmetatable(cls, self)
  return cls
end

---Check if the object is strictly of the given type.
---@param T any
---@return boolean
function Object:is(T)
  return getmetatable(self) == T
end

---Check if the object inherits from the given type.
---@param T any
---@return boolean
function Object:extends(T)
  local mt = getmetatable(self)
  while mt do
    if mt == T then
      return true
    end
    mt = getmetatable(mt)
  end
  return false
end

---Metamethod to get a string representation of an object.
---@return string
function Object:__tostring()
  return "Object"
end

---Methamethod to allow using the object call as a constructor.
---@return core.object
function Object:__call(...)
  local obj = setmetatable({}, self)
  obj:new(...)
  return obj
end


return Object
-- So that in addition to regex.gsub(pattern, string), we can also do
-- pattern:gsub(string).
regex.__index = function(table, key) return regex[key]; end

---Looks for the first match of `pattern` in the string `str`.
---If it finds a match, it returns the indices of `str` where this occurrence
---starts and ends; otherwise, it returns `nil`.
---If the pattern has captures, the captured start and end indexes are returned,
---after the two initial ones.
---
---@param pattern string|table The regex pattern to use, either as a simple string or precompiled.
---@param str string The string to search for valid matches.
---@param offset? integer The position on the subject to start searching.
---@param options? integer A bit field of matching options, eg: regex.NOTBOL | regex.NOTEMPTY
---
---@return integer? start Offset where the first match was found; `nil` if no match.
---@return integer? end Offset where the first match ends; `nil` if no match.
---@return integer? ... #Captured matches offsets.
regex.find_offsets = function(pattern, str, offset, options)
  if type(pattern) ~= "table" then
    pattern = regex.compile(pattern)
  end
  local res = { regex.cmatch(pattern, str, offset or 1, options or 0) }
  -- Reduce every end delimiter by 1
  for i = 2,#res,2 do
    res[i] = res[i] - 1
  end
  return table.unpack(res)
end

---Behaves like `string.match`.
---Looks for the first match of `pattern` in the string `str`.
---If it finds a match, it returns the matched string; otherwise, it returns `nil`.
---If the pattern has captures, only the captured strings are returned.
---If a capture is empty, its offset is returned instead.
---
---@param pattern string|table The regex pattern to use, either as a simple string or precompiled.
---@param str string The string to search for valid matches.
---@param offset? integer The position on the subject to start searching.
---@param options? integer A bit field of matching options, eg: regex.NOTBOL | regex.NOTEMPTY
---
---@return (string|integer)? ... #List of captured matches; the entire match if no matches were specified; if the match is empty, its offset is returned instead.
regex.match = function(pattern, str, offset, options)
  local res = { regex.find(pattern, str, offset, options) }
  if #res == 0 then return end
  -- If available, only return captures
  if #res > 2 then return table.unpack(res, 3) end
  return string.sub(str, res[1], res[2])
end

---Behaves like `string.find`.
---Looks for the first match of `pattern` in the string `str`.
---If it finds a match, it returns the indices of `str` where this occurrence
---starts and ends; otherwise, it returns `nil`.
---If the pattern has captures, the captured strings are returned,
---after the two indexes ones.
---If a capture is empty, its offset is returned instead.
---
---@param pattern string|table The regex pattern to use, either as a simple string or precompiled.
---@param str string The string to search for valid matches.
---@param offset? integer The position on the subject to start searching.
---@param options? integer A bit field of matching options, eg: regex.NOTBOL | regex.NOTEMPTY
---
---@return integer? start Offset where the first match was found; `nil` if no match.
---@return integer? end Offset where the first match ends; `nil` if no match.
---@return (string|integer)? ... #List of captured matches; if the match is empty, its offset is returned instead.
regex.find = function(pattern, str, offset, options)
  local res = { regex.find_offsets(pattern, str, offset, options) }
  local out = { }
  if #res == 0 then return end
  out[1] = res[1]
  out[2] = res[2]
  for i = 3,#res,2 do
    if res[i] > res[i+1] then
      -- Like in string.find, if the group has size 0, return the index
      table.insert(out, res[i])
    else
      table.insert(out, string.sub(str, res[i], res[i+1]))
    end
  end
  return table.unpack(out)
end
local core = require "core"
local common = require "core.common"
local style = require "core.style"
local Node = require "core.node"
local View = require "core.view"
local DocView = require "core.docview"

---@class core.rootview : core.view
---@field super core.view
---@field root_node core.node
---@field mouse core.view.position
local RootView = View:extend()

function RootView:new()
  RootView.super.new(self)
  self.root_node = Node()
  self.deferred_draws = {}
  self.mouse = { x = 0, y = 0 }
  self.drag_overlay = { x = 0, y = 0, w = 0, h = 0, visible = false, opacity = 0,
                        base_color = style.drag_overlay,
                        color = { table.unpack(style.drag_overlay) } }
  self.drag_overlay.to = { x = 0, y = 0, w = 0, h = 0 }
  self.drag_overlay_tab = { x = 0, y = 0, w = 0, h = 0, visible = false, opacity = 0,
                            base_color = style.drag_overlay_tab,
                            color = { table.unpack(style.drag_overlay_tab) } }
  self.drag_overlay_tab.to = { x = 0, y = 0, w = 0, h = 0 }
end


function RootView:defer_draw(fn, ...)
  table.insert(self.deferred_draws, 1, { fn = fn, ... })
end


---@return core.node
function RootView:get_active_node()
  local node = self.root_node:get_node_for_view(core.active_view)
  if not node then node = self:get_primary_node() end
  return node
end


---@return core.node
local function get_primary_node(node)
  if node.is_primary_node then
    return node
  end
  if node.type ~= "leaf" then
    return get_primary_node(node.a) or get_primary_node(node.b)
  end
end


---@return core.node
function RootView:get_active_node_default()
  local node = self.root_node:get_node_for_view(core.active_view)
  if not node then node = self:get_primary_node() end
  if node.locked then
    local default_view = self:get_primary_node().views[1]
    assert(default_view, "internal error: cannot find original document node.")
    core.set_active_view(default_view)
    node = self:get_active_node()
  end
  return node
end


---@return core.node
function RootView:get_primary_node()
  return get_primary_node(self.root_node)
end


---@param node core.node
---@return core.node
local function select_next_primary_node(node)
  if node.is_primary_node then return end
  if node.type ~= "leaf" then
    return select_next_primary_node(node.a) or select_next_primary_node(node.b)
  else
    local lx, ly = node:get_locked_size()
    if not lx and not ly then
      return node
    end
  end
end


---@return core.node
function RootView:select_next_primary_node()
  return select_next_primary_node(self.root_node)
end


---@param doc core.doc
---@return core.docview
function RootView:open_doc(doc)
  local node = self:get_active_node_default()
  for i, view in ipairs(node.views) do
    if view.doc == doc then
      node:set_active_view(node.views[i])
      return view
    end
  end
  local view = DocView(doc)
  node:add_view(view)
  self.root_node:update_layout()
  view:scroll_to_line(view.doc:get_selection(), true, true)
  return view
end


---@param keep_active boolean
function RootView:close_all_docviews(keep_active)
  self.root_node:close_all_docviews(keep_active)
end


---Function to intercept mouse pressed events on the active view.
---Do nothing by default.
---@param button core.view.mousebutton
---@param x number
---@param y number
---@param clicks integer
function RootView.on_view_mouse_pressed(button, x, y, clicks)
end


---@param button core.view.mousebutton
---@param x number
---@param y number
---@param clicks integer
---@return boolean
function RootView:on_mouse_pressed(button, x, y, clicks)
  local div = self.root_node:get_divider_overlapping_point(x, y)
  local node = self.root_node:get_child_overlapping_point(x, y)
  if div and (node and not node.active_view:scrollbar_overlaps_point(x, y)) then
    self.dragged_divider = div
    return true
  end
  if node.hovered_scroll_button > 0 then
    node:scroll_tabs(node.hovered_scroll_button)
    return true
  end
  local idx = node:get_tab_overlapping_point(x, y)
  if idx then
    if button == "middle" or node.hovered_close == idx then
      node:close_view(self.root_node, node.views[idx])
      return true
    else
      if button == "left" then
        self.dragged_node = { node = node, idx = idx, dragging = false, drag_start_x = x, drag_start_y = y}
      end
      node:set_active_view(node.views[idx])
      return true
    end
  elseif not self.dragged_node then -- avoid sending on_mouse_pressed events when dragging tabs
    core.set_active_view(node.active_view)
    return self.on_view_mouse_pressed(button, x, y, clicks) or node.active_view:on_mouse_pressed(button, x, y, clicks)
  end
end


function RootView:get_overlay_base_color(overlay)
  if overlay == self.drag_overlay then
    return style.drag_overlay
  else
    return style.drag_overlay_tab
  end
end


function RootView:set_show_overlay(overlay, status)
  overlay.visible = status
  if status then -- reset colors
    -- reload base_color
    overlay.base_color = self:get_overlay_base_color(overlay)
    overlay.color[1] = overlay.base_color[1]
    overlay.color[2] = overlay.base_color[2]
    overlay.color[3] = overlay.base_color[3]
    overlay.color[4] = overlay.base_color[4]
    overlay.opacity = 0
  end
end


---@param button core.view.mousebutton
---@param x number
---@param y number
function RootView:on_mouse_released(button, x, y, ...)
  if self.dragged_divider then
    self.dragged_divider = nil
  end
  if self.dragged_node then
    if button == "left" then
      if self.dragged_node.dragging then
        local node = self.root_node:get_child_overlapping_point(self.mouse.x, self.mouse.y)
        local dragged_node = self.dragged_node.node

        if node and not node.locked
           -- don't do anything if dragging onto own node, with only one view
           and (node ~= dragged_node or #node.views > 1) then
          local split_type = node:get_split_type(self.mouse.x, self.mouse.y)
          local view = dragged_node.views[self.dragged_node.idx]

          if split_type ~= "middle" and split_type ~= "tab" then -- needs splitting
            local new_node = node:split(split_type)
            self.root_node:get_node_for_view(view):remove_view(self.root_node, view)
            new_node:add_view(view)
          elseif split_type == "middle" and node ~= dragged_node then -- move to other node
            dragged_node:remove_view(self.root_node, view)
            node:add_view(view)
            self.root_node:get_node_for_view(view):set_active_view(view)
          elseif split_type == "tab" then -- move besides other tabs
            local tab_index = node:get_drag_overlay_tab_position(self.mouse.x, self.mouse.y, dragged_node, self.dragged_node.idx)
            dragged_node:remove_view(self.root_node, view)
            node:add_view(view, tab_index)
            self.root_node:get_node_for_view(view):set_active_view(view)
          end
          self.root_node:update_layout()
          core.redraw = true
        end
      end
      self:set_show_overlay(self.drag_overlay, false)
      self:set_show_overlay(self.drag_overlay_tab, false)
      if self.dragged_node and self.dragged_node.dragging then
        core.request_cursor("arrow")
      end
      self.dragged_node = nil
    end
  else -- avoid sending on_mouse_released events when dragging tabs
    self.root_node:on_mouse_released(button, x, y, ...)
  end
end


local function resize_child_node(node, axis, value, delta)
  local accept_resize = node.a:resize(axis, value)
  if not accept_resize then
    accept_resize = node.b:resize(axis, node.size[axis] - value)
  end
  if not accept_resize then
    node.divider = node.divider + delta / node.size[axis]
  end
end


---@param x number
---@param y number
---@param dx number
---@param dy number
function RootView:on_mouse_moved(x, y, dx, dy)
  if core.active_view == core.nag_view then
    core.request_cursor("arrow")
    core.active_view:on_mouse_moved(x, y, dx, dy)
    return
  end

  if self.dragged_divider then
    local node = self.dragged_divider
    if node.type == "hsplit" then
      x = common.clamp(x, 0, self.root_node.size.x * 0.95)
      resize_child_node(node, "x", x, dx)
    elseif node.type == "vsplit" then
      y = common.clamp(y, 0, self.root_node.size.y * 0.95)
      resize_child_node(node, "y", y, dy)
    end
    node.divider = common.clamp(node.divider, 0.01, 0.99)
    return
  end

  self.mouse.x, self.mouse.y = x, y

  local dn = self.dragged_node
  if dn and not dn.dragging then
    -- start dragging only after enough movement
    dn.dragging = common.distance(x, y, dn.drag_start_x, dn.drag_start_y) > style.tab_width * .05
    if dn.dragging then
      core.request_cursor("hand")
    end
  end

  -- avoid sending on_mouse_moved events when dragging tabs
  if dn then return end

  self.root_node:on_mouse_moved(x, y, dx, dy)

  local last_overlapping_node = self.overlapping_node
  self.overlapping_node = self.root_node:get_child_overlapping_point(x, y)

  if last_overlapping_node and last_overlapping_node ~= self.overlapping_node then
    last_overlapping_node:on_mouse_left()
  end

  local div = self.root_node:get_divider_overlapping_point(x, y)
  local tab_index = self.overlapping_node and self.overlapping_node:get_tab_overlapping_point(x, y)
  if self.overlapping_node and self.overlapping_node:get_scroll_button_index(x, y) then
    core.request_cursor("arrow")
  elseif div and (self.overlapping_node and not self.overlapping_node.active_view:scrollbar_overlaps_point(x, y)) then
    core.request_cursor(div.type == "hsplit" and "sizeh" or "sizev")
  elseif tab_index then
    core.request_cursor("arrow")
  elseif self.overlapping_node then
    core.request_cursor(self.overlapping_node.active_view.cursor)
  end
end


function RootView:on_mouse_left()
  if self.overlapping_node then
    self.overlapping_node:on_mouse_left()
  end
end


---@param filename string
---@param x number
---@param y number
---@return boolean
function RootView:on_file_dropped(filename, x, y)
  local node = self.root_node:get_child_overlapping_point(x, y)
  return node and node.active_view:on_file_dropped(filename, x, y)
end


function RootView:on_mouse_wheel(...)
  local x, y = self.mouse.x, self.mouse.y
  local node = self.root_node:get_child_overlapping_point(x, y)
  return node.active_view:on_mouse_wheel(...)
end


function RootView:on_text_input(...)
  core.active_view:on_text_input(...)
end

function RootView:on_ime_text_editing(...)
  core.active_view:on_ime_text_editing(...)
end

function RootView:on_focus_lost(...)
  -- We force a redraw so documents can redraw without the cursor.
  core.redraw = true
end


function RootView:interpolate_drag_overlay(overlay)
  self:move_towards(overlay, "x", overlay.to.x, nil, "tab_drag")
  self:move_towards(overlay, "y", overlay.to.y, nil, "tab_drag")
  self:move_towards(overlay, "w", overlay.to.w, nil, "tab_drag")
  self:move_towards(overlay, "h", overlay.to.h, nil, "tab_drag")

  self:move_towards(overlay, "opacity", overlay.visible and 100 or 0, nil, "tab_drag")
  overlay.color[4] = overlay.base_color[4] * overlay.opacity / 100
end


function RootView:update()
  Node.copy_position_and_size(self.root_node, self)
  self.root_node:update()
  self.root_node:update_layout()

  self:update_drag_overlay()
  self:interpolate_drag_overlay(self.drag_overlay)
  self:interpolate_drag_overlay(self.drag_overlay_tab)
end


function RootView:set_drag_overlay(overlay, x, y, w, h, immediate)
  overlay.to.x = x
  overlay.to.y = y
  overlay.to.w = w
  overlay.to.h = h
  if immediate then
    overlay.x = x
    overlay.y = y
    overlay.w = w
    overlay.h = h
  end
  if not overlay.visible then
    self:set_show_overlay(overlay, true)
  end
end


local function get_split_sizes(split_type, x, y, w, h)
  if split_type == "left" then
    w = w * .5
  elseif split_type == "right" then
    x = x + w * .5
    w = w * .5
  elseif split_type == "up" then
    h = h * .5
  elseif split_type == "down" then
    y = y + h * .5
    h = h * .5
  end
  return x, y, w, h
end


function RootView:update_drag_overlay()
  if not (self.dragged_node and self.dragged_node.dragging) then return end
  local over = self.root_node:get_child_overlapping_point(self.mouse.x, self.mouse.y)
  if over and not over.locked then
    local _, _, _, tab_h = over:get_scroll_button_rect(1)
    local x, y = over.position.x, over.position.y
    local w, h = over.size.x, over.size.y
    local split_type = over:get_split_type(self.mouse.x, self.mouse.y)

    if split_type == "tab" and (over ~= self.dragged_node.node or #over.views > 1) then
      local tab_index, tab_x, tab_y, tab_w, tab_h = over:get_drag_overlay_tab_position(self.mouse.x, self.mouse.y)
      self:set_drag_overlay(self.drag_overlay_tab,
        tab_x + (tab_index and 0 or tab_w), tab_y,
        style.caret_width, tab_h,
        -- avoid showing tab overlay moving between nodes
        over ~= self.drag_overlay_tab.last_over)
      self:set_show_overlay(self.drag_overlay, false)
      self.drag_overlay_tab.last_over = over
    else
      if (over ~= self.dragged_node.node or #over.views > 1) then
        y = y + tab_h
        h = h - tab_h
        x, y, w, h = get_split_sizes(split_type, x, y, w, h)
      end
      self:set_drag_overlay(self.drag_overlay, x, y, w, h)
      self:set_show_overlay(self.drag_overlay_tab, false)
    end
  else
    self:set_show_overlay(self.drag_overlay, false)
    self:set_show_overlay(self.drag_overlay_tab, false)
  end
end


function RootView:draw_grabbed_tab()
  local dn = self.dragged_node
  local _,_, w, h = dn.node:get_tab_rect(dn.idx)
  local x = self.mouse.x - w / 2
  local y = self.mouse.y - h / 2
  local view = dn.node.views[dn.idx]
  self.root_node:draw_tab(view, true, true, false, x, y, w, h, true)
end


function RootView:draw_drag_overlay(ov)
  if ov.opacity > 0 then
    renderer.draw_rect(ov.x, ov.y, ov.w, ov.h, ov.color)
  end
end


function RootView:draw()
  self.root_node:draw()
  while #self.deferred_draws > 0 do
    local t = table.remove(self.deferred_draws)
    t.fn(table.unpack(t))
  end

  self:draw_drag_overlay(self.drag_overlay)
  self:draw_drag_overlay(self.drag_overlay_tab)
  if self.dragged_node and self.dragged_node.dragging then
    self:draw_grabbed_tab()
  end
  if core.cursor_change_req then
    system.set_cursor(core.cursor_change_req)
    core.cursor_change_req = nil
  end
end


return RootView
local core = require "core"
local common = require "core.common"
local config = require "core.config"
local style = require "core.style"
local Object = require "core.object"

---Scrollbar
---Use Scrollbar:set_size to set the bounding box of the view the scrollbar belongs to.
---Use Scrollbar:update to update the scrollbar animations.
---Use Scrollbar:draw to draw the scrollbar.
---Use Scrollbar:on_mouse_pressed, Scrollbar:on_mouse_released,
---Scrollbar:on_mouse_moved and Scrollbar:on_mouse_left to react to mouse movements;
---the scrollbar won't update automatically.
---Use Scrollbar:set_percent to set the scrollbar location externally.
---
---To manage all the orientations, the scrollbar changes the coordinates system
---accordingly. The "normal" coordinate system adapts the scrollbar coordinates
---as if it's always a vertical scrollbar, positioned at the end of the bounding box.
---@class core.scrollbar : core.object
local Scrollbar = Object:extend()

---@class ScrollbarOptions
---@field direction "v" | "h" @Vertical or Horizontal
---@field alignment "s" | "e" @Start or End (left to right, top to bottom)
---@field force_status "expanded" | "contracted" | false @Force the scrollbar status
---@field expanded_size number? @Override the default value specified by `style.expanded_scrollbar_size`
---@field contracted_size number? @Override the default value specified by `style.scrollbar_size`

---@param options ScrollbarOptions
function Scrollbar:new(options)
  ---Position information of the owner
  self.rect = {
    x = 0, y = 0, w = 0, h = 0,
    ---Scrollable size
    scrollable = 0
  }
  self.normal_rect = {
    across = 0,
    along = 0,
    across_size = 0,
    along_size = 0,
    scrollable = 0
  }
  ---@type integer @Position in percent [0-1]
  self.percent = 0
  ---@type boolean @Scrollbar dragging status
  self.dragging = false
  ---@type integer @Private. Used to offset the start of the drag from the top of the thumb
  self.drag_start_offset = 0
  ---What is currently being hovered. `thumb` implies` track`
  self.hovering = { track = false, thumb = false }
  ---@type "v" | "h"@Vertical or Horizontal
  self.direction = options.direction or "v"
  ---@type "s" | "e" @Start or End (left to right, top to bottom)
  self.alignment = options.alignment or "e"
  ---@type number @Private. Used to keep track of animations
  self.expand_percent = 0
  ---@type "expanded" | "contracted" | false @Force the scrollbar status
  self.force_status = options.force_status
  self:set_forced_status(options.force_status)
  ---@type number? @Override the default value specified by `style.expanded_scrollbar_size`
  self.contracted_size = options.contracted_size
  ---@type number? @Override the default value specified by `style.scrollbar_size`
  self.expanded_size = options.expanded_size
end


---Set the status the scrollbar is forced to keep
---@param status "expanded" | "contracted" | false @The status to force
function Scrollbar:set_forced_status(status)
  self.force_status = status
  if self.force_status == "expanded" then
    self.expand_percent = 1
  end
end


function Scrollbar:real_to_normal(x, y, w, h)
  x, y, w, h = x or 0, y or 0, w or 0, h or 0
  if self.direction == "v" then
    if self.alignment == "s" then
      x = (self.rect.x + self.rect.w) - x - w
    end
    return x, y, w, h
  else
    if self.alignment == "s" then
      y = (self.rect.y + self.rect.h) - y - h
    end
    return y, x, h, w
  end
end


function Scrollbar:normal_to_real(x, y, w, h)
  x, y, w, h = x or 0, y or 0, w or 0, h or 0
  if self.direction == "v" then
    if self.alignment == "s" then
      x = (self.rect.x + self.rect.w) - x - w
    end
    return x, y, w, h
  else
    if self.alignment == "s" then
      x = (self.rect.y + self.rect.h) - x - w
    end
    return y, x, h, w
  end
end


function Scrollbar:_get_thumb_rect_normal()
  local nr = self.normal_rect
  local sz = nr.scrollable
  if sz == math.huge or sz <= nr.along_size
  then
    return 0, 0, 0, 0
  end
  local scrollbar_size = self.contracted_size or style.scrollbar_size
  local expanded_scrollbar_size = self.expanded_size or style.expanded_scrollbar_size
  local along_size = math.max(20, nr.along_size * nr.along_size / sz)
  local across_size = scrollbar_size
  across_size = across_size + (expanded_scrollbar_size - scrollbar_size) * self.expand_percent
  return
    nr.across + nr.across_size - across_size,
    nr.along + self.percent * nr.scrollable * (nr.along_size - along_size) / (sz - nr.along_size),
    across_size,
    along_size
end

---Get the thumb rect (the part of the scrollbar that can be dragged)
---@return integer,integer,integer,integer @x, y, w, h
function Scrollbar:get_thumb_rect()
  return self:normal_to_real(self:_get_thumb_rect_normal())
end


function Scrollbar:_get_track_rect_normal()
  local nr = self.normal_rect
  local sz = nr.scrollable
  if sz <= nr.along_size or sz == math.huge then
    return 0, 0, 0, 0
  end
  local scrollbar_size = self.contracted_size or style.scrollbar_size
  local expanded_scrollbar_size = self.expanded_size or style.expanded_scrollbar_size
  local across_size = scrollbar_size
  across_size = across_size + (expanded_scrollbar_size - scrollbar_size) * self.expand_percent
  return
    nr.across + nr.across_size - across_size,
    nr.along,
    across_size,
    nr.along_size
end

---Get the track rect (the "background" of the scrollbar)
---@return number,number,number,number @x, y, w, h
function Scrollbar:get_track_rect()
  return self:normal_to_real(self:_get_track_rect_normal())
end


function Scrollbar:_overlaps_normal(x, y)
  local sx, sy, sw, sh = self:_get_thumb_rect_normal()
  local scrollbar_size = self.contracted_size or style.scrollbar_size
  local result
  if x >= sx - scrollbar_size * 3 and x <= sx + sw and y >= sy and y <= sy + sh then
    result = "thumb"
  else
    sx, sy, sw, sh = self:_get_track_rect_normal()
    if x >= sx - scrollbar_size * 3 and x <= sx + sw and y >= sy and y <= sy + sh then
      result = "track"
    end
  end
  return result
end

---Get what part of the scrollbar the coordinates overlap
---@return "thumb"|"track"|nil
function Scrollbar:overlaps(x, y)
  x, y = self:real_to_normal(x, y)
  return self:_overlaps_normal(x, y)
end


function Scrollbar:_on_mouse_pressed_normal(button, x, y, clicks)
  local overlaps = self:_overlaps_normal(x, y)
  if overlaps then
    local _, along, _, along_size = self:_get_thumb_rect_normal()
    self.dragging = true
    if overlaps == "thumb" then
      self.drag_start_offset = along - y
      return true
    elseif overlaps == "track" then
      self.drag_start_offset = - along_size / 2
      return (y - self.normal_rect.along - along_size / 2) / self.normal_rect.along_size
    end
  end
end

---Updates the scrollbar with mouse pressed info.
---Won't update the scrollbar position automatically.
---Use Scrollbar:set_percent to update it.
---
---This sets the dragging status if needed.
---
---Returns a falsy value if the event happened outside the scrollbar.
---Returns `true` if the thumb was pressed.
---If the track was pressed this returns a value between 0 and 1
---representing the percent of the position.
---@return boolean|number
function Scrollbar:on_mouse_pressed(button, x, y, clicks)
  if button ~= "left" then return end
  x, y = self:real_to_normal(x, y)
  return self:_on_mouse_pressed_normal(button, x, y, clicks)
end

---Updates the scrollbar hover status.
---This gets called by other functions and shouldn't be called manually
function Scrollbar:_update_hover_status_normal(x, y)
  local overlaps = self:_overlaps_normal(x, y)
  self.hovering.thumb = overlaps == "thumb"
  self.hovering.track = self.hovering.thumb or overlaps == "track"
  return self.hovering.track or self.hovering.thumb
end

function Scrollbar:_on_mouse_released_normal(button, x, y)
  self.dragging = false
  return self:_update_hover_status_normal(x, y)
end

---Updates the scrollbar dragging status
function Scrollbar:on_mouse_released(button, x, y)
  if button ~= "left" then return end
  x, y = self:real_to_normal(x, y)
  return self:_on_mouse_released_normal(button, x, y)
end


function Scrollbar:_on_mouse_moved_normal(x, y, dx, dy)
  if self.dragging then
    local nr = self.normal_rect
    return common.clamp((y - nr.along + self.drag_start_offset) / nr.along_size, 0, 1)
  end
  return self:_update_hover_status_normal(x, y)
end

---Updates the scrollbar with mouse moved info.
---Won't update the scrollbar position automatically.
---Use Scrollbar:set_percent to update it.
---
---This updates the hovering status.
---
---Returns a falsy value if the event happened outside the scrollbar.
---Returns `true` if the scrollbar is hovered.
---If the scrollbar was being dragged, this returns a value between 0 and 1
---representing the percent of the position.
---@return boolean|number
function Scrollbar:on_mouse_moved(x, y, dx, dy)
  x, y = self:real_to_normal(x, y)
  dx, dy = self:real_to_normal(dx, dy) -- TODO: do we need this? (is this even correct?)
  return self:_on_mouse_moved_normal(x, y, dx, dy)
end

---Updates the scrollbar hovering status
function Scrollbar:on_mouse_left()
  self.hovering.track, self.hovering.thumb = false, false
end

---Updates the bounding box of the view the scrollbar belongs to.
---@param x number
---@param y number
---@param w number
---@param h number
---@param scrollable number @size of the scrollable area
function Scrollbar:set_size(x, y, w, h, scrollable)
  self.rect.x, self.rect.y, self.rect.w, self.rect.h = x, y, w, h
  self.rect.scrollable = scrollable

  local nr = self.normal_rect
  nr.across, nr.along, nr.across_size, nr.along_size = self:real_to_normal(x, y, w, h)
  nr.scrollable = scrollable
end

---Updates the scrollbar location
---@param percent number @number between 0 and 1 representing the position of the middle part of the thumb
function Scrollbar:set_percent(percent)
  self.percent = percent
end

---Updates the scrollbar animations
function Scrollbar:update()
  -- TODO: move the animation code to its own class
  if not self.force_status then
    local dest = (self.hovering.track or self.dragging) and 1 or 0
    local diff = math.abs(self.expand_percent - dest)
    if not config.transitions or diff < 0.05 or config.disabled_transitions["scroll"] then
      self.expand_percent = dest
    else
      local rate = 0.3
      if config.fps ~= 60 or config.animation_rate ~= 1 then
        local dt = 60 / config.fps
        rate = 1 - common.clamp(1 - rate, 1e-8, 1 - 1e-8)^(config.animation_rate * dt)
      end
      self.expand_percent = common.lerp(self.expand_percent, dest, rate)
    end
    if diff > 1e-8 then
      core.redraw = true
    end
  elseif self.force_status == "expanded" then
    self.expand_percent = 1
  elseif self.force_status == "contracted" then
    self.expand_percent = 0
  end
end


---Draw the scrollbar track
function Scrollbar:draw_track()
  if not (self.hovering.track or self.dragging)
     and self.expand_percent == 0 then
    return
  end
  local color = { table.unpack(style.scrollbar_track) }
  color[4] = color[4] * self.expand_percent
  local x, y, w, h = self:get_track_rect()
  renderer.draw_rect(x, y, w, h, color)
end

---Draw the scrollbar thumb
function Scrollbar:draw_thumb()
  local highlight = self.hovering.thumb or self.dragging
  local color = highlight and style.scrollbar2 or style.scrollbar
  local x, y, w, h = self:get_thumb_rect()
  renderer.draw_rect(x, y, w, h, color)
end

---Draw both the scrollbar track and thumb
function Scrollbar:draw()
  self:draw_track()
  self:draw_thumb()
end


return Scrollbar
-- this file is used by lite-xl to setup the Lua environment when starting
MOD_VERSION = "3"

SCALE = tonumber(os.getenv("LITE_SCALE") or os.getenv("GDK_SCALE") or os.getenv("QT_SCALE_FACTOR")) or SCALE
PATHSEP = package.config:sub(1, 1)

EXEDIR = EXEFILE:match("^(.+)[/\\][^/\\]+$")
if MACOS_RESOURCES then
  DATADIR = MACOS_RESOURCES
else
  local prefix = EXEDIR:match("^(.+)[/\\]bin$")
  DATADIR = prefix and (prefix .. PATHSEP .. 'share' .. PATHSEP .. 'lite-xl') or (EXEDIR .. PATHSEP .. 'data')
end
USERDIR = (system.get_file_info(EXEDIR .. PATHSEP .. 'user') and (EXEDIR .. PATHSEP .. 'user'))
       or os.getenv("LITE_USERDIR")
       or ((os.getenv("XDG_CONFIG_HOME") and os.getenv("XDG_CONFIG_HOME") .. PATHSEP .. "lite-xl"))
       or (HOME and (HOME .. PATHSEP .. '.config' .. PATHSEP .. 'lite-xl'))

package.path = DATADIR .. '/?.lua;'
package.path = DATADIR .. '/?/init.lua;' .. package.path
package.path = USERDIR .. '/?.lua;' .. package.path
package.path = USERDIR .. '/?/init.lua;' .. package.path

local suffix = PLATFORM == "Mac OS X" and 'lib' or (PLATFORM == "Windows" and 'dll' or 'so')
package.cpath =
  USERDIR .. '/?.' .. ARCH .. "." .. suffix .. ";" ..
  USERDIR .. '/?/init.' .. ARCH .. "." .. suffix .. ";" ..
  USERDIR .. '/?.' .. suffix .. ";" ..
  USERDIR .. '/?/init.' .. suffix .. ";" ..
  DATADIR .. '/?.' .. ARCH .. "." .. suffix .. ";" ..
  DATADIR .. '/?/init.' .. ARCH .. "." .. suffix .. ";" ..
  DATADIR .. '/?.' .. suffix .. ";" ..
  DATADIR .. '/?/init.' .. suffix .. ";"

package.native_plugins = {}
local searchers = package.searchers and "searchers" or "loaders"


local function iterate_paths(paths, modname, callback)
  local s = 1
  return function() 
    if s > #paths then return nil end
    local e = paths:find(";", s) or (#paths+1)
    local module_path = modname:gsub("%.", "/")
    local path = paths:sub(s, e - 1):gsub("?", module_path)
    s = e + 1
    return path
  end
end


loadstring = loadstring or load
package[searchers] = { function (modname) 
  for path in iterate_paths(package.path, modname) do
    local internal_file = system.get_internal_file(path)
    if internal_file then return function() return loadstring(internal_file, path)() end, path end
  end
  return nil
end, package[searchers][1], package[searchers][2], function(modname)
  for path in iterate_paths(package.path, modname) do
    if system.get_file_info(path) then return system.load_native_plugin, path end
  end
  return nil
end }

table.pack = table.pack or pack or function(...) return {...} end
table.unpack = table.unpack or unpack

-- For internal files, to let plugins loading work.
local old_io_lines = io.lines
io.lines = function(path)
  if type(path) == "string" and path:find(DATADIR, 1, true) == 1 then
    local internal_file = system.get_internal_file(path)
    if internal_file then return internal_file:gmatch("([^\n]*)\n?") end
  end
  return old_io_lines(path)
end

bit32 = bit32 or require "core.bit"

require "core.utf8string"

-- Because AppImages change the working directory before running the executable,
-- we need to change it back to the original one.
-- https://github.com/AppImage/AppImageKit/issues/172
-- https://github.com/AppImage/AppImageKit/pull/191
local appimage_owd = os.getenv("OWD")
if os.getenv("APPIMAGE") and appimage_owd then
  system.chdir(appimage_owd)
end

-- compatibility with lite-xl
string.ufind = string.find
local core = require "core"
local common = require "core.common"
local command = require "core.command"
local config = require "core.config"
local style = require "core.style"
local DocView = require "core.docview"
local CommandView = require "core.commandview"
local LogView = require "core.logview"
local View = require "core.view"
local Object = require "core.object"


---@alias core.statusview.styledtext table<integer, renderer.font|renderer.color|string>
---@alias core.statusview.position '"left"' | '"right"'

---A status bar implementation for lite, check core.status_view.
---@class core.statusview : core.view
---@field super core.view
---@field items core.statusview.item[]
---@field active_items core.statusview.item[]
---@field hovered_item core.statusview.item
---@field message_timeout number
---@field message core.statusview.styledtext
---@field tooltip_mode boolean
---@field tooltip core.statusview.styledtext
---@field left_width number
---@field right_width number
---@field r_left_width number
---@field r_right_width number
---@field left_xoffset number
---@field right_xoffset number
---@field dragged_panel '""' | core.statusview.position
---@field hovered_panel '""' | core.statusview.position
---@field hide_messages boolean
local StatusView = View:extend()

---Space separator
---@type string
StatusView.separator  = "      "

---Pipe separator
---@type string
StatusView.separator2 = "   |   "

---@alias core.statusview.item.separator
---|>`StatusView.separator`
---| `StatusView.separator2`

---@alias core.statusview.item.predicate fun():boolean
---@alias core.statusview.item.onclick fun(button: string, x: number, y: number)
---@alias core.statusview.item.get_item fun(self: core.statusview.item):core.statusview.styledtext?,core.statusview.styledtext?
---@alias core.statusview.item.ondraw fun(x, y, h, hovered: boolean, calc_only?: boolean):number

---@class core.statusview.item : core.object
---@field name string
---@field predicate core.statusview.item.predicate
---@field alignment core.statusview.item.alignment
---@field tooltip string
---@field command string | nil @Command to perform when the item is clicked.
---Function called when item is clicked and no command is set.
---@field on_click core.statusview.item.onclick | nil
---Custom drawing that when passed calc true should return the needed width for
---drawing and when false should draw.
---@field on_draw core.statusview.item.ondraw | nil
---@field background_color renderer.color | nil
---@field background_color_hover renderer.color | nil
---@field visible boolean
---@field separator core.statusview.item.separator
---@field active boolean
---@field x number
---@field w number
---@field cached_item core.statusview.styledtext
local StatusViewItem = Object:extend()

---Available StatusViewItem options.
---@class core.statusview.item.options : table
---A condition to evaluate if the item should be displayed. If a string
---is given it is treated as a require import that should return a valid object
---which is checked against the current active view, the sames applies if a
---table is given. A function that returns a boolean can be used instead to
---perform a custom evaluation, setting to nil means always evaluates to true.
---@field predicate string | table | core.statusview.item.predicate
---A unique name to identify the item on the status bar.
---@field name string @A unique name to identify the item on the status bar.
---@field alignment core.statusview.item.alignment
---A function that should return a core.statusview.styledtext element,
---returning an empty table is allowed.
---@field get_item core.statusview.item.get_item
---The name of a valid registered command or a callback function to execute
---when the item is clicked.
---@field command string | core.statusview.item.onclick | nil
---The position in which to insert the given item on the internal table,
---a value of -1 inserts the item at the end which is the default. A value
---of 1 will insert the item at the beggining.
---@field position? integer
---@field tooltip? string @Text displayed when mouse hovers the item.
---@field visible boolean @Flag to show or hide the item
---The type of separator rendered to the right of the item if another item
---follows it.
---@field separator? core.statusview.item.separator

---Flag to tell the item should me aligned on left side of status bar.
---@type integer
StatusViewItem.LEFT = 1

---Flag to tell the item should me aligned on right side of status bar.
---@type integer
StatusViewItem.RIGHT = 2

---@alias core.statusview.item.alignment
---|>`StatusView.Item.LEFT`
---| `StatusView.Item.RIGHT`

---Constructor
---@param options core.statusview.item.options
function StatusViewItem:new(options)
  self:set_predicate(options.predicate)
  self.name = options.name
  self.alignment = options.alignment or StatusView.Item.LEFT
  self.command = type(options.command) == "string" and options.command or nil
  self.tooltip = options.tooltip or ""
  self.on_click = type(options.command) == "function" and options.command or nil
  self.on_draw = nil
  self.background_color = nil
  self.background_color_hover = nil
  self.visible = options.visible == nil and true or options.visible
  self.active = false
  self.x = 0
  self.w = 0
  self.separator = options.separator or StatusView.separator
  self.get_item = options.get_item
end

---Called by the status bar each time that the item needs to be rendered,
---if on_draw() is set this function is obviated.
---@return core.statusview.styledtext
function StatusViewItem:get_item() return {} end

---Do not show the item on the status bar.
function StatusViewItem:hide() self.visible = false end

---Show the item on the status bar.
function StatusViewItem:show() self.visible = true end

---A condition to evaluate if the item should be displayed. If a string
---is given it is treated as a require import that should return a valid object
---which is checked against the current active view, the sames applies if a
---table is given. A function that returns a boolean can be used instead to
---perform a custom evaluation, setting to nil means always evaluates to true.
---@param predicate string | table | core.statusview.item.predicate
function StatusViewItem:set_predicate(predicate)
  self.predicate = command.generate_predicate(predicate)
end

---@type core.statusview.item
StatusView.Item = StatusViewItem


---Predicated used on the default docview widgets.
---@return boolean
local function predicate_docview()
  return  core.active_view:is(DocView)
    and not core.active_view:is(CommandView)
end


---Constructor
function StatusView:new()
  StatusView.super.new(self)
  self.message_timeout = 0
  self.message = {}
  self.tooltip_mode = false
  self.tooltip = {}
  self.items = {}
  self.active_items = {}
  self.hovered_item = {}
  self.pointer = {x = 0, y = 0}
  self.left_width = 0
  self.right_width = 0
  self.r_left_width = 0
  self.r_right_width = 0
  self.left_xoffset = 0
  self.right_xoffset = 0
  self.dragged_panel = ""
  self.hovered_panel = ""
  self.hide_messages = false
  self.visible = true

  self:register_docview_items()
  self:register_command_items()
end

---The predefined status bar items displayed when a document view is active.
function StatusView:register_docview_items()
  if self:get_item("doc:file") then return end

  self:add_item({
    predicate = predicate_docview,
    name = "doc:file",
    alignment = StatusView.Item.LEFT,
    get_item = function()
      local dv = core.active_view
      return {
        dv.doc:is_dirty() and style.accent or style.text, style.icon_font, "f",
        style.dim, style.font, self.separator2, style.text,
        dv.doc.filename and style.text or style.dim, common.home_encode(dv.doc:get_name())
      }
    end
  })

  self:add_item({
    predicate = predicate_docview,
    name = "doc:position",
    alignment = StatusView.Item.LEFT,
    get_item = function()
      local dv = core.active_view
      local line, col = dv.doc:get_selection()
      local _, indent_size = dv.doc:get_indent_info()
      -- Calculating tabs when the doc is using the "hard" indent type.
      local ntabs = 0
      local last_idx = 0
      while last_idx < col do
        local s, e = string.find(dv.doc.lines[line], "\t", last_idx, true)
        if s and s < col then
          ntabs = ntabs + 1
          last_idx = e + 1
        else
          break
        end
      end
      col = col + ntabs * (indent_size - 1)
      return {
        style.text, line, ":",
        col > config.line_limit and style.accent or style.text, col,
        style.text,
        self.separator,
        string.format("%.f%%", line / #dv.doc.lines * 100)
      }
    end,
    command = "doc:go-to-line",
    tooltip = "line : column"
  })

  self:add_item({
    predicate = predicate_docview,
    name = "doc:indentation",
    alignment = StatusView.Item.RIGHT,
    get_item = function()
      local dv = core.active_view
      local indent_type, indent_size, indent_confirmed = dv.doc:get_indent_info()
      local indent_label = (indent_type == "hard") and "tabs: " or "spaces: "
      return {
        style.text, indent_label, indent_size,
        indent_confirmed and "" or "*"
      }
    end,
    command = function(button, x, y)
      if button == "left" then
        command.perform "indent:set-file-indent-size"
      elseif button == "right" then
        command.perform "indent:set-file-indent-type"
      end
    end,
    separator = self.separator2
  })

  self:add_item({
    predicate = predicate_docview,
    name = "doc:lines",
    alignment = StatusView.Item.RIGHT,
    get_item = function()
      local dv = core.active_view
      return {
        style.text,
        style.icon_font, "g",
        style.font, style.dim, self.separator2,
        style.text, #dv.doc.lines, " lines",
      }
    end,
    separator = self.separator2
  })

  self:add_item({
    predicate = predicate_docview,
    name = "doc:line-ending",
    alignment = StatusView.Item.RIGHT,
    get_item = function()
      local dv = core.active_view
      return {
        style.text, dv.doc.crlf and "CRLF" or "LF"
      }
    end,
    command = "doc:toggle-line-ending"
  })
end


---The predefined status bar items displayed when a command view is active.
function StatusView:register_command_items()
  if self:get_item("command:files") then return end

  self:add_item({
    predicate = "core.commandview",
    name = "command:files",
    alignment = StatusView.Item.RIGHT,
    get_item = function()
      return {
        style.icon_font, "g",
        style.font, style.dim, self.separator2,
        style.text, #core.docs, style.text, " / ",
        #core.project_files, " files"
      }
    end
  })
end


---Set a position to the best match according to total available items.
---@param self core.statusview
---@param position integer
---@param alignment core.statusview.item.alignment
---@return integer position
local function normalize_position(self, position, alignment)
  local offset = 0
  local items_count = 0
  local left = self:get_items_list(1)
  local right = self:get_items_list(2)
  if alignment == 2 then
    items_count = #right
    offset = #left
  else
    items_count = #left
  end
  if position == 0 then
    position = offset +  1
  elseif position < 0 then
    position = offset + items_count + (position + 2)
  else
    position = offset + position
  end
  if position < 1 then
    position = offset + 1
  elseif position > #left + #right then
    position = offset + items_count + 1
  end
  return position
end


---Adds an item to be rendered in the status bar.
---@param options core.statusview.item.options
---@return core.statusview.item
function StatusView:add_item(options)
  assert(self:get_item(options.name) == nil, "status item already exists: " .. options.name)
  ---@type core.statusview.item
  local item = StatusView.Item(options)
  table.insert(self.items, normalize_position(self, options.position or -1, options.alignment), item)
  return item
end


---Get an item object associated to a name or nil if not found.
---@param name string
---@return core.statusview.item | nil
function StatusView:get_item(name)
  for _, item in ipairs(self.items) do
    if item.name == name then return item end
  end
  return nil
end


---Get a list of items.
---@param alignment? core.statusview.item.alignment
---@return core.statusview.item[]
function StatusView:get_items_list(alignment)
  if alignment then
    local items = {}
    for _, item in ipairs(self.items) do
      if item.alignment == alignment then
        table.insert(items, item)
      end
    end
    return items
  end
  return self.items
end


---Move an item to a different position.
---@param name string
---@param position integer Can be negative value to position in reverse order
---@param alignment? core.statusview.item.alignment
---@return boolean moved
function StatusView:move_item(name, position, alignment)
  assert(name, "no name provided")
  assert(position, "no position provided")
  local item = nil
  for pos, it in ipairs(self.items) do
    if it.name == name then
      item = table.remove(self.items, pos)
      break
    end
  end
  if item then
    if alignment then
      item.alignment = alignment
    end
    position = normalize_position(self, position, item.alignment)
    table.insert(self.items, position, item)
    return true
  end
  return false
end


---Remove an item from the status view.
---@param name string
---@return core.statusview.item removed_item
function StatusView:remove_item(name)
  local item = nil
  for pos, it in ipairs(self.items) do
    if it.name == name then
      item = table.remove(self.items, pos)
      break
    end
  end
  return item
end


---Order the items by name
---@param names table<integer, string>
function StatusView:order_items(names)
  local removed_items = {}
  for _, name in ipairs(names) do
    local item = self:remove_item(name)
    if item then table.insert(removed_items, item) end
  end

  for i, item in ipairs(removed_items) do
    table.insert(self.items, i, item)
  end
end


---Hide the status bar
function StatusView:hide()
  self.visible = false
end


---Show the status bar
function StatusView:show()
  self.visible = true
end


---Toggle the visibility of the status bar
function StatusView:toggle()
  self.visible = not self.visible
end


---Hides the given items from the status view or all if no names given.
---@param names? table<integer, string> | string
function StatusView:hide_items(names)
  if type(names) == "string" then
    names = {names}
  end
  if not names then
    for _, item in ipairs(self.items) do
      item:hide()
    end
    return
  end
  for _, name in ipairs(names) do
    local item = self:get_item(name)
    if item then item:hide() end
  end
end


---Shows the given items from the status view or all if no names given.
---@param names? table<integer, string> | string
function StatusView:show_items(names)
  if type(names) == "string" then
    names = {names}
  end
  if not names then
    for _, item in ipairs(self.items) do
      item:show()
    end
    return
  end
  for _, name in ipairs(names) do
    local item = self:get_item(name)
    if item then item:show() end
  end
end


---Shows a message for a predefined amount of time.
---@param icon string
---@param icon_color renderer.color
---@param text string
function StatusView:show_message(icon, icon_color, text)
  if not self.visible or self.hide_messages then return end
  self.message = {
    icon_color, style.icon_font, icon,
    style.dim, style.font, StatusView.separator2, style.text, text
  }
  self.message_timeout = system.get_time() + config.message_timeout
end


---Enable or disable system wide messages on the status bar.
---@param enable boolean
function StatusView:display_messages(enable)
  self.hide_messages = not enable
end


---Activates tooltip mode displaying only the given
---text until core.statusview:remove_tooltip() is called.
---@param text string | core.statusview.styledtext
function StatusView:show_tooltip(text)
  self.tooltip = type(text) == "table" and text or { text }
  self.tooltip_mode = true
end


---Deactivates tooltip mode.
function StatusView:remove_tooltip()
  self.tooltip_mode = false
end


---Helper function to draw the styled text.
---@param self core.statusview
---@param items core.statusview.styledtext
---@param x number
---@param y number
---@param draw_fn fun(font,color,text,align, x,y,w,h):number
local function draw_items(self, items, x, y, draw_fn)
  local font = style.font
  local color = style.text

  for _, item in ipairs(items) do
    if Object.is(item, renderer.font) then
      font = item
    elseif type(item) == "table" then
      color = item
    else
      x = draw_fn(font, color, item, nil, x, y, 0, self.size.y)
    end
  end

  return x
end


---Helper function to calculate the width of text by using it as part of
---the helper function draw_items().
---@param font renderer.font
---@param text string
---@param x number
local function text_width(font, _, text, _, x)
  return x + font:get_width(text)
end


---Draws a table of styled text on the status bar starting on the left or right.
---@param items core.statusview.styledtext
---@param right_align? boolean
---@param xoffset? number
---@param yoffset? number
function StatusView:draw_items(items, right_align, xoffset, yoffset)
  local x, y = self:get_content_offset()
  x = x + (xoffset or 0)
  y = y + (yoffset or 0)
  if right_align then
    local w = draw_items(self, items, 0, 0, text_width)
    x = x + self.size.x - w - style.padding.x
    draw_items(self, items, x, y, common.draw_text)
  else
    x = x + style.padding.x
    draw_items(self, items, x, y, common.draw_text)
  end
end


---Draw the tooltip of a given status bar item.
---@param item core.statusview.item
function StatusView:draw_item_tooltip(item)
  core.root_view:defer_draw(function()
    local text = item.tooltip
    local w = style.font:get_width(text)
    local h = style.font:get_height()
    local x = self.pointer.x - (w / 2) - (style.padding.x * 2)

    if x < 0 then x = 0 end
    if (x + w + (style.padding.x * 3)) > self.size.x then
      x = self.size.x - w - (style.padding.x * 3)
    end

    renderer.draw_rect(
      x + style.padding.x,
      self.position.y - h - (style.padding.y * 2),
      w + (style.padding.x * 2),
      h + (style.padding.y * 2),
      style.background3
    )

    renderer.draw_text(
      style.font,
      text,
      x + (style.padding.x * 2),
      self.position.y - h - style.padding.y,
      style.text
    )
  end)
end


---Older method of retrieving the status bar items and which is now
---deprecated in favour of core.status_view:add_item().
---@deprecated
---@param nowarn boolean
---@return table left
---@return table right
function StatusView:get_items(nowarn)
  if not nowarn and not self.get_items_warn then
    core.warn(
      "Overriding StatusView:get_items() is deprecated, "
      .. "use core.status_view:add_item() instead."
    )
    self.get_items_warn = true
  end
  return {"{:dummy:}"}, {"{:dummy:}"}
end


---Helper function to copy a styled text table into another.
---@param t1 core.statusview.styledtext
---@param t2 core.statusview.styledtext
local function table_add(t1, t2)
  for _, value in ipairs(t2) do
    table.insert(t1, value)
  end
end


---Helper function to merge deprecated items to a temp items table.
---@param destination table
---@param items core.statusview.styledtext
---@param alignment core.statusview.item.alignment
local function merge_deprecated_items(destination, items, alignment)
  local start = true
  local items_start, items_end = {}, {}
  for i, value in ipairs(items) do
    if value ~= "{:dummy:}" then
      if start then
        table.insert(items_start, i, value)
      else
        table.insert(items_end, value)
      end
    else
      start = false
    end
  end

  local position = alignment == StatusView.Item.LEFT and "left" or "right"

  local item_start = StatusView.Item({
    name = "deprecated:"..position.."-start",
    alignment = alignment,
    get_item = items_start
  })

  local item_end = StatusView.Item({
    name = "deprecated:"..position.."-end",
    alignment = alignment,
    get_item = items_end
  })

  table.insert(destination, 1, item_start)
  table.insert(destination, item_end)
end


---Append a space item into the given items list.
---@param self core.statusview
---@param destination core.statusview.item[]
---@param separator string
---@param alignment core.statusview.item.alignment
---@return core.statusview.item
local function add_spacing(self, destination, separator, alignment, x)
  ---@type core.statusview.item
  local space = StatusView.Item({name = "space", alignment = alignment})
  space.cached_item = separator == self.separator and {
    style.text, separator
  } or {
    style.dim, separator
  }
  space.x = x
  space.w = draw_items(self, space.cached_item, 0, 0, text_width)

  table.insert(destination, space)

  return space
end


---Remove starting and ending separators.
---@param self core.statusview
---@param styled_text core.statusview.styledtext
local function remove_spacing(self, styled_text)
  if
    not Object.is(styled_text[1], renderer.font)
    and
    type(styled_text[1]) == "table"
    and
    (
      styled_text[2] == self.separator
      or
      styled_text[2] == self.separator2
    )
  then
    table.remove(styled_text, 1)
    table.remove(styled_text, 1)
  end

  if
    not Object.is(styled_text[#styled_text-1], renderer.font)
    and
    type(styled_text[#styled_text-1]) == "table"
    and
    (
      styled_text[#styled_text] == self.separator
      or
      styled_text[#styled_text] == self.separator2
    )
  then
    table.remove(styled_text, #styled_text)
    table.remove(styled_text, #styled_text)
  end
end


---Set the active items that will be displayed on the left or right side
---of the status bar checking their predicates and performing positioning
---calculations for proper functioning of tooltips and clicks.
function StatusView:update_active_items()
  local x = self:get_content_offset()

  local rx = x + self.size.x
  local lx = x
  local rw, lw = 0, 0

  self.active_items = {}

  ---@type core.statusview.item[]
  local combined_items = {}
  table_add(combined_items, self.items)

  -- load deprecated items for compatibility
  local dleft, dright = self:get_items(true)
  merge_deprecated_items(combined_items, dleft, StatusView.Item.LEFT)
  merge_deprecated_items(combined_items, dright, StatusView.Item.RIGHT)

  local lfirst, rfirst = true, true

  -- calculate left and right width
  for _, item in ipairs(combined_items) do
    item.cached_item = {}
    if item.visible and item:predicate() then
      local styled_text = type(item.get_item) == "function"
        and item.get_item(item) or item.get_item

      if #styled_text > 0 then
        remove_spacing(self, styled_text)
      end

      if #styled_text > 0 or item.on_draw then
        item.active = true
        local hovered = self.hovered_item == item
        if item.alignment == StatusView.Item.LEFT then
          if not lfirst then
            local space = add_spacing(
              self, self.active_items, item.separator, item.alignment, lx
            )
            lw = lw + space.w
            lx = lx + space.w
          else
            lfirst = false
          end
          item.w = item.on_draw and
            item.on_draw(lx, self.position.y, self.size.y, hovered, true)
            or
            draw_items(self, styled_text, 0, 0, text_width)
          item.x = lx
          lw = lw + item.w
          lx = lx + item.w
        else
          if not rfirst then
            local space = add_spacing(
              self, self.active_items, item.separator, item.alignment, rx
            )
            rw = rw + space.w
            rx = rx + space.w
          else
            rfirst = false
          end
          item.w = item.on_draw and
            item.on_draw(rx, self.position.y, self.size.y, hovered, true)
            or
            draw_items(self, styled_text, 0, 0, text_width)
          item.x = rx
          rw = rw + item.w
          rx = rx + item.w
        end
        item.cached_item = styled_text
        table.insert(self.active_items, item)
      else
        item.active = false
      end
    else
      item.active = false
    end
  end

  self.r_left_width, self.r_right_width = lw, rw

  -- try to calc best size for left and right
  if lw + rw + (style.padding.x * 4) > self.size.x then
    if lw + (style.padding.x * 2) < self.size.x / 2 then
      rw = self.size.x - lw  - (style.padding.x * 3)
      if rw > self.r_right_width then
        lw = lw + (rw - self.r_right_width)
        rw = self.r_right_width
      end
    elseif rw + (style.padding.x * 2) < self.size.x / 2 then
      lw = self.size.x - rw  - (style.padding.x * 3)
    else
      lw = self.size.x / 2 - (style.padding.x + style.padding.x / 2)
      rw = self.size.x / 2 - (style.padding.x + style.padding.x / 2)
    end
    -- reposition left and right offsets when window is resized
    if rw >= self.r_right_width then
      self.right_xoffset = 0
    elseif rw > self.right_xoffset + self.r_right_width then
      self.right_xoffset = rw - self.r_right_width
    end
    if lw >= self.r_left_width then
      self.left_xoffset = 0
    elseif lw > self.left_xoffset + self.r_left_width then
      self.left_xoffset = lw - self.r_left_width
    end
  else
    self.left_xoffset = 0
    self.right_xoffset = 0
  end

  self.left_width, self.right_width = lw, rw

  for _, item in ipairs(self.active_items) do
    if item.alignment == StatusView.Item.RIGHT then
      -- re-calculate x position now that we have the total width
      item.x = item.x - rw - (style.padding.x * 2)
    end
  end
end


---Drag the given panel if possible.
---@param panel core.statusview.position
---@param dx number
function StatusView:drag_panel(panel, dx)
  if panel == "left" and self.r_left_width > self.left_width then
    local nonvisible_w = self.r_left_width - self.left_width
    local new_offset = self.left_xoffset + dx
    if new_offset >= 0 - nonvisible_w and new_offset <= 0 then
      self.left_xoffset = new_offset
    elseif dx < 0 then
      self.left_xoffset = 0 - nonvisible_w
    else
      self.left_xoffset = 0
    end
  elseif panel == "right" and self.r_right_width > self.right_width then
    local nonvisible_w = self.r_right_width - self.right_width
    local new_offset = self.right_xoffset + dx
    if new_offset >= 0 - nonvisible_w and new_offset <= 0 then
      self.right_xoffset = new_offset
    elseif dx < 0 then
      self.right_xoffset = 0 - nonvisible_w
    else
      self.right_xoffset = 0
    end
  end
end


---Return the currently hovered panel or empty string if none.
---@param x number
---@param y number
---@return string
function StatusView:get_hovered_panel(x, y)
  if y >= self.position.y and x <= self.left_width + style.padding.x then
    return "left"
  end
  return "right"
end


---@param item core.statusview.item
---@return number x
---@return number w
function StatusView:get_item_visible_area(item)
  local item_ox = item.alignment == StatusView.Item.LEFT and
    self.left_xoffset or self.right_xoffset

  local item_x = item_ox + item.x + style.padding.x
  local item_w = item.w

  if item.alignment == StatusView.Item.LEFT then
    if self.left_width - item_x > 0 and self.left_width - item_x < item.w then
      item_w = (self.left_width + style.padding.x) - item_x
    elseif self.left_width - item_x < 0 then
      item_x = 0
      item_w = 0
    end
  else
    local rx = self.size.x - self.right_width - style.padding.x
    if item_x < rx then
      if item_x + item.w > rx then
        item_x = rx
        item_w = (item_x + item.w) - rx
      else
        item_x = 0
        item_w = 0
      end
    end
  end

  return item_x, item_w
end



function StatusView:on_mouse_pressed(button, x, y, clicks)
  if not self.visible then return end
  core.set_active_view(core.last_active_view)
  if
    system.get_time() < self.message_timeout
    and
    not core.active_view:is(LogView)
  then
    command.perform "core:open-log"
  else
    if y >= self.position.y and button == "left" and clicks == 1 then
      self.position.dx = x
      if
        self.r_left_width > self.left_width
        or
        self.r_right_width > self.right_width
      then
        self.dragged_panel = self:get_hovered_panel(x, y)
        self.cursor = "hand"
      end
    end
  end
  return true
end


function StatusView:on_mouse_moved(x, y, dx, dy)
  if not self.visible then return end
  StatusView.super.on_mouse_moved(self, x, y, dx, dy)

  self.hovered_panel = self:get_hovered_panel(x, y)

  if self.dragged_panel ~= "" then
    self:drag_panel(self.dragged_panel, dx)
    return
  end

  if y < self.position.y or system.get_time() <= self.message_timeout then
    self.cursor = "arrow"
    self.hovered_item = {}
    return
  end

  for _, item in ipairs(self.items) do
    if
      item.visible and item.active
      and
      (item.command or item.on_click or item.tooltip ~= "")
    then
      local item_x, item_w = self:get_item_visible_area(item)

      if x > item_x and (item_x + item_w) > x then
        self.pointer.x = x
        self.pointer.y = y
        if self.hovered_item ~= item then
          self.hovered_item = item
        end
        if item.command or item.on_click then
          self.cursor = "hand"
        end
        return
      end
    end
  end
  self.cursor = "arrow"
  self.hovered_item = {}
end


function StatusView:on_mouse_released(button, x, y)
  if not self.visible then return end
  StatusView.super.on_mouse_released(self, button, x, y)

  if self.dragged_panel ~= "" then
    self.dragged_panel = ""
    self.cursor = "arrow"
    if self.position.dx ~= x then
      return
    end
  end

  if y < self.position.y or not self.hovered_item.active then return end

  local item = self.hovered_item
  local item_x, item_w = self:get_item_visible_area(item)

  if x > item_x and (item_x + item_w) > x then
    if item.command then
      command.perform(item.command)
    elseif item.on_click then
      item.on_click(button, x, y)
    end
  end
end


function StatusView:on_mouse_wheel(y, x)
  if not self.visible or self.hovered_panel == "" then return end
  if x ~= 0 then
    self:drag_panel(self.hovered_panel, x * self.left_width / 10)
  else
    self:drag_panel(self.hovered_panel, y * self.left_width / 10)
  end
end


function StatusView:update()
  if not self.visible and self.size.y <= 0 then
    return
  elseif not self.visible and self.size.y > 0 then
    self:move_towards(self.size, "y", 0, nil, "statusbar")
    return
  end

  local height = style.font:get_height() + style.padding.y * 2;

  if self.size.y + 1 < height then
    self:move_towards(self.size, "y", height, nil, "statusbar")
  else
    self.size.y = height
  end

  if system.get_time() < self.message_timeout then
    self.scroll.to.y = self.size.y
  else
    self.scroll.to.y = 0
  end

  StatusView.super.update(self)

  self:update_active_items()
end


---Retrieve the hover status and proper background color if any.
---@param self core.statusview
---@param item core.statusview.item
---@return boolean is_hovered
---@return renderer.color | nil color
local function get_item_bg_color(self, item)
  local hovered = self.hovered_item == item

  local item_bg = hovered
    and item.background_color_hover or item.background_color

  return hovered, item_bg
end


function StatusView:draw()
  if not self.visible and self.size.y <= 0 then return end

  self:draw_background(style.background2)

  if self.message and system.get_time() <= self.message_timeout then
    self:draw_items(self.message, false, 0, self.size.y)
  else
    if self.tooltip_mode then
      self:draw_items(self.tooltip)
    end
    if #self.active_items > 0 then
      --- draw left pane
      core.push_clip_rect(
        0, self.position.y,
        self.left_width + style.padding.x, self.size.y
      )
      for _, item in ipairs(self.active_items) do
        local item_x = self.left_xoffset + item.x + style.padding.x
        local hovered, item_bg = get_item_bg_color(self, item)
        if item.alignment == StatusView.Item.LEFT and not self.tooltip_mode then
          if type(item_bg) == "table" then
            renderer.draw_rect(
              item_x, self.position.y,
              item.w, self.size.y, item_bg
            )
          end
          if item.on_draw then
            core.push_clip_rect(item_x, self.position.y, item.w, self.size.y)
            item.on_draw(item_x, self.position.y, self.size.y, hovered)
            core.pop_clip_rect()
          else
            self:draw_items(item.cached_item, false, item_x - style.padding.x)
          end
        end
      end
      core.pop_clip_rect()

      --- draw right pane
      core.push_clip_rect(
        self.size.x - (self.right_width + style.padding.x), self.position.y,
        self.right_width + style.padding.x, self.size.y
      )
      for _, item in ipairs(self.active_items) do
        local item_x = self.right_xoffset + item.x + style.padding.x
        local hovered, item_bg = get_item_bg_color(self, item)
        if item.alignment == StatusView.Item.RIGHT then
          if type(item_bg) == "table" then
            renderer.draw_rect(
              item_x, self.position.y,
              item.w, self.size.y, item_bg
            )
          end
          if item.on_draw then
            core.push_clip_rect(item_x, self.position.y, item.w, self.size.y)
            item.on_draw(item_x, self.position.y, self.size.y, hovered)
            core.pop_clip_rect()
          else
            self:draw_items(item.cached_item, false, item_x - style.padding.x)
          end
        end
      end
      core.pop_clip_rect()

      -- draw tooltip
      if self.hovered_item.tooltip ~= "" and self.hovered_item.active then
        self:draw_item_tooltip(self.hovered_item)
      end
    end
  end
end

return StatusView
local strict = {}
strict.defined = {}


-- used to define a global variable
function global(t)
  for k, v in pairs(t) do
    strict.defined[k] = true
    rawset(_G, k, v)
  end
end


function strict.__newindex(t, k, v)
  error("cannot set undefined variable: " .. k, 2)
end


function strict.__index(t, k)
  if not strict.defined[k] then
    error("cannot get undefined variable: " .. k, 2)
  end
end


setmetatable(_G, strict)
local common = require "core.common"
local style = {}

style.padding = { x = common.round(14 * SCALE), y = common.round(7 * SCALE) }
style.divider_size = common.round(1 * SCALE)
style.scrollbar_size = common.round(4 * SCALE)
style.expanded_scrollbar_size = common.round(12 * SCALE)
style.caret_width = common.round(2 * SCALE)
style.tab_width = common.round(170 * SCALE)

-- The function renderer.font.load can accept an option table as a second optional argument.
-- It shoud be like the following:
--
-- {antialiasing= "grayscale", hinting = "full"}
--
-- The possible values for each option are:
-- - for antialiasing: grayscale, subpixel
-- - for hinting: none, slight, full
--
-- The defaults values are antialiasing subpixel and hinting slight for optimal visualization
-- on ordinary LCD monitor with RGB patterns.
--
-- On High DPI monitor or non RGB monitor you may consider using antialiasing grayscale instead.
-- The antialiasing grayscale with full hinting is interesting for crisp font rendering.
style.font = renderer.font.load(DATADIR .. "/fonts/FiraSans-Regular.ttf", 15 * SCALE)
style.big_font = style.font:copy(46 * SCALE)
style.icon_font = renderer.font.load(DATADIR .. "/fonts/icons.ttf", 16 * SCALE, {antialiasing="grayscale", hinting="full"})
style.icon_big_font = style.icon_font:copy(23 * SCALE)
style.code_font = renderer.font.load(DATADIR .. "/fonts/JetBrainsMono-Regular.ttf", 15 * SCALE)

style.syntax = {}

-- This can be used to override fonts per syntax group.
-- The syntax highlighter will take existing values from this table and
-- override style.code_font on a per-token basis, so you can choose to eg.
-- render comments in an italic font if you want to.
style.syntax_fonts = {}
-- style.syntax_fonts["comment"] = renderer.font.load(path_to_font, size_of_font, rendering_options)

style.log = {}

return style
local common = require "core.common"

local syntax = {}
syntax.items = {}

local plain_text_syntax = { name = "Plain Text", patterns = {}, symbols = {} }


function syntax.add(t)
  if type(t.space_handling) ~= "boolean" then t.space_handling = true end

  if t.patterns then
    -- the rule %s+ gives us a performance gain for the tokenizer in lines with
    -- long amounts of consecutive spaces, can be disabled by plugins where it
    -- causes conflicts by declaring the table property: space_handling = false
    if t.space_handling then
      table.insert(t.patterns, { pattern = "%s+", type = "normal" })
    end

    -- this rule gives us additional performance gain by matching every word
    -- that was not matched by the syntax patterns as a single token, preventing
    -- the tokenizer from iterating over each character individually which is a
    -- lot slower since iteration occurs in lua instead of C and adding to that
    -- it will also try to match every pattern to a single char (same as spaces)
    table.insert(t.patterns, { pattern = "%w+%f[%s]", type = "normal" })
  end

  table.insert(syntax.items, t)
end


local function find(string, field)
  local best_match = 0
  local best_syntax
  for i = #syntax.items, 1, -1 do
    local t = syntax.items[i]
    local s, e = common.match_pattern(string, t[field] or {})
    if s and e - s > best_match then
      best_match = e - s
      best_syntax = t
    end
  end
  return best_syntax
end

function syntax.get(filename, header)
  return find(common.basename(filename), "files")
      or (header and find(header, "headers"))
      or plain_text_syntax
end


return syntax
local core = require "core"
local common = require "core.common"
local style = require "core.style"
local View = require "core.view"

local icon_colors = {
  bg = { common.color "#2e2e32ff" },
  color6 = { common.color "#e1e1e6ff" },
  color7 = { common.color "#ffa94dff" },
  color8 = { common.color "#93ddfaff" },
  color9 = { common.color "#f7c95cff" }
};

local restore_command = {
  symbol = "w", action = function() system.set_window_mode("normal") end
}

local maximize_command = {
  symbol = "W", action = function() system.set_window_mode("maximized") end
}

local title_commands = {
  {symbol = "_", action = function() system.set_window_mode("minimized") end},
  maximize_command,
  {symbol = "X", action = function() core.quit() end},
}

---@class core.titleview : core.view
---@field super core.view
local TitleView = View:extend()

local function title_view_height()
  return style.font:get_height() + style.padding.y * 2
end

function TitleView:new()
  TitleView.super.new(self)
  self.visible = true
end

function TitleView:configure_hit_test(borderless)
  if borderless then
    local title_height = title_view_height()
    local icon_w = style.icon_font:get_width("_")
    local icon_spacing = icon_w
    local controls_width = (icon_w + icon_spacing) * #title_commands + icon_spacing
    system.set_window_hit_test(title_height, controls_width, icon_spacing)
    -- core.hit_test_title_height = title_height
  else
    system.set_window_hit_test()
  end
end

function TitleView:on_scale_change()
  self:configure_hit_test(self.visible)
end

function TitleView:update()
  self.size.y = self.visible and title_view_height() or 0
  title_commands[2] = core.window_mode == "maximized" and restore_command or maximize_command
  TitleView.super.update(self)
end


function TitleView:draw_window_title()
  local h = style.font:get_height()
  local ox, oy = self:get_content_offset()
  local color = style.text
  local x, y = ox + style.padding.x, oy + style.padding.y
  common.draw_text(style.icon_font, icon_colors.bg, "5", nil, x, y, 0, h)
  common.draw_text(style.icon_font, icon_colors.color6, "6", nil, x, y, 0, h)
  common.draw_text(style.icon_font, icon_colors.color7, "7", nil, x, y, 0, h)
  common.draw_text(style.icon_font, icon_colors.color8, "8", nil, x, y, 0, h)
  x = common.draw_text(style.icon_font, icon_colors.color9, "9 ", nil, x, y, 0, h)
  local title = core.compose_window_title(core.window_title)
  common.draw_text(style.font, color, title, nil, x, y, 0, h)
end

function TitleView:each_control_item()
  local icon_h, icon_w = style.icon_font:get_height(), style.icon_font:get_width("_")
  local icon_spacing = icon_w
  local ox, oy = self:get_content_offset()
  ox = ox + self.size.x
  local i, n = 0, #title_commands
  local iter = function()
    i = i + 1
    if i <= n then
      local dx = - (icon_w + icon_spacing) * (n - i + 1)
      local dy = style.padding.y
      return title_commands[i], ox + dx, oy + dy, icon_w, icon_h
    end
  end
  return iter
end


function TitleView:draw_window_controls()
  for item, x, y, w, h in self:each_control_item() do
    local color = item == self.hovered_item and style.text or style.dim
    common.draw_text(style.icon_font, color, item.symbol, nil, x, y, 0, h)
  end
end


function TitleView:on_mouse_pressed(button, x, y, clicks)
  local caught = TitleView.super.on_mouse_pressed(self, button, x, y, clicks)
  if caught then return end
  core.set_active_view(core.last_active_view)
  if self.hovered_item then
    self.hovered_item.action()
  end
end


function TitleView:on_mouse_moved(px, py, ...)
  if self.size.y == 0 then return end
  TitleView.super.on_mouse_moved(self, px, py, ...)
  self.hovered_item = nil
  local x_min, x_max, y_min, y_max = self.size.x, 0, self.size.y, 0
  for item, x, y, w, h in self:each_control_item() do
    x_min, x_max = math.min(x, x_min), math.max(x + w, x_max)
    y_min, y_max = y, y + h
    if px > x and py > y and px <= x + w and py <= y + h then
      self.hovered_item = item
      return
    end
  end
end


function TitleView:draw()
  self:draw_background(style.background2)
  self:draw_window_title()
  self:draw_window_controls()
end

return TitleView
local core = require "core"
local syntax = require "core.syntax"

local tokenizer = {}
local bad_patterns = {}

local function push_token(t, type, text)
  type = type or "normal"
  local prev_type = t[#t-1]
  local prev_text = t[#t]
  if prev_type and (prev_type == type or prev_text:ufind("^%s*$")) then
    t[#t-1] = type
    t[#t] = prev_text .. text
  else
    table.insert(t, type)
    table.insert(t, text)
  end
end


local function push_tokens(t, syn, pattern, full_text, find_results)
  if #find_results > 2 then
    -- We do some manipulation with find_results so that it's arranged
    -- like this:
    -- { start, end, i_1, i_2, i_3, , i_last }
    -- Each position spans characters from i_n to ((i_n+1) - 1), to form
    -- consecutive spans of text.
    --
    -- If i_1 is not equal to start, start is automatically inserted at
    -- that index.
    if find_results[3] ~= find_results[1] then
      table.insert(find_results, 3, find_results[1])
    end
    -- Copy the ending index to the end of the table, so that an ending index
    -- always follows a starting index after position 3 in the table.
    table.insert(find_results, find_results[2] + 1)
    -- Then, we just iterate over our modified table.
    for i = 3, #find_results - 1 do
      local start = find_results[i]
      local fin = find_results[i + 1] - 1
      local type = pattern.type[i - 2]
        --  (i - 2) to convert from [3; n] to [1; n]
      local text = full_text:usub(start, fin)
      push_token(t, syn.symbols[text] or type, text)
    end
  else
    local start, fin = find_results[1], find_results[2]
    local text = full_text:usub(start, fin)
    push_token(t, syn.symbols[text] or pattern.type, text)
  end
end

-- State is a string of bytes, where the count of bytes represents the depth
-- of the subsyntax we are currently in. Each individual byte represents the
-- index of the pattern for the current subsyntax in relation to its parent
-- syntax. Using a string of bytes allows us to have as many subsyntaxes as
-- bytes can be stored on a string while keeping some level of performance in
-- comparison to a Lua table. The only limitation is that a syntax would not
-- be able to contain more than 255 patterns.
--
-- Lets say a state contains 2 bytes byte #1 with value `3` and byte #2 with
-- a value of `5`. This would mean that on the parent syntax at index `3` a
-- pattern subsyntax that matched current text was found, then inside that
-- subsyntax another subsyntax pattern at index `5` that matched current text
-- was also found.

-- Calling `push_subsyntax` appends the current subsyntax pattern index to the
-- state and increases the stack depth. Calling `pop_subsyntax` clears the
-- last appended subsyntax and decreases the stack.

local function retrieve_syntax_state(incoming_syntax, state)
  local current_syntax, subsyntax_info, current_pattern_idx, current_level =
    incoming_syntax, nil, state:byte(1) or 0, 1
  if
    current_pattern_idx > 0
    and
    current_syntax.patterns[current_pattern_idx]
  then
    -- If the state is not empty we iterate over each byte, and find which
    -- syntax we're using. Rather than walking the bytes, and calling into
    -- `syntax` each time, we could probably cache this in a single table.
    for i = 1, #state do
      local target = state:byte(i)
      if target ~= 0 then
        if current_syntax.patterns[target].syntax then
          subsyntax_info = current_syntax.patterns[target]
          current_syntax = type(subsyntax_info.syntax) == "table" and
            subsyntax_info.syntax or syntax.get(subsyntax_info.syntax)
          current_pattern_idx = 0
          current_level = i+1
        else
          current_pattern_idx = target
          break
        end
      else
        break
      end
    end
  end
  return current_syntax, subsyntax_info, current_pattern_idx, current_level
end

---Return the list of syntaxes used in the specified state.
---@param base_syntax table @The initial base syntax (the syntax of the file)
---@param state string @The state of the tokenizer to extract from
---@return table @Array of syntaxes starting from the innermost one
function tokenizer.extract_subsyntaxes(base_syntax, state)
  local current_syntax
  local t = {}
  repeat
    current_syntax = retrieve_syntax_state(base_syntax, state)
    table.insert(t, current_syntax)
    state = string.sub(state, 2)
  until #state == 0
  return t
end

local function report_bad_pattern(log_fn, syntax, pattern_idx, msg, ...)
  if not bad_patterns[syntax] then
    bad_patterns[syntax] = { }
  end
  if bad_patterns[syntax][pattern_idx] then return end
  bad_patterns[syntax][pattern_idx] = true
  log_fn("Malformed pattern #%d in %s language plugin. " .. msg,
            pattern_idx, syntax.name or "unnamed", ...)
end

---@param incoming_syntax table
---@param text string
---@param state string
function tokenizer.tokenize(incoming_syntax, text, state)
  local res = {}
  local i = 1

  if #incoming_syntax.patterns == 0 then
    return { "normal", text }
  end

  state = state or string.char(0)
  -- incoming_syntax    : the parent syntax of the file.
  -- state              : a string of bytes representing syntax state (see above)

  -- current_syntax     : the syntax we're currently in.
  -- subsyntax_info     : info about the delimiters of this subsyntax.
  -- current_pattern_idx: the index of the pattern we're on for this syntax.
  -- current_level      : how many subsyntaxes deep we are.
  local current_syntax, subsyntax_info, current_pattern_idx, current_level =
    retrieve_syntax_state(incoming_syntax, state)

  -- Should be used to set the state variable. Don't modify it directly.
  local function set_subsyntax_pattern_idx(pattern_idx)
    current_pattern_idx = pattern_idx
    local state_len = #state
    if current_level > state_len then
      state = state .. string.char(pattern_idx)
    elseif state_len == 1 then
      state = string.char(pattern_idx)
    else
      state = ("%s%s%s"):format(
        state:sub(1,current_level-1),
        string.char(pattern_idx),
        state:sub(current_level+1)
      )
    end
  end


  local function push_subsyntax(entering_syntax, pattern_idx)
    set_subsyntax_pattern_idx(pattern_idx)
    current_level = current_level + 1
    subsyntax_info = entering_syntax
    current_syntax = type(entering_syntax.syntax) == "table" and
      entering_syntax.syntax or syntax.get(entering_syntax.syntax)
    current_pattern_idx = 0
  end

  local function pop_subsyntax()
    current_level = current_level - 1
    state = string.sub(state, 1, current_level)
    set_subsyntax_pattern_idx(0)
    current_syntax, subsyntax_info, current_pattern_idx, current_level =
      retrieve_syntax_state(incoming_syntax, state)
  end

  local function find_text(text, p, offset, at_start, close)
    local target, res = p.pattern or p.regex, { 1, offset - 1 }
    local p_idx = close and 2 or 1
    local code = type(target) == "table" and target[p_idx] or target

    if p.whole_line == nil then p.whole_line = { } end
    if p.whole_line[p_idx] == nil then
      -- Match patterns that start with '^'
      p.whole_line[p_idx] = code:umatch("^%^") and true or false
      if p.whole_line[p_idx] then
        -- Remove '^' from the beginning of the pattern
        if type(target) == "table" then
          target[p_idx] = code:usub(2)
        else
          p.pattern = p.pattern and code:usub(2)
          p.regex = p.regex and code:usub(2)
        end
      end
    end

    if p.regex and type(p.regex) ~= "table" then
      p._regex = p._regex or regex.compile(p.regex)
      code = p._regex
    end

    repeat
      local next = res[2] + 1
      -- If the pattern contained '^', allow matching only the whole line
      if p.whole_line[p_idx] and next > 1 then
        return
      end
      res = p.pattern and { text:ufind((at_start or p.whole_line[p_idx]) and "^" .. code or code, next) }
        or { regex.find(code, text, text:ucharpos(next), (at_start or p.whole_line[p_idx]) and regex.ANCHORED or 0) }
      if p.regex and #res > 0 then -- set correct utf8 len for regex result
        local char_pos_1 = res[1] > next and string.ulen(text:sub(1, res[1])) or next
        local char_pos_2 = string.ulen(text:sub(1, res[2]))
        for i=3,#res do
          res[i] = string.ulen(text:sub(1, res[i] - 1)) + 1
        end
        res[1] = char_pos_1
        res[2] = char_pos_2
      end
      if res[1] and target[3] then
        -- Check to see if the escaped character is there,
        -- and if it is not itself escaped.
        local count = 0
        for i = res[1] - 1, 1, -1 do
          if text:ubyte(i) ~= target[3]:ubyte() then break end
          count = count + 1
        end
        if count % 2 == 0 then
          -- The match is not escaped, so confirm it
          break
        elseif not close then
          -- The *open* match is escaped, so avoid it
          return
        end
      end
    until not res[1] or not close or not target[3]
    return table.unpack(res)
  end

  local text_len = text:ulen()
  while i <= text_len do
    -- continue trying to match the end pattern of a pair if we have a state set
    if current_pattern_idx > 0 then
      local p = current_syntax.patterns[current_pattern_idx]
      local s, e = find_text(text, p, i, false, true)

      local cont = true
      -- If we're in subsyntax mode, always check to see if we end our syntax
      -- first, before the found delimeter, as ending the subsyntax takes
      -- precedence over ending the delimiter in the subsyntax.
      if subsyntax_info then
        local ss, se = find_text(text, subsyntax_info, i, false, true)
        -- If we find that we end the subsyntax before the
        -- delimiter, push the token, and signal we shouldn't
        -- treat the bit after as a token to be normally parsed
        -- (as it's the syntax delimiter).
        if ss and (s == nil or ss < s) then
          push_token(res, p.type, text:usub(i, ss - 1))
          i = ss
          cont = false
        end
      end
      -- If we don't have any concerns about syntax delimiters,
      -- continue on as normal.
      if cont then
        if s then
          push_token(res, p.type, text:usub(i, e))
          set_subsyntax_pattern_idx(0)
          i = e + 1
        else
          push_token(res, p.type, text:usub(i))
          break
        end
      end
    end
    -- General end of syntax check. Applies in the case where
    -- we're ending early in the middle of a delimiter, or
    -- just normally, upon finding a token.
    while subsyntax_info do
      local s, e = find_text(text, subsyntax_info, i, true, true)
      if s then
        push_token(res, subsyntax_info.type, text:usub(i, e))
        -- On finding unescaped delimiter, pop it.
        pop_subsyntax()
        i = e + 1
      else
        break
      end
    end

    -- find matching pattern
    local matched = false
    for n, p in ipairs(current_syntax.patterns) do
      local find_results = { find_text(text, p, i, true, false) }
      if find_results[1] then
        local type_is_table = type(p.type) == "table"
        local n_types = type_is_table and #p.type or 1
        if #find_results == 2 and type_is_table then
          report_bad_pattern(core.warn, current_syntax, n,
            "Token type is a table, but a string was expected.")
          p.type = p.type[1]
        elseif #find_results - 1 > n_types then
          report_bad_pattern(core.error, current_syntax, n,
            "Not enough token types: got %d needed %d.", n_types, #find_results - 1)
        elseif #find_results - 1 < n_types then
          report_bad_pattern(core.warn, current_syntax, n,
            "Too many token types: got %d needed %d.", n_types, #find_results - 1)
        end
        -- matched pattern; make and add tokens
        push_tokens(res, current_syntax, p, text, find_results)
        -- update state if this was a start|end pattern pair
        if type(p.pattern or p.regex) == "table" then
          -- If we have a subsyntax, push that onto the subsyntax stack.
          if p.syntax then
            push_subsyntax(p, n)
          else
            set_subsyntax_pattern_idx(n)
          end
        end
        -- move cursor past this token
        i = find_results[2] + 1
        matched = true
        break
      end
    end

    -- consume character if we didn't match
    if not matched then
      push_token(res, "normal", text:usub(i, i))
      i = i + 1
    end
  end

  return res, state
end


local function iter(t, i)
  i = i + 2
  local type, text = t[i], t[i+1]
  if type then
    return i, type, text
  end
end

function tokenizer.each_token(t)
  return iter, t, -1
end


return tokenizer
--------------------------------------------------------------------------------
-- inject utf8 functions to strings
--------------------------------------------------------------------------------

local utf8 = require "utf8extra"

string.ubyte = utf8.byte
string.uchar = utf8.char
string.ufind = utf8.find
string.ugmatch = utf8.gmatch
string.ugsub = utf8.gsub
string.ulen = utf8.len
string.ulower = utf8.lower
string.umatch = utf8.match
string.ureverse = utf8.reverse
string.usub = utf8.sub
string.uupper = utf8.upper

string.uescape = utf8.escape
string.ucharpos = utf8.charpos
string.unext = utf8.next
string.uinsert = utf8.insert
string.uremove = utf8.remove
string.uwidth = utf8.width
string.uwidthindex = utf8.widthindex
string.utitle = utf8.title
string.ufold = utf8.fold
string.uncasecmp = utf8.ncasecmp

string.uoffset = utf8.offset
string.ucodepoint = utf8.codepoint
string.ucodes = utf8.codes
local core = require "core"
local config = require "core.config"
local common = require "core.common"
local Object = require "core.object"
local Scrollbar = require "core.scrollbar"

---@class core.view.position
---@field x number
---@field y number

---@class core.view.scroll
---@field x number
---@field y number
---@field to core.view.position

---@class core.view.thumbtrack
---@field thumb number
---@field track number

---@class core.view.thumbtrackwidth
---@field thumb number
---@field track number
---@field to core.view.thumbtrack

---@class core.view.scrollbar
---@field x core.view.thumbtrack
---@field y core.view.thumbtrack
---@field w core.view.thumbtrackwidth
---@field h core.view.thumbtrack

---@alias core.view.cursor "'arrow'" | "'ibeam'" | "'sizeh'" | "'sizev'" | "'hand'"

---@alias core.view.mousebutton "'left'" | "'right'"

---@alias core.view.context "'application'" | "'session'"

---Base view.
---@class core.view : core.object
---@field context core.view.context
---@field super core.object
---@field position core.view.position
---@field size core.view.position
---@field scroll core.view.scroll
---@field cursor core.view.cursor
---@field scrollable boolean
---@field v_scrollbar core.scrollbar
---@field h_scrollbar core.scrollbar
---@field current_scale number
local View = Object:extend()

-- context can be "application" or "session". The instance of objects
-- with context "session" will be closed when a project session is
-- terminated. The context "application" is for functional UI elements.
View.context = "application"

function View:new()
  self.position = { x = 0, y = 0 }
  self.size = { x = 0, y = 0 }
  self.scroll = { x = 0, y = 0, to = { x = 0, y = 0 } }
  self.cursor = "arrow"
  self.scrollable = false
  self.v_scrollbar = Scrollbar({direction = "v", alignment = "e"})
  self.h_scrollbar = Scrollbar({direction = "h", alignment = "e"})
  self.current_scale = SCALE
end

function View:move_towards(t, k, dest, rate, name)
  if type(t) ~= "table" then
    return self:move_towards(self, t, k, dest, rate, name)
  end
  local val = t[k]
  local diff = math.abs(val - dest)
  if not config.transitions or diff < 0.5 or config.disabled_transitions[name] then
    t[k] = dest
  else
    rate = rate or 0.5
    if config.fps ~= 60 or config.animation_rate ~= 1 then
      local dt = 60 / config.fps
      rate = 1 - common.clamp(1 - rate, 1e-8, 1 - 1e-8)^(config.animation_rate * dt)
    end
    t[k] = common.lerp(val, dest, rate)
  end
  if diff > 1e-8 then
    core.redraw = true
  end
end


function View:try_close(do_close)
  do_close()
end


---@return string
function View:get_name()
  return "---"
end


---@return number
function View:get_scrollable_size()
  return math.huge
end

---@return number
function View:get_h_scrollable_size()
  return 0
end


---@param x number
---@param y number
---@return boolean
function View:scrollbar_overlaps_point(x, y)
  return not (not (self.v_scrollbar:overlaps(x, y) or self.h_scrollbar:overlaps(x, y)))
end


---@return boolean
function View:scrollbar_dragging()
  return self.v_scrollbar.dragging or self.h_scrollbar.dragging
end


---@return boolean
function View:scrollbar_hovering()
  return self.v_scrollbar.hovering.track or self.h_scrollbar.hovering.track
end


---@param button core.view.mousebutton
---@param x number
---@param y number
---@param clicks integer
---return boolean
function View:on_mouse_pressed(button, x, y, clicks)
  if not self.scrollable then return end
  local result = self.v_scrollbar:on_mouse_pressed(button, x, y, clicks)
  if result then
    if result ~= true then
      self.scroll.to.y = result * self:get_scrollable_size()
    end
    return true
  end
  result = self.h_scrollbar:on_mouse_pressed(button, x, y, clicks)
  if result then
    if result ~= true then
      self.scroll.to.x = result * self:get_h_scrollable_size()
    end
    return true
  end
end


---@param button core.view.mousebutton
---@param x number
---@param y number
function View:on_mouse_released(button, x, y)
  if not self.scrollable then return end
  self.v_scrollbar:on_mouse_released(button, x, y)
  self.h_scrollbar:on_mouse_released(button, x, y)
end


---@param x number
---@param y number
---@param dx number
---@param dy number
function View:on_mouse_moved(x, y, dx, dy)
  if not self.scrollable then return end
  local result
  if self.h_scrollbar.dragging then goto skip_v_scrollbar end
  result = self.v_scrollbar:on_mouse_moved(x, y, dx, dy)
  if result then
    if result ~= true then
      self.scroll.to.y = result * self:get_scrollable_size()
      if not config.animate_drag_scroll then
        self:clamp_scroll_position()
        self.scroll.y = self.scroll.to.y
      end
    end
    -- hide horizontal scrollbar
    self.h_scrollbar:on_mouse_left()
    return true
  end
  ::skip_v_scrollbar::
  result = self.h_scrollbar:on_mouse_moved(x, y, dx, dy)
  if result then
    if result ~= true then
      self.scroll.to.x = result * self:get_h_scrollable_size()
      if not config.animate_drag_scroll then
        self:clamp_scroll_position()
        self.scroll.x = self.scroll.to.x
      end
    end
    return true
  end
end


function View:on_mouse_left()
  if not self.scrollable then return end
  self.v_scrollbar:on_mouse_left()
  self.h_scrollbar:on_mouse_left()
end


---@param filename string
---@param x number
---@param y number
---@return boolean
function View:on_file_dropped(filename, x, y)
  return false
end


---@param text string
function View:on_text_input(text)
  -- no-op
end


function View:on_ime_text_editing(text, start, length)
  -- no-op
end


---@param y number @Vertical scroll delta; positive is "up"
---@param x number @Horizontal scroll delta; positive is "left"
---@return boolean @Capture event
function View:on_mouse_wheel(y, x)
  -- no-op
end

---Can be overriden to listen for scale change events to apply
---any neccesary changes in sizes, padding, etc...
---@param new_scale number
---@param prev_scale number
function View:on_scale_change(new_scale, prev_scale) end

function View:get_content_bounds()
  local x = self.scroll.x
  local y = self.scroll.y
  return x, y, x + self.size.x, y + self.size.y
end


---@return number x
---@return number y
function View:get_content_offset()
  local x = common.round(self.position.x - self.scroll.x)
  local y = common.round(self.position.y - self.scroll.y)
  return x, y
end


function View:clamp_scroll_position()
  local max = self:get_scrollable_size() - self.size.y
  self.scroll.to.y = common.clamp(self.scroll.to.y, 0, max)

  max = self:get_h_scrollable_size() - self.size.x
  self.scroll.to.x = common.clamp(self.scroll.to.x, 0, max)
end


function View:update_scrollbar()
  local v_scrollable = self:get_scrollable_size()
  self.v_scrollbar:set_size(self.position.x, self.position.y, self.size.x, self.size.y, v_scrollable)
  self.v_scrollbar:set_percent(self.scroll.y/v_scrollable)
  self.v_scrollbar:update()

  local h_scrollable = self:get_h_scrollable_size()
  self.h_scrollbar:set_size(self.position.x, self.position.y, self.size.x, self.size.y, h_scrollable)
  self.h_scrollbar:set_percent(self.scroll.x/h_scrollable)
  self.h_scrollbar:update()
end


function View:update()
  if self.current_scale ~= SCALE then
    self:on_scale_change(SCALE, self.current_scale)
    self.current_scale = SCALE
  end

  self:clamp_scroll_position()
  self:move_towards(self.scroll, "x", self.scroll.to.x, 0.3, "scroll")
  self:move_towards(self.scroll, "y", self.scroll.to.y, 0.3, "scroll")
  if not self.scrollable then return end
  self:update_scrollbar()
end


---@param color renderer.color
function View:draw_background(color)
  local x, y = self.position.x, self.position.y
  local w, h = self.size.x, self.size.y
  renderer.draw_rect(x, y, w, h, color)
end


function View:draw_scrollbar()
  self.v_scrollbar:draw()
  self.h_scrollbar:draw()
end


function View:draw()
end


return View
       GDEFB    GPOS5?$  GSUBb:; w  OS/2`A    `cmap?( t  cvt b P  0fpgmvd `  gasp       glyfb   Whead
z@ t   6hhea
    $hmtx[ u  locaZ8 X  maxpk X    name'VD2   postr} h  @wprepa x     {   % 1 @
*& 0+!!!#"&556654&#"#"&5463#"&5463\n7i3-2

5&#;"x4@35:-T!)!$
    7  
 ,@)
J    f `KaL  	  +!'!#3%344`xzkOh   7 "         7~ "         7 "    '   3+3+ 97~ "    #   i}     7 "    ' n  3+3+   78 "    ' \ 3+\3+   7 "    ' \  3+3+   7 "         7 "         7 "    '\  3+3+ 97 "    #   i}     7 "    '  3+3+   7 "    'D 6 3+63+   7 "    ' X  3+3+   7 "         7~ "         7 "    'L \V  \3+3+   7 "    }   97 "    i}     7 "    ' o 3+o3+   7 "         7 "         7 "   Z  3+  7v  # KPX@ J G@ J GYKPX@ _hK _   i L@ `K _ hK _   i LY@#"&&(+$&&'#"&&5466327367&#"3H ./
V6LyHG|O1R	TH#=XVbaPi!H%!&+LouX&!;L&&G}   7^ "        7   a@ JKPX@  f `KaK   _ eL@  f    c `KaLY@
##+327#"&5467'!#3#%348"	#9DDF/4`x(k50F9,0HOh   7 "         7P "    '  3+3+  7    ?@<JHG  f `KaL    +!'#'7##37%3'3'4A->P4]x-,vME"b4$ar   7 "            :@7I  e   e ] `K   ]aL	+%3!'!#!!!#3(Aa8 TLLLL=k   " "   p    ^ " "       d  3    <@9J  e] `K ]   a L'!#+ !#32'32654&#654&##3XK6h<MQReYVEq_`LPVX<P:5<.2FD< d  3 " %      d93 " %   i    d63  $ s@" JK.PX@#  g ] `K _   aK eL@#    g ] `K _   a LY@$#$!*!$+ #"'#32654&##732654&##3XlA<_K6PVE1
<MQRND9`JLee{VX<P;C@:I:5<.  
    # , C@@J  e] `K ]   a L$$$,$+*(#"':!#	+ !##"&&546332'32654&#654&##3.X 6		@LFK6h<MQReYVEq_`LPf2! 27CVX<P:5<.2FD<    ?   ' L@IJ  e	e
] `K		 ]   a L'&%$#"!'!#+ !#5#5332'32654&#654&##3#3X\\K6h<MQReYVEq_`LPFVX<P:5<.2FD<VF\ d  %     7  4@1  J   _hK _ iL    %$$+ &#"3267#"&&54663U,4?FVihV,B%/ dATILP $=3<!,SqqR 7 " ,      7 " ,      7 " ,       7 . ?@<!-". J  g    c _ hL$$($(+$#"&'732654&#7.546632&#"3267 S50-F60!*/MuALP>U,4?FVihV,B%/$)./"044XWkqR $=3< 7 " ,      7 " ,       ~  @	 J  `L+##33Alflf8Fw~?  7@ % G@D  "	J   g _ hK _ iL   % $&%$$$+ &&#"&#"3267#"&&5466326632$@,HEVihV,@&0eATILP7,OG@&;J34*=!,SqqRGN  7  ' >@;! JH G _ hK  _   i L&+*"+%#"''7&&5466327&'3267$&#" dA($-OYLP  -',4,B%ZViA!,	CH$~qR68$=	%@
  d  M   ,@)]`K  ]   a L		  		
  $+ ##332654&&#1M`x>`ALvmu' d  H " 6   <k   d  H " 6   #<k   ?     Y  :      Y   <@9e ]`K	 ]   a L    $
+ ###533654&&##3#3\\|x>`AFM>F-vmu'F d  M " 6      dM " 6   s     Y  :   d  M " 6      d9M " 6   i    
     5@2J]`K ]   a L    !$+ ###"&&54633654&&##3 6		@LF|x>`AFMf2! 27Cvmu' dSM " 6   v         /@,  e ] `K ]   a L"$ +!#"&546335!5!#"3v{[r_\ORQMfnjpNDLN: d   " 6   z   d   " 6   #z   R    d    /@,  e   ]`K ] aL    +!3#!!LLL d   " E      d  ~ " E      d   " E       d   @
 JKPX@- p  e    c ] `K ]
	aL@. ~  e    c ] `K ]
	aLY@      $&+!#"&'732654&#7#!!3#!A0-F60!*/u8/"044cLLL d   " E      d  + " E   '_  3+3+ d9 " E   #   i      " E   '  3+3+ d  ) " E   'G 6 3+63+ d   " E   ' [  3+3+ Z   " E      d  ~ " E      d   " E      d9 " E   i   d   " E      d   " E      d   " E  Z  3+ d  ^ " E       d  u	 JKPX@)  e ] `K	 ]  aK _ eL@&  e  c ] `K	 ]  a LY@    #$
+%#327#"&5467#!!3#(G48"	#9D23uLL50F9,)@LL  - ' ?@<  J  g   _hK _ iL   ' &$$!$#+ &#"33#"327#"&&5467&&54663[4HT<;G<B4KMNG_@8*qAGp?ZD?H1_CU9@;/5=NA==FC6./5_>LXO?2P.  6    )@&  e  ]   `K ] aL+!!5!5#535!<wOLL (       d    N@K
	H Ge	]`K
 ]  a L    +%#'7#!73#3#3737#-U-9B<[o?:]<
?ILLF;=2LL d   " E       
  >@;
	J e ] `K  _   i L    $%%+ #"&'732654&##57!5!3`w;oKHi'7 K3HMLQXh_=`5,.6#G?D<CNM 
 " ^       -  7@4J  e ] `K  _   i L#""+%#"&&54633'5!!#"3267'kMFm;{qXKC8L!N.,4\;]qMNC:E#  d   	 )@&  e  ]   `KaL   	 	+3!!3#dnLK d   " a      +  9@6
J    e] `K _ eL    $#+3##"'7325!PGA2%=neKLP&<JL  79  A@>  J  e   _hK _ iL    "%%+ &&#"3275#'3#"&54663_/8%D.5Y8_]L7zkvQQ%':9}`M=pS 79 " d       +$   #@ J`K  _   e L%%+%#"&546733'325O#=;;="f`    EAK(1550"NEl*
LL#$$ 79~ " d      79 " d   '   79 " d   &   79 " d      79 " d       7@ * T@Q  &	J   g  e _ hK _ iL   * )%#%%$	+ &&#"&&#"3275#'3#"&54663254632$@1'L+5Y8_]M6z2qEQJM2OH@&;J;49}` MoSKQ  
    "@
  J   _ hK aL%&+76654&#"'6632#H>>B<,L&41g>Ce6aR_?CA?I  9+*5_=_]  7| % J@G J  e	  e _ hK _ iL%$%%%"
+%##"&546632&&#"3275#535#'33|Ch{ROC_/8%D.5Y8_]J9zzzCx=pS%':9}`JN:M  
  4@1 J G    c _hL    + '6654##732654&#"'63HlH?EY	B6<G:;RN2`zfPBPQKj$P#lLvN?82=@9U  d  D  '@$    e`KaL    +!!#3!3__"_C O  #     @@=	
  e e`KaL    +##!##5353!535!E__EE_"__AECEppppkk d  D " p      d  D " p      d9D " p   i    
    4@1J   e ]`K  a L    *!+#!##"&&54633!__ 6		@LFz"OCf2! 27C  (        d  [KPX@  e`K cK  _  i L@#  e`K cK aK  _   i LY@#$+ #"&&55!#3!332654'3Ci<2S1__"_/,6Q]Zx9)O7 76^k  d     @`K   a L    +#_O dw " x    '      " x   )    *~ " x   H    9 " x   W    8 " x   V      " x       5~ " x   S    5 " x     R    " x       R9  " x   i       " x      <   " x   $    * " x  ZH  3+ 
  ^ " x   9      9 JKPX@ `K   _ eL@    c `LY##+327#"&5473|48"	#9Dl_50F9,T2O  Zd  @J `K  `   i L"!+%#"&533267d2AGP_=&PL!J    *  '@$  e `K aL    +###533*^_^^_JBJ%  : " x   X    w  
 @ G   ` L+7'>53Y[.._`ffE*<0MwH "    f   +U   6@3J  g `K _   e L'$%+&&'#"&54632367&#"3?8WIBHTN#_88#-*>bJI;28=Fd-5.  w/  @ G  a `L+#'>55#5333/]Y[..___]0ffE*<0N3  d  M  	 +@( J`K  a L  		  +#!#_uOpA d  M "       dM "        d  i   fKPX@ J@JYKPX@  _  hKaL@`K  _   hKaLY@%#+76632&&#"##"A1 /"$u_p1*=	
$O  d    @`K   ^ aL    +!!S dw "           "    *        '@$ e `K   ^ aL+7!!#5333#[[_aaSSDNN  
     H@EJ  gg `K	 ^   a L    $!
+%!#&&546325367'5&#"3FH@/_C74Q_
CSS<618=Y1 d   "        d "    s   d "    v   d   "   M 	3+ d9 "    iz   d, "    #   M        &@#
 J `K   ^ aL+7!!'7378&^_&SS#<:]c<{  >    (@%J   ~`K  a L+!#&'##33\YZ97b} >   "       >   "        ZA $ W#	JKPX@`K `  a L@`K   aK`iLY@   $ $##$#	+#'#"&'#"&533267&533267AR!O16L'T3OY_/++=$_/++=#OO.-4/30oZ<A*3
<A*3  d  G  @
 J`K  a L+!##3&&53GY|
YIEuS6x dw} "        d  G "       d  G "       d  G "    %   dG "    s   dG "       d  G "       d9G "    i   d  G "        d+G  8@5 J`KaK  _   e L    $#+#"'73255##3&&5GPGA2%= Y|
LP&<J?IEuS6x +G  6@3  J`K   aK _ eL    $'+##"'73253&&5GPDA2$@|
OIEuSKO&;J6x d,w "    #   M    d6C  yJKPX@ _`K aK   e LK.PX@ `K _hK aK   e L@    `K _hK aLYY@    #+ #4&#"#3663]_597M/_R,b>kW;DC-0S.1 d  G "    &    7}   ,@)_hK  _   i L    &+ #"&&5466332#IIWWIIVZdeYSrpTRqoUN  7U  * 2@/J  g`K _   i L*))"%+ #"&&5467&&553326553654&#"3EA{SS{AF@-,_E?`0-2TTVUUVTo^@:e><e;=^Q4J82PGHAEFAFH 7} "       7} "       7}~ "       7} "       7} ,   7} "       7} "    '  3+3+ 79} "    #   i   7} "    ' "  3+3+ 7} "    ' 6 3+63+ 7} "    '   3+3+ 7} "       7}~ "       7} "    'L \V  \3+3+ 7} "       7} "    ' o 3+o3+ 79} "    i   7} "       7} "        7  # 4@1JH _ hK _   i L#",&&+ #"&&546632654&'7#"3Y?IWWIIVqH7HZdeY\]pTRqoUB,!1  7   ' 7@4JH _ hK _   i L'&,&*+'7#"&&546632654&'7#"3Y?IWWIIVqH7HZdeYBO1k]pTRqoUB,!1  79  # / r@JHK#PX@! _ hK _   iK_ eL@ c _ hK _   i LY@$$$/$.*(#",&&+ #"&&546632654&'7#"3#"&5463Y?IWWIIVqH7HZdeY$$$$\]pTRqoUB,!1#$$#  7   ' 7@4JH _ hK _   i L'&,&*+'7 #"&&546632654&'7#"3'Y?IWWIIVqH7HZdeY$1OM]pTRqoUB,!1  7  , 6 Z@W *	)$J ~   g _ hK_ iL--  -6-51/#!  #	+ '632#56654&# #"&&546632654&'7#"36)539QE' EY?IWWIIVqH7HZdeY32+G0T]pTRqoUB,!1  7  4 > [@X 21,J   g  g _ hK	_ iL55  5>5=97+)#!  %%%
+ '66323267#"&'&&##"&&546632654&'7#"387#88"wY?IWWIIVqH7HZdeY>(0*,
]pTRqoUB,!1 7} "    9    76:  ( K&PX@

J@

JYK&PX@_hK_ iK   e LK.PX@) _hK _hK_ iK   e L@)    _hK _hK_ iLYY@  ('#!  &("	+ #4#"#"&&546632663#"3S_K,%(IWWIIV^F'G+ZdeYRNS.RpTRqoU2 7} "   Z  3+ 7}^ "        7} "    'V  \ w \3+w3+  7}    ! <@9H    e_hK _ iL! '+'!5!#"&&5466332#1IIWWIIVZdeYk1OESrpTRqoUN  <
 ' .@+J ~`K `  i L"&##+ #"'#"&54673326553326654&'3,w H>bk,!\&$3+.1]e'4%%\gu:;MWxXg-5>t'g]wZ  7}  ( \
 JKPX@  ~ _ hK   ` eL@  ~    d _ hLY@('&+#'+$327#"&547.546632#"3}l^G48"	#9DRNu@IVWIeZdeY50F9,I0VjoUSr  7}^  " , yJKPX@'~   e _ hK ` eL@$~   e  d _ hLY@##  #,#+'%  	+!5 327#"&547.546632#"3l^G48"	#9DRNu@IVWIeZdeY^EEq50F9,I0VjoUSr    4@1	 J _hK  _   i L    $$%+ #"'732654&#"'663kITrS1%@,Vh^MTI0.e@rSM;2<""  7}3   ' H@E%$ JH
	 G_ hK _   i L   ' &*%+ #"''7&&5466327&#4&'3.OIW$#O(GOIV%%O*dR**twpTz(voU},=	cz 7} "     3+ 7} "       7} "    'U f  f3+3+ 7} "    'U f  v f3+v3+  7K  & KPX@!  e	_hK _  a LKPX@5  e	_ hK	] `K ]   aK_ iL@1  e 		_ hK ] `K  ]   aK _ iLYY@$""&!
+!!#"&&546632!!3#!$32654&#"KK"'P~HH~P(%&.1+DQbRT`_USaRqoUL&sHLJy)}  d  % 
  0@-   e ]`K aL   
 	$+ ###3654&##3yW_PWWQUSkjqn@SJB d  % "       d  % "        
  x    9@6J   e]`K aL     !$+ ####"&&54633654&##3yW_ 6		@LFPWWQUSkjqnf2! 27C@SJB  d  %   4@1 e   e `K aL    $+ ###33654&##3yW__VQVWQUS;lmtovBUMC  7   5@2 G  ~ _ hK  _   i L    &%+$&&#"&&546632$32#"Z*><l\VIIVWIPNeYZd'!P5(QqoUSry)  7+  & KPX@J@JYKPX@! _hK_ iK  _   e L@% `K _ hK_ iK  _   e LY@&%'"&$!+#"&55#"&&546632733267$67&#"32AGP?WLyHG|OV?T=C9MVbaP&PLg:LouX:.J7}  d  D   2@/ J   e ] `KaL!+##32#2654&##.k_JKqKLMUU$baHZm=D@9 d  D "       d  D "       dD "       c  D "       d9D "    i   d  D "   Z  3+    O   <@9 J	  e ] `KaL    !
+!###5332654&##3k_[[JKLMUU`$$IDbaHZm=D@9  d+D    C@@  J  e] `K aK   _ eL ##$ +3267#"&532##32654&#=%2AGPJKqk`KLMU<&PLbaHZ$=D@9   ) .@+ J   _hK _ iL   ) ($-%+ &&#"#"'732654&&'&&54663Sb.4'K+6FA>AV5;oL[4*V5@T?<jb7c?'):20)".Q><\4Y:"#?<"-$ ZM4R.  "        "         <[   @ ]   `L    +3Ji[V  "         < w@.- JKPX@# p    c _ hK _ iL@$ ~    c _ hK _ iLY@
%,$$(+$#"&'732654&#7&'732654&&'&&546632&&#"nb0-F60!*/R4*V5@T?<jb7c?Eb.4'K+6FA>AV5lm	./"044XQ:"#?<"-$ ZM4R.'):20)".Q>  "        "    e    "    r   9 "    ii    dd   KPX@ J@JYKPX@ ~ _hK  _  i L@# ~ _hK aK  _   i LY@     ##(+ #"'732654&#57&#"#463lp{hJ+$-ADjhQPz_pgG>
dT`nE@?E?K"eo -R R        !@  ]`K aL    +###5
_Q`Q    )@&e  ] `K aL+#3###535#5!}}_{{^F?FQ    "          ;@8 J ~    c] `K aL$$+#"'732654&#7##5!#b0I77 */%
<0!044c`QQh  "    s    "    ]       2@/ JHG  ]`K aL+##5'#5!737#e[]O,{j,O))`=XQC2h    "    a   9 "    ia    
  !  "@ J  ] `K aL*!+###"&5463!_`

G&NG``$:18D S "    v    g     $   7@4J e `K ^   a L    $+ ##'6733654&##3|E.!U[PRQP\_kjtk*1J?RLA  (  % .@+"! J _hK   _ iL   % $,#*+ 327#"&&5467>54&#"'663wuciU@P<bS4\Gk:jb=@?6.M'40hB_NNZ!A39>D9Y3Z8X]$,!1.9((  +  +@(  J] `K   _ eL$ +3267#"&5#5!#2=%2AGP
<&PLQQa  Z<  @`K  _   i L##+%#"&5332653<9mLs}_HIJH`Ei;j3PPOQ Z< "       #   .@+ 	 e`K 		_ iL$
+##"&5#5353!533!3265E9mLs}EE_#`EHIJHEi;jEppppEPPOQ Z<~ "       Z< "      Z< "      Z< "      Z<~ "      Z< "       Z< "       Z< "       Z< "   'L \V  \3+3+ Z9< "   i   Z< "      Z< "       Z  /@, JH   ~`K _ iL#$+ #"&5332653654&'7?=9mLs}_HIJH`/H137Ei;j3PPOQ5	)  Z  " 2@/ J"!H   ~`K _ iL#$+'7#"&5332653654&'7?=9mLs}_HIJH`/HBO1k137Ei;j3PPOQ5	)  Z9  * o@ JHK#PX@$   ~`K _ iK_ eL@!   ~ c`K _ iLY@*),#$+ #"&5332653654&'7 #"&5463?=9mLs}_HIJH`/H$$$$137Ei;j3PPOQ5	)#$$#  Z  " 2@/ J"!H   ~`K _ iL#$+'7#"&5332653654&'7'?=9mLs}_HIJH`/H$1OM137Ei;j3PPOQ5	)  Z  1 W@T 1	0+J ~ ~   g`K _ iL  *)&$!   #	+ '632#56654&##"&5332653654&'7')539QE' u?=9mLs}_HIJH`/H32+G0T137Ei;j3PPOQ5	)  Z  9 X@U 983J ~  	 g  g`K _ iL  21.,)(%#  %%%
+ '66323267#"&'&&##"&5332653654&'787#88"?=9mLs}_HIJH`/H>(0*,
Z137Ei;j3PPOQ5	) Z< "   *   Z< "  Z   3+ Z<^ "       Z<   X JKPX@`K _ iK   _ eL@    c`K _ iLY@      ##(+327#"&547&&533265<PJG48"	#9D_jr_HIJH,Ru50F9,M+~e3PPOQ  7} ! /@,
 I  ]`K _iL   !  &+&&5467#5332654&'53##GD=k@;dZYe><k;EJUOdm5NN3n|}~|j5NN,raR Z< "      Z< "      Z< "   'U f  f3+3+    &  !@ J`K   a L    +#3&ffOJ  Z<  Y@
JKPX@ _`K  _   i L@ `K _hK  _   i LY@    %#&+ #"&&5332654&#"'63=@vNDd6_B=PT!+?@_M:e@'GMzv	B   7       !  '@$ J`K  a L    +##33!zw]oesOA^^   ! "(   3     ! "(   `     !~ "(   ]     ! "(   )        fKPX@
 J@
 JYKPX@ ]`K  a L@`K _ hK  a LY@	$#+33366327&&#"##wze$18DSeo]A1&6=C^^  d  %   Q@ JKPX@ _`K   a L@ `K _hK   a LY@    + #36354&#"7X5FsRW__C]]:5S;S-V<GgE "4@79<"      @	 J`K  a L+##33Elflft1oB    !  #@  J`K   a L    +#3!`iXU   ! "0        ! "0        !~ "0      9! "0   iq     ! "0           I@
  JKPX@  _  `K aL@   `K _ hK aLY$$+376632&#"#inC52$" `=56'   ! "0        !^ "0       dD   :@7 J   e   e `K aL!+%##332#2654&##.k__VJKqKLMUUzbaHZm=D@9    !   .@+J  f`K aL	+3###53'33737#-Q`K',i**c\\EEUUU   ! "0          	 /@, J ]`K   ] aL   	 	+!!5!5ULXMQLP    "<         "<          "<         "<   n   9 "<   i`    +  =@:  	J ] `K   ] aK _ eL$#+!#"'73255!5!5!OPGA2$ >XdLP&=J?LP      =@:
J  e ]`K ] aL    	+3#!!57#537!5iYLYMJQLJP _   |    9  A@>  J  e   _kK _ iL    "$%+ &&#"3275#'3#"&54663iS)3 ;&@VFC9/`
[ho{CqC  :cbkaG5R|C  9 ( @  $	JKPX@(  e   _bK _ kK _ iL@&   g  e _ kK _ iLY@   ( '%"$%$	+ &&#"&&#"3275#'3#"&5466325463a2$@.!='BUFC9/`
[ho{CqC0)PG&;J4bckaG5R|CJLP _         4  #@   ] cK] aL+#3!53#5!4``__HHH  _    @cK   ^ aL    +3!?N  _    @	 JcK  a L+!##3&53vUvUhzKDR  9  $ KPX@!  e	_kK _  a LKPX@5  e	_ kK	] cK ]   aK_ iL@1  e 		_ kK ] cK  ]   aK _ iLYY@#!"%!
+!!#"&546632!#3#!$32654&#"'#o|8jJ"X
$	CFC=LK>R}EGP/Gg:[dedee  _     3@0 J    e ] cKaL    !!+!'###3232654&##=\kq:5C66>?2RO4N,2/+  _     1@.J  gcK ^   a L%!$+ ##33373654##38qk\=h/=lC2&J6RT-2Y       #@  JcK   a L    +#53\bJ  -  % F@C J G  g _ kK _   i L%$&##$'+$&&'#"&5463354&#"'63275#"3)25hNZyoQ68:TbT]\-E.-[@$&OXGTZ'80C$[TBRyl/0 -! "O   O   - "O   S   - "O   '`  k `3+k3+ -9 "O   #S   ic   - "O   '`Tk `3+k3+ - "O   '`W k `3+k3+ -q "O   '`Bk `3+k3+ - "O   R   - "O   Q   -| "O   'V? Y V3+Y3+ -9 "O   #Q   ic  | "O   'VY V3+Y3+ - "O   'VW& i V3+i3+ -q "O   'L<k L3+k3+ -@ "O   Y   -  "O   L   -\ "O   'LV | 3+|3+ - "O   Mc   -9 "O   ic   -E "O   'MbV e 3+e3+ -! "O   N   -N "O   W   - "O   Z    9   # KPX@ J G@ J GYKPX@ _kK _   i L@ cK _ kK _   i LY@#"'%(+$&&'#"&5466327367&&#"3-.
Q-_m3aA0DO<;%=C=:f!E('+|Q~G&"<|N''"#fefd  7  # KPX@ 	 JH@ 	JHYKPX@ _kK _  i L@ _kK aK _   i LY@  #"  %+ #"&'#4&'7663654&#"3m3aA0DO-.
Q-&C=:+<;%|Q~G&"<%!E('+"fefd''"# - "O   V    - + 4 P@M! -* J  g    c _ kK_ iL,,,4,3*##$(##	+327#"&5467&'#"&5463354&#"'632&75#"348"	#9DGI5hNZyoQ68:TbT]\-E.-+50F9,1I*OXGTZ'80C$[T @ERyl/0 -D "O   T    -    8 A @21:"		J HGKPX@0  g  	g  _   jK _ kK
		_ iL@.    g  g  	g _ kK
		_ iLY@999A9@&##$*$$$%+'7632#"&56&#"3265&&'#"&5463354&#"'63275#"3}@22@@22@)25hNZyoQ68:TbT]\-E.-qO1k==--==-@$&OXGTZ'80C$[TBRyl/0  -S ! & - 2 V@S#0/( JH
	 G e _ kK `   i L'''-',#"+$&&'#'7&&54677&#"'6327'3575##3&7)25h+:Aof&:TbT+[\6--E7[-4a[@$&O:3S<QYC$<=&ys'RyY - "O   U    2  % M@J JH  e_ kK _   i L  %$!  $+#+$7#"&554&'7632##33254&#bTaU]\)25hNZyoQ68A-E.-?C$[T @$&OXGTZ'80Ryl/0  - ( / ; K&PX@#2 	J@#2 	JYK&PX@*  
 
g 	  	 e_kK_iL@4  
 
g 	  	 e_kK _iK_iLY@000;0:74/.%"##$$$"+ !3267#"&'#"&5463354&#"'632632'4&#"367&55#"3L<&@#(Td?a$Z>O\|oQ68:TbTr+9ffo[>>q
UCE.- WR7B2/4-XGTZ'80C$TTzNR,00<l/0 -! "p   OA   - "p   VQ    _   KPX@ JH@JHYKPX@ _kK _  i L@ _kK aK _   i LY@    %+ #"'#763654&#"3j2^?S9	Q\9\E@;F5="R}EF:N"chk_R!& _ "s   2 23+ _9 "s   i   _*-     _  & KPX@#" J@#"JYKPX@" _ bK _kK _  i LKPX@& _ bK _kK aK _   i L@$  g _kK aK _   i LYY@  &%!  $#%	+ #"'#4632&#"63654&#"3j2^?S9	QWN$9!-/*$9\E@;F5="R}EF:WDSC%'N"chk_R!&    6%   KPX@#p  e  ]   cK	aLKPX@$~  e  ]   cK	aL@"~    e  e	aLYY@  
	  
+5!#5#5!#5#???ZZpZZ  7   ' =@: g_hK  _   i L  '&"   &	+ #"&&5466332654&##"&5463WWccWXcsrtu$$$$TonUTomWJ$##$    "    p 	p3+    # KPX@  JH@ JHYKPX@$]`K _	kK
 _  i LK&PX@(]`K _	kK aK
 _   i L@&e _	kK aK
 _   i LYY@  #"  %+ #"'##53573#63654&#"3j2^?S9	QOO\9\E@;F5="R}EF:^F?JFN"chk_R!&  _   KPX@ J@JYKPX@" ] bK _kK _  i LKPX@& ] bK _kK aK _   i L@$  e _kK aK _   i LYY@    %	+ #"'#!#63654&#"3j2^?S9	Q<9\E@;F5="R}EF:FN"chk_R!&  9  4@1  J   _kK _ iL    $$%+ &&#"3267#"&54663NN$,5 @GFA4 *HYk{8gG:fdd_<:T~F 9! "}   O   9	 "}       9 "}   R    9 - ?@<, - J  g    c _ kL$%'$'+#"&'732654&#7&&546632&&#"3267M0-F60!*/Yd8gG/N$,5 @GFA4 *-/"044ZrT~F:fdd_< 9 "}   Q    9 ! , O@L*
 J	 G g _ kK _   i L""  ","+(& !  %*$+$#"''7&&546632&&#"5663654&#"3AbN' !;!048gG/N$-4!@G)A7,%:2@J
IK!xQT~F<fdj1C<&7 9 "}   M    9n % t@  !	JKPX@    _bK _ kK _ iL@   g _ kK _ iLY@   % $%$$%$+ &&#"&&#"3267#"&5466325463<2$@&6&@GFA4 *HYk{8gG'PG&;Jx2fdd_<:T~FCLP  J-  4@1  J   _kK _ eL    $$%+ &&#"3267#"&5463dI$*3DGFD3+HTp{|s:=:  9S  & F@C 
 JH	 G _ kK _   i L  $!  *$+$67#"''7&&5466327&'3&&#"B4 *HY#+<B8gG+,",h2e@GB<:AE\T~F;9:M/nfd  >   `@J HKPX@ _ kK _  a L@ _ kK   aK_ iLY@(%#+#'#"&54663267&&#"3Q	N0^i2^?Q=X<;%=C>:I(-}Q~GAO''"#fefd  9  + ;@8#J
H  g _   i L+*'%&%+ #"&&546632&&''7&'77654'&&#"3L:hD>e:-[A[892H?J4=U@F6?KE.yD:TS}E:pM>nDC?a'F KFJ/Ajc&''V\  >(   , 8 }@54$#	JHKPX@_	kK
 _  i L@!_	kK aK
 _  i LY@--!!  -8-720!,!+'%   &#&+ #"'#'#"&&5466327663 675&#"3 654#"3S.1Z:P1
F	J*:V-0Y:'D\C.93A4>;3v@m'5.(A|VR}ESGI(-D{RPG'%''"''Mgdeeef*$.( > "   2 23+ > "   s    >F  % @JHKPX@$  ]	`K _ kK
_aLK&PX@(  ]	`K _ kK aK
_ iL@&	  e _ kK aK
_ iLYY@  %$   %#+##'#"&5466325#53567&&#"3FOQ	N0^i2^?Q=\<;%=C>:FI(-}Q~GAFJ?''"#fefd  > ! / 9 K.PX@ &7$
 JH	 G@ &7$
 JH	 GYK.PX@" g _ kK
	 _  i L@, g _ kK
 _  iK	 _  i LY@00""  090853"/".*( !  %($+$#"''7&'#"&54663276636755&&#"3$654#"3<^M" ;"!S4^i2^?Q=\B2<;%=C>:`,$#9.=HGI&.4}Q~GA<:'(
"#fefd$&4 > "   2 23+ >9 "   i    9(
 " / +@(&"
	 J _ kK  _   e L/,%%+$#"&'732654&&'&&546632&6654&#"+)P77T'/7"/-23d^8iHEi:PGD=67BCAE$A-&A'9' +q_EuE<rNNo#E4"_FW[]X  >+ - : KPX@!&	+	10

	J('H@!&	+	10

	J('HYKPX@6 
e 		_kK _kK

_aK  _   e L@8 
e 		_ kK ] cK aK

_ iK  _   e LY@..  .:.953 - ,%#$%%+$#"&'732654&##57!#'#"&546632!367&&#"3!y<lHEf(6#I/FIHTOQ	N0^i2^?Q=\<;%=C>:ebAd7--2"KHF;C=I(-}Q~GAF''"#fefd  >  ' @  
JKPX@"   _bK _ kK_aLKPX@&   _bK _ kK aK_ iL@$   g _ kK aK_ iLYY@  '&"   %#$	+ &&#"#'#"&546632546367&&#"3s2$@Q	N0^i2^?Q=PG<;%=C>:&;JI(-}Q~GAxLPO''"#fefd >S "   v    >+  ' F@CJH _ kK_ iK  _   e L'&(%%%!+#"&55#"&5466323267$67&&#"32AFQM/^i2^?Q=\@<;%=C>:&PL'+}Q~GAJ
''"#fefd  >   @JKPX@! ] bK _ kK _  a LKPX@% ] bK _ kK   aK_ iL@#  e _ kK   aK_ iLYY@&%#+!#'#"&5466325#5!67&&#"3Q	N0^i2^?Q=6<;%=C>:I(-}Q~GAFZ''"#fefd > "   V    >u  " % KPX@$JH@$JHYKPX@0 _kK
_kK _  aK	 _  a L@, _ kK
] cK ]   aK	_ iLY@##  #%#%"!  %#+%!'#"&546632!67&&#"3u<	N0^i2^?Q=\{<;%=C>:MMI(-}Q~GAF''"#fefd| > "   #V   R    > ! . 1 9yKPX@
%
$0	JH@
%
$0	JHYK
PX@>  o  g _kK

_kK _  aK		_ iLKPX@@    g _kK

_kK _  aK		 _  a LKPX@=   g _kK

_kK _  aK		_ iL@;   g _ kK

] cK _  aK		_ iLYYY@ 22//""292975/1/1"."-("%#+$#47!'#"&546632!3663267&&#"3654#"D	N0^i2^?Q=\zgG5-:<;%=C>:7)  )QG3I(-}Q~GAFFC3,:''"#fefd{!!+  9   3@0 	J    e _ kK _ iL%%$"+ !3267#"&546632'4&#"3L<&@#(Tdn{5cCip[>>q
 WR7B~RHzNR 9! "   O   9 "   S   9 "   R    9 ) 0 D@A 	J    e  g  c _ kL%'$+"+ !3267#"&'732654&#7&&546632'4&#"3L<&@#(GV0-F60!*/^h5cCip[>>q
 WR79-/"044YsRHzNR 9 "   Q   9| "   'VQ Y V3+Y3+ 99 "   #Q   i   | "   'VY V3+Y3+ 9 "   'VW8 i V3+i3+ 9q "   'LNk L3+k3+ 9@ "   Y   9  "   L   9 "   Mu   99 "   i   9! "   N   9N "   W   9 "   Z   9 "   V    9 $ + t@ 	JK&PX@'    e _ kK _ iK _ eL@$    e  c _ kK _ iLY@%%#)"+ !3267327#"&547&&546632'4&#"3L<&@#(,1B18"	#9DSdp5cCip[>>q
 WR7#40F9,H*xRHzNR  9 & E@B  !J  g   _kK _ iL   & %%$!$%+ &&#"33#"3267#"&547&5463=R#,7#0380=8>5;6(D!+%b6^qoeT7)&#*H)/(1: TKu\BN  9   % >@;J  g  _   kK_iL  %$!  *+&5467&&54632#6654#"33#"3xDB73lQKk8yxMB,3B1'B6[L8<7*BOE}RJah'#*(HS1-      9   % >@;J  g  _   kK_iL  %$!  %+&546632#6654##732654&#"3y8kKQl37BDx^3B'1B3,BJR}EOB*7<8L[J-1SH(*#'ha   8 KPX@0*8)J@0*8)JYKPX@&    h  g _kK _ iL@*    h  g cK _ kK _ iLY@"%$!#$.!	+#"&55#"'73254&##732654&#"'66327332672DCJ937BDbwT0#G.IAF68D:/)? ,(\:/SVW@_&F>	,8<8RUB9^.%H(*'#7-FF  4   @@= J e _kK  _   i L    $$+ #"'73267!&54633&&#"zn|mdT(#C-;Drh8>=@~B7QXzZLSM +i  U@  JKPX@   _bK _ eL@   g _ eLY@    $$$+ &&#"#"'732546372$@QFA2$@PG&;JmLP&:
JLP +  ' v@!	JKPX@  g_ bK _   e L@ g  g _   e LY@  '&$"  $$++&&'#"&546324632&&#67&#"3888WE;FPD#PGA2$%M8JK2IJ;08?HLP&;0590 +  " j@JKPX@  _ bK _kK  _   e L@  g _kK  _   e LY@"!'$$$!+#"&5#"&546323267754&#"32AFQ8JN;@M@6&PL
J>>LIIcJ
9!!"B     *@'J _ kK  _   i L$$$!+%#"&554#"'63232672AFQ@$2AGP@&PLJ;&PLJ
  9S  % * . ]@Z'.  JHG e	_ kK   _ iL    ,+)( % #"!  *$"
+%3267#"''7&&5466327$37&#'35#+!&@#(Td++9<5cC+AD
a-|>*hO&7B
DJ}WRH;;~_1#JU+ 9 "   U   4     4   @@=J  e _kK _   i L    "%+ #"&547!&&#"'6367!3r7fEevYB=&A *Ne>AE<T}Cy!XQ=?"NXKS  4 & . KPX@&J@&JYKPX@'    h  e _kK	_ iL@+    h  e cK _ kK	_ iLY@'''.'-"$")!
+#"&55#"&547!&&#"'632733267 67!32DCJB7fEevYB=&A *Nej:dW@UAE<_&F>#>\T}Cy!XQ=?@4FFNXKS   +  >@;
	J e ] cK  _   e L    $%%+$#"&'732654&##57!5!3Jy<lHEf(6#I/FIHTOebAd7--2"KHF;CLF  + "   R    " + J@G J G  e  g ] cK  _   e L""'$&+'#"&546326654&##57!5!323&&#"VR@miB4;I$5/HTOryj>I&Hl5CD@1>GZE8H<CLFfbt<)  +  7@4J  e ] cK  _   e L$""+#"&&54633'5!!#"3267*fFEl<|oORJIC1J%{--5^<dpFLCEI?G"  ) " +@( J"! G    a ] cL"*+&54676654&##57!5!32^BPVQG,(7S_l]23$%"E+28

(-""CLFGBIQ"<  
    a@
 JKPX@_ bK ]  cK aL@  g ]  cK aLY@    #+3###5354632&#$
v\^^WN$9!-/%'IG8GHDSC 
   "  b 2 23+  
+ 2PKPX@&	'	/	 JKPX@&	'	/	 J@&	'	/	 JYYKPX@* 		_ bK]
cKaK  _   e LKPX@5 		_ bK_kK]
cKaK  _   e LKPX@2 		_ bK _kK]
cKaK  _   e L@0  		g _kK]
cKaK  _   e LYYY@   2 1.-*(#$$%+ #"'73254&#"####5354632&#"!663QQFA2$@*)*@\\^^WN$9!-/*$
S2VKMLP&:
J8.0-8GHDSC%'IN*0  +J 8 C @-
J8HKPX@8  	 	~ ~  g
		_ kK ] aK _ eL@6  	 	~ ~  g  e
		_ kK _ eLY@999C9B(+4#%5$+##"'332#"&&5332654&##"&5467&&5466366732654#H4]l]$ET5R-~yUc*S>9SG82SCE.+5]9>T7(9:569q
*[Od
+&B*MS#F7 %))%&9+0G35T/qA56A?9u  >+  ' KPX@ J@ JYKPX@" _CK_ ;K  _   > L@&<K _ CK_ ;K  _   > LY@  '&"   %%##		+#"'732655#"&5466327675&&#"3pocB>CJ>M/^i2^?TAe<;%<D>:jn,> ?G_'+vLzFH<B''"#c^_a +! "   O    
+   #@ JcK  _   e L(%+%#"&546733&'3265*"<67;"b_@;N).54.#P>m/%), + "   S   + "   R   + "   Q   +" "   [b   + "   Mb    >+ $ 1 @   ('JKPX@+   _bK _ kK	_ aK _ eL@)   g _ kK	_ aK _ eLY@%%  %1%0,* $ #%%#$$
+ &&#"#"'732655#"&5466325463675&&#"3s2$@pocB>CJ>M/^i2^?Q=PG<;%<D>:&;Jjn,> ?G_'+vLzFAxLPc''"#c^_a     /@,
	JHe  _   i L%%+ #"&'732654&''5#53573#ag8gD;_-2$F)BA=@GNN\lllb@e:),4 PGGJF{
Fl     <@	
  JKPX@   _ bK aL@    g aLY%&+76654&#"'6632#==@AB)F$2-`<Ef6dN\\GFGP 4,)9eAcd    @ H  _   i L%(+#"&'732654&''Kg8gD;_-2$F)BA=@Glb@e:),4 PGGJ[      D@	JKPX@  _   bKaL@    gaLY@    %(+3'&&546632&&#"Od9hE;^,2$C)AFA==.dbBe9*+4 PGFG      %@" 
  J   _ kK aL%&+776654&#"'6632#xH59;4*;"3*W<>^3\H\>53A8&%3W6Q\      U@	  JKPX@  e _ bK aL@   g  e aLY@
%'+3##5#53576654&#"'6632ll\DD==@AB)F$2-`<Ef6dN.WFFGFGP 4,)9eAcd       \@	 JKPX@  e_ bK aL@  g  e aLY@     (+3##5#535'&&546632&&#FA==DD\llOd9hE;^,2$C)PGFGFFWdbBe9*+4  >+     +$J < G @(2	J'HKPX@B ~   ~  	
	g  e_ kK 

] aK _ eL@@ ~   ~  	
	g 
 
e  e_ kK _ eLY@===G=FCA<;961/+1#"+##"&&533267#53&##"&5467&&54663667##"'3323 32654#$5{lUc*S>9GMUSCE.+5]9>T7(H4]l]$ETF`59:569qV=B#F7 %?,5*0G35T/S
*[Od
+@4A56A?9u   ! 9@6JG   ~  a _kL   !  $!++ '6654&##732654&#"'63o28?G11d;1<:/)>!,PmMF09>3W&C*X<)!H)-+%6<  _    -@* JH _kK  a L    #+ #4&#"#763Q\+))@\\>^VKm8.0,
U      f@ JHK&PX@]`K _kK  a L@e _kK  a LY@    #	+ #4&#"##53573#63Q\+))@\OO\>^VKm8.0,^F>
HFU _   "   2 23+ _   "   2 23+ _9 "   i    _+ ' ~@%	 JKPX@% _ bK _kK aK  _   e L@#  g _kK aK  _   e LY@   ' &$#$$%+ #"'73254&#"#4632&#"63QQFA2$@+))@\WN$9!-/*$>^VKMLP&:
J8.0,WDSC%'U  _    c@ JKPX@ _ bK _kK  a L@  g _kK  a LY@    $##+ #4&#"#4632&#"63Q\+))@\WN$9!-/*$>^VKm8.0,WDSC%'U  Z+  -@*J GcK  `   i L    #$+'#"&533267\>^HQ\+))@UVKz8.0,w  +K  <@9J GcK _ kK  _   i L    %$$$+'#"&554#"'6323267K\>^HQ@$2AFQ+))@UVKJ
:&PL8.0,w  + & A@>&J cK _ kK _ iK  `   e L"%$$$!+#"&55#"&554#"'6323267332672AFQ>^HQ@$2AFQ+))@\@&PLUVKJ
:&PL8.0,wJ
  _/ # [@JHKPX@ _kK  _  i L@ cK _ kK aK  _   i LY@	%$%$+ #"&554&#"#763232654'3/Ci<Mf+))@\\>^HQ/,6Q]Zx9\S8.0,
UVK76^k L    "   M     _     @cK   a L    +#\   ! "   O#    $ "   SB    3 "   RQ    3 "   QQ     @ "   Y    /  "   LM    /} "     L    "   M    L9  "   #M    i      ! "   N-   6   N "   W    $ "   ZB   L, "   #M    #   M      "   V3       XJKPX@   _jK cK ` eL@   g  d cLY@    
$+#"&54633327#"&5467$$$$-\G48"	#9D78$##$50F9,+C  Z  )@&
 J   cK `iL    #+&53327#;\!(=7[@    *   hKPX@!	e _   jK cK aL@   g	e cK aLY@    
$
+&54632###5#5353$$$$`\__\#$$#FF  4 "   UR  ,  "   M    ,   @ G   c L+7'>53$E>'*\ IX7C#?7,2 "   RP  ,2 "   QP  +B "   M    ,*  @ G  a cL+%#'>55#53533*`$E>'*__\`IX7C#?7F  ,x  [@J GKPX@ _ bK ]  a L@  g ]  a LY@    $#+%#'>7#534632&&#"*a&C9$)__PGA2$@FF<M2C 4,FLP&;J ,* "   M     _     	 '@$ J HcK  a L		+##7\n  _    "   2 23+ _  "   lY    _    	 +@( JcK  a L  		  +#!#7\n  _      Y@ JKPX@_ bK cK  a L@ g cK  a LY@    #+#4632&##73$\WN$9!-/ng%'WDSC    +  	 (@% J	G  cKaL    +3733n\&  Z  %@" J
 H   _iL    '+&57327#;\!(=7{|@  "   2 23+     @
 H
	 G   t+ .''3&''7&'77i45'V'72Y0A?Q5Q+A6E"Md."5hC@'? S	GE/GYB  *  6@3  JH e   _ iL    ##+327#"&55#5373!(3;``\_Q@=7FLF  H  $ C@@JH  gg  _   i L"#$!+%#"&55&&54632767327&35&#"H!(3;DH@-
\0+,C
=7;2.7N
8X ZK "    2 23+ X "   sv   Z "   l    Z   @@=
 JH	 G g _   i L    $+$#"''7&577663654#"3y<^M" ;"9\B2,$#9.=HGI+TM<:$&4 Zj "  M 	3+ Z9 "   i    Z+w * W@T(
	J%$H e ] cK _ iK  _   e L   * )##$%%	+$#"&'732654&##57!327#"&57!3y<lHBd'3#G-FJHTO!(3;\fd@b7*)3JFH<C@=7{F  _+i  @H  _   e L&!+#"&573267i2AFQ\@&PLJ
 Z, "   #%   M    " J@G   JH  g  g   _ iL   " !%#$#$+'327#"&55&#"'63273267#!(3;'!82W\$7/W*@=76a6[  Zt ) 4@1 JH _ kK   _iL   ) ($-'+&5732654&&'.546632&&#"#\OX_W.-=B0R2ZO'%;!%0+<RIlc D=*++5&)B&<:&%K8RV  
8  -@* J
	H _   i L    #+67#"&55'7773!(3;3#V\[!|@@=7;6e7<L  Zv  @JHK
PX@! ] cK  _  aK  _  a LKPX@ ] cK _  a LKPX@! ] cK  _  aK  _  a L@ ] cK  ]   aK _ iLYYY@	'!+!!#"&57327#5!!k3;\d=7{|{NF  _    Y@	
 JKPX@_cK  a L@ cK_kK  a LY@    """	+ #4#"#4#"#3632663N\J'6\J(6\O;]1EK3WJmf-0mf./MY2-.1 _  ! "   OC   _   "   M    _+ ) t@&!	 JKPX@_	cKaK  _   e L@# cK_	kKaK  _   e LY@   ) (""#$%
+ #"'73254#"#4#"#3632663NQFA2$@J'6\J(6\O;]1EK3WJMLP&:
Jf-0mf./MY2-.1  Z+  5@2J GcK `  i L    ""$$+'#"&'#"&53326733267\;X1EK3AN\J'6\J(6R2-.1WJzf-0vf./v  Z  Y@	JKPX@cK `  a L@cK   aK`iLY@    ""$"	+#'#"&'#"&53326733267O;]1EK3AN\J'6\J(6MY2-.1WJzf-0vf./v  _    M JKPX@ _cK  a L@ cK _kK  a LY@    #+ #4&#"#3663Q\*)*@\OS2VKm8.0-N*0 _  ! "   O   _  	 "        (  ]  ! KPX@ J@JYKPX@   _bK _cKaLKPX@"   _bK cK _kKaL@    e cK _kKaLYY@  !   	+#7&5463#4&#"#3663!)5"Q\*)*@\OS2   Vt VKm8.0-N*0 _   "   R   _ "   s   _ "   l    _ % / KPX@-!
 J	 G@-!
 J	 GYKPX@! g _cK	 _  i L@) g cK _ kK aK	 _   i LY@&&  &/&.+) % $#)$
+$#"''7&554&#"#366327663654#"3<^M" ;"9*)*@\OS2HQB2,$#9.=HGI+T8.0-N*0VK<:$&4 _   "   M   _9 "   i   _  ! "   N    _+  i@	 JKPX@ _cK aK  _   e L@  cK _kK aK  _   e LY@    $$%+ #"'73254&#"#3663QQFA2$@*)*@\OS2VKMLP&:
J8.0-N*0 +  i@  JKPX@ _cK   aK ` eL@  cK _kK   aK ` eLY@    $%#+ #4&#"#"'73253663Q\*)*@QFA2$@OS2VKm8.0-QLP&:
JPN*0  _+  ^@JKPX@ _cK aK  _   e L@ cK _ kK aK  _   e LY@	$#%!+#"&54&#"#3663232672AFQ*)*@\OS2HQ@&PL8.0-N*0VKEJ
 _, "   #J   M4    _+  P@ JGKPX@   _cK aL@ cK   _kK aLY@    '+ '4&#"#3663Q\*)*@\OS2VK78.0-N*0 _   "   U    9   ,@)_kK  _   i L    %+ #"&546633254#{8jIo|8jJR}ER}EJ 9! "0   O   9	 "0       9    9 "0   S   9 "0   R   9 "0   Q   9*| "0   'V^ Y V3+Y3+ 99 "0   #Q   i   | "0   'VY V3+Y3+ 9' "0   'VWE i V3+i3+ 9q "0   'L[k L3+k3+ 9@ "0   Y   9  "0   L   9\ "0   'LV | 3+|3+ 9 "0   M   9E "0   'MV e 3+e3+ 99 "0   i   9! "0   N   9N "0   W    9N_  ! 4@1JH _ kK _   i L! -%&+ #"&5466326654&'754#"3N_ 8jIo|8jJi=HBZR}ER}EC!11  9N!   % 7@4JH _ kK _   i L%$-%*+'7#"&5466326654&'754#"3_ 8jIo|8jJi=HV1rBZR}ER}EC!11  99N_  ! - r@JHK#PX@! _ kK _   iK_ eL@ c _ kK _   i LY@"""-",(&! -%&+ #"&5466326654&'754#"3#"&5463N_ 8jIo|8jJi=H$$$$BZR}ER}EC!11#$$#  9N!   % 7@4JH _ kK _   i L%$-%*+'7 #"&5466326654&'754#"3)o_ 8jIo|8jJi=H1VMBZR}ER}EC!11  9NN  - 5 Z@W 
+*$J ~   g _ kK_ iL..  .5.420#!  #	+ '632#56654&# #"&5466326654&'754#"3 )539*'E' 2_ 8jIo|8jJi=H31*%+:^BZR}ER}EC!11  9N  4 < @ 21+JKPX@+ _   jK _ bK _ kK	_ iLKPX@)  g _   jK _ kK	_ iL@'   g  g _ kK	_ iLYY@55  5<5;97*(#!  %%%
+'66323267#"&'&&# #"&5466326654&'754#"387#88"d_ 8jIo|8jJi=H(0*,
BZR}ER}EC!11 9@ "0   P    9+  # ?@< 
 JG  _kK_ iL  #"   %&'+ '4&#"#"&5466326354#"3jO\%#78jIo|8jJG6<@rRNH*)JtR}ER}E""# 9 "0   Z   9 "0   V   9x "0   'V 3+3+ 9x "0   'V 3+3+ A     9  & 9@6#"	J _kK _  i L  &%  $%+ #"&'#"&5466354&#"3265573GhR8H	G>OdHklz{m22*-XTMX~};:=8{XM#lvwm[U2E|w  9  # T JKPX@   ~ _ kK   ` eL@   ~    d _ kLY"&*##+327#"&547&&546632&3254#"(28"	#9DT\e8jJo{UM 40F9,K/rR}Ef@  9   ' u
JKPX@( ~   ]bK _ kK ` eL@# ~   e  d _ kLY@  &$" 	  +!5327#"&547&&546632&3254#"28"	#9DT\e8jJo{UMEE 40F9,K/rR}Ef@    4@1  J _ kK   _iL    $#$+'7254&#"'632#cE+4$BB 8*D^nx8jI::fc99R}E  9~   & F@C$# JH
	 G_ kK _   i L&%*%+ #"''7&&5466327&#54&'398jI'K*6:8jJ'K*0|{}VR}E{!~UR}Ez~+-umCT 9~! "U   O   9 "0   U   9| "0   'U 3+3+ 92 "0   'UV R 3+R3+  9	  ) XJKPX@  hbK _   i L@  h _   i LY@   ) ((#%+ #"&&5467&&553326553654#"3A8iGFj8B<+-\3443\0*&ABCbI=h><h>FcI.4::4-HJOMK  9`  $ , F@C 	J    e_kK
	_iL%%%,%+#%"%"$"+ !3267#"'#"&546632632'4&#"354#"3`L<&@#(Td}<>zo|8jJ~;;sfn[=:v
 WR7BmmR}EjjzNR  _+   h@ J	 GKPX@ _cK _   i L@ cK _kK _   i LY@    $+ #"'366354#"3^lcX2\OR-`w'@<$|<G(+$.$! _+! "\   O   _+ "\   M    .+F    *@' JH GcK  a L+$5&&54675754&'Fxf\jtxf\ksK??A=R@>sw
sX`y_XTa  _+  % }@"! J	 GKPX@! _ bK _kK _   i L@  g _kK _   i LY@  %$  $&$+ #"'4632&#"66354#"3^lcX2\WN$9!-/*$M,`w'@<$|<,DSC%'()$.$!  _+   B@? J
H	 G _kK _   i L    $+ #"'766354#"3^lcX2\\N,`w'@<$|<%'$.$!  >+   KPX@J G@J GYKPX@ _kK _   i L@cK _ kK _   i LY@    %%+'#"&546632767&&#"3\M/^i2^?T@e<;%=C>:'+}Q~GG;.''"#fefd  >+  ' }@  
J	GKPX@!   _bK _ kK_ iL@   g _ kK_ iLY@  '&"   %&$+ &&#"'#"&546632546367&&#"3s2$@\M/^i2^?S;PG<;%=C>:&;J'+}Q~GE|LPO''"#fefd  >+R  ' KPX@J@JYKPX@! _kK_ iK  `   e L@% cK _ kK_ iK  `   e LY@'&'#%%!+#"&55#"&54663273327&67&&#"3R!(2<M/^i2^?T@O<;%=C>:=7'+}Q~GG;''"#fefd  >+(   - 9 }@65$#	J
 GKPX@_	kK
 _  i L@! cK_	kK
 _  i LY@..!!  .9.842!-!,(&   &'%+ #"&'#"&&54663273663 675&&#"3$654&#"3\.Y>%?\I):V-2[='EBL)98"4?;3w?83B57Q}F")'+D{RPG('CG(+"''+)hceedeeeR&'  _  x  eKPX@ JH@ JYKPX@   _cK aL@ cK   _kK aLY@    #+ &#"#3663`1<\O	H0ZHLk;< _  x! "f   O      ( 3 :@7 +$
 J  _kK _ iL  20 ( '$((%+ &&#"#"&5467'&&#"'6327663&'325#
g!8439!f
!**4EG1*44:"+44*;74057.O %   H   "f   R   Qx "f   l    -  x@ "f   Y}   L9x "f   i     Z  d  )@&  J   _kK aL    $+ &&#"#46322$@\QF&:
JwLP      )@&
 J _kK   a L    "+#4#"'63Q\@$2APLJ
:&  _+x  zKPX@ JH@ JYKPX@ _cK _   e L@ cK _ kK _   e LY@    ##$+67#"&536632&#"3$2AFQO	H01<@
:&PLHk;<ZHLJ  
+  5@2J cK _ iK  `   e L"#%!+#"&55#"'73267332672AFQF.1<\@&PL67ZHL-J
 V   "f   Z    _+x  \KPX@H	 G@J	 GYKPX@   _c L@ cK   _k LY@    #+ &#"3663`1<\O	H0ZHL	k;<  
#  TKPX@	 H G@ J	 HYKPX@  _  a L@   aK _ iLY##+#'#"'73267#O	H01<k;<ZHL      {KPX@ JH@ JYKPX@e   _cK aL@ e cK   _kK aLY@    #	+ &#"3##5#5353663n.;]a\^^O	H0Z@DFFk;<  
#  eKPX@	J G@	 JYKPX@cK  _  a L@cK   aK _ iLY@    ##+#'#"'73267#O	H01<k;<ZHL-   % 4@1  J   _kK _ iL   % $#*%+ &&#"#"'732654&&'&&54663$V''$A$-41@XWyWxO1CQ4=64TK1W6:%  $LBNRE83+%!J9)C% ! "v   O   	 "v        <   @ ]   `L    +3Jc.  "v   R     9 }@,- JKPX@# p    c _ kK _ iL@$ ~    c _ kK _ iLY@
%,#$(+$#"&'732654&#7&'732654&&'&&546632&&#"bK0-F60!*/fF1CQ4=64TK1W66V''$A$-41@XWNP./"044X=83+%!J9)C%:%  $LB  "v   Q    "v   lE    "v   MS   9 "v   iI    _) 3 KPX@
 J@
JYKPX@ _bK  _  i LKPX@ _bK aK  _   i L@ g aK  _   i LYY@   3 2/.,*+ #"'732654&'&&54676654&#"#463_Q," "#&/"1R/;+(*3/.+-5(l\i`&A()0"*D04O+@41-8!4(!&$%'do  + 3 I@F"#  J _ kK _iK   _ eL   3 2%,%$#+'3267#"&55732654&&'&&546632&&#"#0C$2AGP+CW3>55TK1W66V'(#A$-41@XW9^6KJ;&PLr1,*##K9)B%=%  $LB5H#  + 8 ?@<
1	8J _ kK _ iK  _   e L%+%,)!+#"&&'&&'732654&&'&&546632&&#"#"'327':!2%$G7&&L-3955TK1W66V''$A$-41@XW:X, +&5N8'&#K9)B%:%  $LB4H$+!  
    [@
  JKPX@   _bK ] cK aL@   g ] cK aLY@    $+ &#"##53546319!-/*$\^^WNC%'GHDS  	i  .@+J
H]cK  _   i L#!+%#"&5#53573#327i4BCK\\\}
s"'$MI>GwG)%  	i  =@:	JH	e]cK 		 _   i L!
+%#"&55#535#53573#3#327i4BCKQQ\\\}
snn"'$MIGcGwGcG)%  	i   0@-JH]cK  _   i L#%+'7#"&5#53573#327G25u4BCK\\\}
s"'"$MI>GwG)%  	 3 =KPX@'(	;0
 JHK!PX@'(	;0
 JH@'(	;0
 JHYYKPX@%	 
	
g]cK _  i LK!PX@0	 
	
g_ kK]cK _  i L@-	 
	
g _ kK]cK _  i LYY@44  4=4<97 3 2%'##$+$#"'#"&5#53573#3267&546632&&#"663654#"3@bN^:,I*JN\\\}
s )/#%8gG/N$-4!@G.S-,*;1"9:1AJ5MI>GwG)%AdT~F<fdB,*))&   	i ) D@A%)(&	 JH  g    c]cL#$$+#"&'732654&#7&&5#53573#3272-F60!*/-2\\\}
s"'#/8</"044]J;>GwG)%= , 	 "   s   	i "   lD    	  ' P@M%
 JH	 G g]cK	 _   i L  '&#!  $
+$#"''7&5#53573#7663654#"3<^M";!8\\\}
sB2,$#9.=HFF)Y2GwG<:$&4  	i  ! F@C  JH G]cK  _   i L!!$!	+%#"''7&5#5357373#3277i4BS$%+:\\\+4+0#
1B"!%$8r>GwGp)%q<< 	i_ "    	3+ 	9i "   iH    	+ % - @  '		JKPX@-   _
bK]cK		_ iK _ eL@+
   g]cK		_ iK _ eLY@&&  &-&,)( % $#$$$+ &&#"#"'73255#"&5#5357354637#3[2$@QFA2$@8:WU\\\PG<',&;JmLP&:
JJOQ4GwCLPR|/)  	i   t@ JKPX@" _ bK]cK _   i L@   g]cK _   i LY@     $##	+$7#"&5#5354632&&#"3#3!%#4BCK\\OE>2$!}
s"@?$MI>GCLP&;$&KG)% 	Sr "   v       @@=J ~  g   ] cK _ iL$%&#+#6632#"&'732654&#"#!m(.K+3]>9R%2!4(0<2)%A;}

+O46T.$#7742/	       7@4J g cK ^   a L    $+ ##'6733654&##3{jwXE/ RFA=9FEOe\UY[t*0A2:74  # $ 4@1"!  J _kK   _ iL   $ #+#++ 327#"&&54676654&#"'63@cJU368-OG/Ox3Z9VYA/0,&B&&TgP>;F"&+27E#H3CI)#$9<  	+i " G@D"  JH]cK _ iK  _   e L##$#+%#"'73255#"&5#53573#327iPGA2$C;I\\\}
s"#*QLP&;J<NH>GwG)%  	+o  .@+J
H]cK  _   e L"!+#"&5#53573#3267o2AFQ\\\}
s@&PLGwGJ
  	 0 KPX@&'JHKPX@&'JH@&'JHYYKPX@]cK  _   i LKPX@$_ kK]cK  _   i L@! _ kK]cK  _   i LYY@$-#$+ # 5#53573#32654&&'.546632&&#"II\\\i
_Si\X.-=B0R2ZO'%;!%0+<K8QWGwGHB+*+5&)B&<:&%   ~`  2@/J G _ kK ]  a L##+!#5#734&#"'6323`\\}
s"'#5ACK\wG:)%=$MI  Z  EJKPX@cK  `  a L@cK   aK ` iLY##+!#'#"&533273ON8EN\&+M7\R1-TMz6-[x Z! "   O    F   f
 JKPX@	 
 ecK 

`aL@"	 
 ecK aK 

` iLY@#+##'#"&55#53533533#327FUON8ENUU\\U&+M7=R1-TMFF6-[ Z "   S   Z "   R   Z "   Q   Z@ "   Y   Z  "   L   Z} "   `  Z "   ]  Z} "   `  Z\ "   'LV | 3+|3+ Z9 "   i   Z! "   N   ZN "   W    Zc_  a@  JHKPX@   ~cK `aL@   ~cK aK ` iLY@	##+ #'#"&533273654&'7c?=ON8EN\&+M7\/H>137_R1-TMz6-[x6	&  Zc!  " d@  J"!HKPX@   ~cK `aL@   ~cK aK ` iLY@	##+'7#'#"&533273654&'7?=ON8EN\&+M7\/HV1r137_R1-TMz6-[x6	&  Z9c_  * @  JHKPX@%   ~cK `aK_ eLK#PX@)   ~cK aK ` iK_ eL@&   ~ ccK aK ` iLYY@*),##	+ #'#"&533273654&'7 #"&5463c?=ON8EN\&+M7\/H$$$$>137_R1-TMz6-[x6	&W#$$#  Zc!  " d@  J"!HKPX@   ~cK `aL@   ~cK aK ` iLY@	##+'7#'#"&533273654&'7)?=ON8EN\&+M7\/H1VM137_R1-TMz6-[x6	&  ZcN  2 @ 
21,)JKPX@+ ~ ~  	 gcK `aL@/ ~ ~  	 gcK aK ` iLY@  +*(&#"  #
+'632#56654&##'#"&533273654&'7)539*'E' J?=ON8EN\&+M7\/H31*%+:^137_R1-TMz6-[x6	&  Zc  9@ 9830"JKPX@/ ~
 _   jK _ bK	cK `aLKPX@3 ~
 _   jK _ bK	cK aK ` iLKPX@1 ~  g
 _   jK	cK aK ` iL@/ ~  
 g  g	cK aK ` iLYYY@  21/-*)&$!   %%%+'66323267#"&'&&##'#"&533273654&'787#88"|?=ON8EN\&+M7\/H(0*,
137_R1-TMz6-[x6	& Z@ "   P   Z "   Z   Z "   V    Z ! [@! JKPX@cK ` iK   _ eL@    ccK ` iLY@	#(##+327#"&5467'#"&53327348"	#9D<?N8EN\&+M7\50F9,-FH1-TMz6-[x  9  0@-	 J  ]cK _iL    &+&&547#5332654&'53##j9ZM$)FCBH)%LZ:jGArHRHF*aNX[\XMa*FHRGrB ZD "   T   Z "   U   Z| "   'U 3+3+  
    !@ JcK   a L    +#3odC  Z  Y@
 JKPX@  _  cK _iL@   cK _ kK _iLY@    #%"+&53326554&#"'632#f\[:N!&4<?i@[Tlm]l@><_|:  
  (>  (@%
 J   g cK   a L#$+!#36632&#"/odv2/ &C~<2>  
    !@ J   cKaL    +33#
odC      '@$ JcK  a L    +##33x}\_z{\_hgc`D11   ! "   O      "   Q+       "   L'     ! "   N      	>  .@+ J  g  cKaL#$+336632&#"##\_hgcN6/#&b}\_z11;3>8D      '@$ J  cKaL    +333##x}\_z{\_hgc`D11  _+   C@		GKPX@  _  cL@   cK _kLY@    + 3663654&#"7bCt[G\O#S:Z1/SC;cVOtU/%L+-{sW89P       @	 JcK  a L+#'#'373)ohlnoh  
+  @ J GcK   a L+'>7#332og
4>%b_\kH	"5-4 
+! "   O   
+ "   Q   
+  "   L   
+ "   i   
+! "   N    
+>  ,@) J G   g cK   a L#$+>7#36632&#"34>%bi50%!ti	"5-4<2>>ao 
+N "   W   
+ "   V    +   +@(G  fcK aL	+3#'>7##53'33737#+Alog
4>%lC-/b+*_LB\kH	"5-AB4 
+ "   U    
    @ J H   cKaL+>73##:]G
5>% b_D[7F	#;44     	 /@, J ]cK   ] aL   	 	+!!5#5FME|N   ! "   Oq     	 "          "   R       v@
 JK
PX@&   o  g ] cK	 _  a L@%    g ] cK	 _  a LY@&"
+$#47#5#5!36632654#"DdgG5-:v)  )QG3E|NFFC2,)!!+    "   M9   9 "   i5    +  =@:  	J ] cK   ] aK _ eL$#+!#"'73255!5#5!QFA2$CdLP&:
JAE|N  +E  9@6J ] cK ] aK  _   e L"!+#"&55!5#5!!3267E2AFNd@&PL9E|NFJ
      7@4 J e ] cK   ] aL+7!!57#537#5!3#~uQmdtTMMEFNFF  +  6@3  J   ] cK _eL    '+&&'.'5#5!327#C2$,E0d6B")':$ $,$E|NFp;0&#<  
    d@
  JKPX@   _bK]cKaL@   g]cKaLY@    $	+ &#"!####535463>E# 4;5(&\\TTZ\@&(F8GEFT  
< $ @$JKPX@" _ bK]cK  _  i LKPX@& _ bK]cK aK  _   i L@$  g]cK aK  _   i LYY@&#%!	+%#"&5&&#"3###53546327327<%)364 1'
v\TTYU"7![;9+	$(IG8GHER

  A    % ) @  JKPX@' g	 g   _ K ] LKPX@%    g g	 g ] LKPX@' g	 g   _ K ] L@%    g g	 g ] LYYY@  )('&%$!  +##
+54&#"'632&&'#"&546375#"3!!9(+1@NH#+A(?Ic[!0j"x' >=C7@D5PH M  8      KPX@     g_K ]LKPX@g    g ]LKPX@     g_K ]L@g    g ]LYYY@    
$	+ #"&54633254&#5!Weg[\fh[dcc11xob_rpa_rEHDMM    *  .@+H  ee aL	+#3###535#5373*bbbVccccVbV??V?
  d     @  H   a L+#V d  f "        d    $@!  H   _ iL&+##"&5463VI((((())(    @ JKPX@   _ K _LKPX@    g _ LKPX@   _ K _LKPX@    g _ L@     gW_ OYYYY@    $##+#54&#"#4632&#"663,MM93-+*&%&0	35    @ JHKPX@   _LKPX@  W_ OKPX@   _L@  W_ OYYY@    #+#54&#"#7663,MMM+*&t	  # $   GK	PX@    W _   OKPX@   _K LKPX@     _ LKPX@   _K LKPX@     _ L@    W _   OYYYYY@    
$+#"&5463'66553'88!M$::4!     )@& J H   W   _ O    +&573263#H*M
%&29	    @
 JK	PX@  g ]  MKPX@ _K  _ LKPX@  g ]  MKPX@ _K  _ LKPX@  g ]  M@  U  g  ]  MYYYYY@    #+#54&#"#363,MMC#2*&		#     K"PX@	 J G@	  JYKPX@   W  ]LKPX@ U   W  _  OKPX@   W  ]LK"PX@ U   W  _  O@  W   e _ OYYYY@    ##+#'#"'732675;
'
8!H&&|   # @  JKPX@  c   _ LKPX@   g W _ OKPX@  c   _ L@   g W _ OYYY@   # "$*$+&&#"#"'73254&&'&&5463/! )1+E8D5'%.-+?4",


&#$3'*	
& #.     ! i@ JK1PX@ e _ `K ]   a L@  ge ]   a LY@   ! !%%	+%!567#536654&#"'66323#uu3$<2)>#<)d><[2G2vMMIz9J0K+4;"'0320S4,R,J9v     JK	PX@  U ]  MKPX@  ] LKPX@  U ]  MKPX@  ] L@  U ]  MYYYY@    +#'#3737DW//[CP%3N/(	  >  	 JK	PX@  U ]  MKPX@  ] LKPX@  U ]  MKPX@  ] L@  U ]  MYYYY+#'#7'373aW;9UaWV1.See}VV  !:  q@ J GK	PX@
    tKPX@   LKPX@
    tKPX@   L@
    tYYYY+'667#373F?	*&[S9BN426	  (jw   " P@M	J  		e  R ]:K
^ ;L  ""  	+%#'!#53667&&553!35#5#wKeK9!<JH_# B;+N#]md{t@IQ_u) j  $ ( S@PJ
eR ]	:K ^  ; L%%%(%('&$#	+!####'!#53>77!3333%#335#n.xKK/__/dec%#_CP  ~T  j  .@+ J   a ] :K ;L    	+%#'##'>7!KU!&@>&%-Na|{9J,Xa *D  ;@8 
J   e:K   ;K _ >L    $#	+#!#"'73253!D_PGA2%=_"OCLP&<J    7      d  %   6@3 e ] :K ]   ; L    $	+ ##!!3654&##3|w[PRRO\_jhrjN>PJ@ d  3  %    d    @   ]:K ;L    	+!#_R d   "       d  0  EIK
PX@   n ] :K ;L@    ] :K ;LY	+3!#!\_20R j7   3@0  Q ] :K] ;L    		+%#'!#53>77!#!7KsK/^_%#+NP~T  d    /@,  e   ]:K ] ;L    	+!3#!!LLL d   "      d  ~ " E         0  6@3J e
	:K  ; L    	+#####3333kR[SifR[RCCnC    
 & ?@< J   g _ AK   _BL   & %#$!$$	+&'732654&##732654&#"'632#r)8@_GNMKB6<G9;RN2`ydlH?DZ?pG/.6CF==AN=5/;@9UcM?OXL>_5  d  G  @ J:K  ; L	+!#47#33G_z_wPunJ d  Gx "       d  G "       djx   I@FJ
	 H   g	 a:K;L    %
	+ &'73267##7#47#33S=
+$$.
=U>aPK#Uz_w?6 6?XPunJ  d  C  -@*J   e:K  ; L    	+###330n^___C  d  C "       /  #@ 	 G ]:K   ; L    	+##'>7/_!&@>&%-Oa|{9J,Xa >       d  D  p    7}   ,@)_AK  _   B L    &	+ #"&&5466332#IIWWIIVZdeYSrpTRqoUN  d  ?  !@ ]:K  ; L    	+#!#?__O` d  %     7  ,            !   @ J G   :L	+%'667#33Y<T@FD#c`DN*
E7?F  !x "   X   (    :@7 Ug
	  g ] M	+$#5&&546753654&'\\~qsuooqsNNFFupnvnvsp-    /    (     /@,J   g:K   ; L    "#	+##"&53327 _,O4\n_[<O!p_	:M  dj  #@   R:K  ^ ;L	+%3#'!3!35PK9__Nc  d  9  %@":K ^   ; L    	+!33339+]YOcc  dj  '@$  R:K  ^ ;L	+%3#'!333339PK5]Y]Ncc  dj5  )@&  :K  ^  ; L    	+##'#3!5K_Oc  d  % 
  0@- e :K ^   ; L   
 	$	+ ##33654&##3|_[PRQP\_kjtk?RLA       6@3 e ] :K ]   ; L    $	+ ###5!3654&##3	|#[PRQP\_kjtk`Q?RLA  d   
   6@3 e:K ^  ; L   
 	$		+ ##33%3#$654&##3|_N___RRROUkjtkOL?RLA  j   :@7 G e ] :K ]   ; L    $	+ ###'>7!3654&##3|!&@>&%-mNSRRROUkjtka|{9J,Xa?RLA  d     8@5	e:K
 ^  ; L    $	+ ##!#3!33654##3u___]GO^_hcmhV<K       7  7@4J  e _ AK  _   B L"$&"	+%#"&&546632&#"!!3267eATILP>U,4?FOhhR,B%A!,SqqR $=3nwN}{    A@>	 J  e _AK  _   B L    "%$	+ #"&'7327!5!&&#"'663X@]%0"@-TC.C%1*`>(";Nzk:#$ d     x    5~ " x   S   w           7@4
 J  g] :K  ; L    "	+ #54#"##5!#63=m_2J_
@jsf&$`QQE  dL   nKPX@!  e _:K	 _  B L@)  e :K _AK ;K	 _   B LY@    &
	+ #"&'##33663#"3EEU|X__YuV^`TRrpS       8@5J  e ]:K  ; L    	+###&&5463#"3_lACd^YOK?O bBeoDFAB  w  :@7  JG   g] :K ;L    .	+ '>554&#"##5!#63?kY[..@C1H_
@lsfffE*<0DE%%`QQE <
         ^   >@;e	 e :K
 ^   ; L    $	+ ###53533#3654&##3|_[PRRO\_jhrjI\\I^>PJ@  d $ v@$	JKPX@!	e _:K 		 _  B L@)	e :K _ AK ;K 		 _   B LY@" $#"
	+%#"&&'##33>32&#"!!3267eAQ~KX__YP{I>U,4?FOhhR,B%A!,LhaF $=3nwN}{    A   0@-J   e :K;L    	+!####33'W7V;X`xLOk  d  3   8@5J
  e:K	;L    	+!######3333'W7V;X`]__kxLFOk       C@@JI	 e
] :K  ; L    	+#####3'5!'76kR[SiW{77CC  d  l   E@BJI
 e ]	:K  ; L    	+#######3!'5!7!hr>[?pi__2{777CC  )  ) B@?'"J HG    a ] :L)(&%$#!	+#'77&&54676654&##57!5!3=(~'7tm\33$%"CBOWOIIJbn-QQ-h^[i"<E+28

A@D<CNM #   $    7}    =@:  e_AK _   B L    &		+ #"&&54663!&&#67!3IIWWIIVSfeUWe~gUSrpTRqoUNtyzsyz      G@	 
JKPX@  _  :K ;L@   :K _ AK ;LY$$	+36632&#"#fF7!1$
f@:6"    "-      7+ "        
    '@$e   ] :K ;L	+!3###53!_bb_FWF  d+;  G@D	 J g ] :K ;K  _   > L    $$%	+ #"'73254&#"#!!63kPGA2%=@C1H_w@lsfLP&<JDE%%NE  jK  <@9J
 e    a	:K;L	+%3#'#####33333FK,R[SifR[RdNCCnC    
 5 H@E*)2
	 J ~  g    d _ AL#$!$)$&	+$#"'73254&'&&'732654&##732654&#"'632s]KF<6*;%&6\#8@_GNMKB6<G9;RN2`ydlH?DZqp1F3=48;.'6CF==AN=5/;@9UcM?OXL  djV  0@-J   e    a:K;L	+%3#'###333@K'^___dNC   d  C  0@-e   e	:K  ; L
	+###5##335333~k6)]])6dnD!    G  0@-e   e	:K  ; L
	+####53533#33un^_TT_dd_dnCI\\I{       '@$   e ]:K  ; L	+####5!33n^_#_dnC`Q   dj  *@'   e    a:K;L	+%3#'#!#3!3DPKU__"_NC   d+   I@F	 J g ] :K;K  _   > L     $$%		+ #"'73254&#"#!#!63IkPGA2%=@C0G__@isfLP&<J)DE##`B  dj  $@!    a ] :K;L	+%3#'#!#!?PKU_N`  7 * 6 B@?-  J G  g _ AK  _   B L*'$$&)	+$&''#"&&546632&#"327&&5466326654&#"LF:@%'2YJLP>U,4?FVik]
$%,P5R]03(%',%G!-$&.
SrqR $=33Y-3S0`K6O)Y?-/70  7 * :@7)*
	 J ~    d _ AL$$+$&	+$#"'73254&'.546632&#"3267Q4LF<6*;%&Jp?LP>U,4?FVihV,B%/%)1F3=48;
WhqR $=3<  j  $@!  a  ] :K ;L	+#3#'##5!PKU``Q   ! 0      !  /@, J  f:K ;L    	+3##5#533!cx`xbiFFU  j,  )@&	 J    a:K;L	+%3#'##33AK'flfN1oB  (jP  8@5J  g   a:K ;L    "#	+%#'##"&533273PKU,O4\n_[<_N!p_	:M  (     k@JIK&PX@  g:K ] <K   ; L@  g   e:K   ; LY@    !	+##5#"&535367 _3;	\n_t;>-Ohap_	}+M  d  ;  /@,
 J  g :K  ; L    "	+ #54#"#363m_2J__@jsf&$E  dj  8@5
J  g   a :K;L    ""	+%#'#54#"#3632KU2J__@jamN&$Esf    # * ?@< J  g _ AK _ BL$$$*$*%#*"%!		+ !3267#"&'#"&546733>32'&&#"A
4V)02pE}FL@		6KxL^[PQ_J":+*C72 !2jGww    1 8 @$# JKPX@(   ~	  g _ AK ` >L@%   ~	  g  d _ ALY@222828%#*'#)!
	+ !3267327#"&547&&'#"&546733>32'&&#"A
4V)0@JF38"	#9DQrFL@		6KxL^[PQ_J":750F9,I/	C72 !2jGww d     x     0x "        d+0  9@6	 J  e:K ;K  _   > L$$%	+ #"'732554&###333WPGA2%=>@___dxl^LP&<JFC-  j  .@+ J   a ] :K ;L    	+%#7##'>7!PK#U!&@>&%-Na|{9J,Xa  d+D  ;@8 J  e:K ;K  _   > L    $#	+#"'7325!#3!DPGA2%=__"LP&<J   dj  *@'   e    a:K;L	+%3#7#!#3!3DnPK#U__"_NC   (j   8@5J  g  a:K   ; L    "#	+##535#"&53327 FKA,O4\n_[<O!p_	:M  >j:  7@4
J ~   a:K;L    	+%#7#&'##33:PK#RYZ93N7b}   7x "    i    7~ "       d  x "   l   -R   =@:J  e _AK _   B L    "%	+ #"&547!&&#"'6637!3G|Q^V]V02pE{P|qA:+* -R~ "R        0~ "   [   
~ "      
  ^   d  G^ "      d  G~ "      7}~ "       7}    =@:  e_AK _   B L    &		+ #"&&54663!&&#67!3IIWWIIVSfeUWe~gUSrpTRqoUNtyzsyz 7}~ "Z      ~ "       !^ "       !~ "       ! "      (   ~ "       dj 	 "@  a   ] :K ;L	+!3#'#!PKU_ d  ~ "   W    
+  L@IJ ~  e
		] :K ;K ` >L    $#	+3#3#"'73255##53!^PGA2%=^bb_FLP&<J?WFR  ++  C@@ J~:K;K  _   > L    $#	+%#"'73255##33+PGA2%=!flfNLP&<J?1oB      5@2 J f:K  ; L    		+###53333[lflfM6MFF     
  0@-  e:K ^   ; L   
 
$!	+#"&54633#"3v{[\ORQMOfnjpDLN:    ) =@:"J ~  e :K _  B L   ) ($#%$$		+ #"&'#"&&54633332654'3 675#"3Ci<7PX26`<{[_/,9N]B\A5:;Zx920222`Cox76]l.F7;ED   $ 8@5J ~  e ] :K  _   B L(!$!#	+ #"&''#532654&##53232654'3q\F](bqfKLMUJKb4$4:];<BEI=D@9JbaHZ*&Zo/F  j  8@5J  e   a ] :K ;L    !$!	+%#'##532654&##532K>qfKLMUJKN$I=D@9JbaHZ  n ! ,@) G ~ ] :K  _   B L#$	+ #"&&5#'>7!32654'3nCi<2S1!&@>&%-/,9N]:;Zx9)O7|{9J,Xa76]l.F  d  aKPX@" ~  e:K  _  B L@& ~  e:K ;K  _   B LY@#$	+ #"&&55!#3!332654'3Ci<2S1__"_/,9N]:;Zx9)O7 76]l.F 79  d    q  *@' ~] :K  _   B L#$	+ #"&&5#5!#32654'3qCi<2S1
/,9N]:;Zx9)O7QQK76]l.F -  Y    +/  0@- J ]:K  _   > L    $#	+#"'7325#'>7/PGA2%=!&@>&%-LP&<J|{9J,Xa  #  *@' J G ]:K  ; L	+!##'#'>733#lfZ!&@>&%-f1o|{9J,Xa  d     ?@< J   e ]:K;L    !"		+!###3273 654&##3@pW_s{avTUIUS69sb
HARGE       J@GJ  e	 	e] :K
 ]  ; L    &	+%!##&&5463!!3##"3lAC_^YOK?LL bBeoLLDFAB 7       ! (    d  C  1@.J   e:K  ; L	+###337'773'qn^___?o&mGdcu&rnCjF;DyI;H  + ( H@E&	 J g ] :K ;K  _   > L   ( '$$%	+ #"'73254&#"##'>7!63:kPGA2%=@C0G_!&@>&%-@jsfLP&<J)DE$#a|{9J,XaC  d+ $ O@L"	 J
	 	g  e:K;K  _   > L   $ #$$%	+ #"'73254&#"#!#3!363NkPGA2%=@C0G___"_@isfLP&<J)DE##C B    0   >@;e	 e :K
 ^   ; L    $	+ ###53533#3654&##3|[[_[PRRO\_jhrjE^^E`>PJ@  d  %   G@DJ ~   ~  f ] :K ;L%!"	+ #'###327'3654&##3%jIO:+6W_ZOJ0WQUSV7w_
kjz"TJB - O    9
  ' 6@3#JH g _   B L  '&!  $	+ #"&54667667663654&#"3k~jj#WO;G%'#K42:#X8H;8.PG?p}s_ E%+QF.4QSg[P12@]e  _     ! D@AJ  e_ CK ]   ; L! ("#	+ ##632&32654&#654&##3ye]Pbr65(c04:;KB8CdboSOJE-8	$+($t(4+&  _    @ ] <K   ; L	+3#!#\IL _  ! "}   O    _    $@!I    ] <K ;L	+3##3L\\L=   j   3@0  Q ] <K] ;L    		+%#'!#53>77!#3KK%J\!J)fb;|o]d6  9   3@0 	J    e _ CK _ BL%%$"	+ !3267#"&546632'4&#"3L<&@#(Tdn{5cCip[>>q
 WR7B~RHzNR 9! "   N   9  "   L        6@3J e
	<K  ; L    	+#'##5##'335337e}FXE~d`nFXGo   ' E@B$# J  g _CK  _   B L   ' &$!#$+	+ #"'73254&##732654&#"'663W537BDbwT0#G.IAF68D:/)? ,(\:!@-,8<8RUB9^.%H(*'#7  _    @ J<K  ; L	+!#5467#33[m[o<lY5q _   "   v  _  ! "   N    _j]  ! u@J
	 HK*PX@ 	 a _   AK<K;L@   g	 a<K;LY@  !!   %
	+&'73267##7#5467#33S=
+$$.
=U>3FK#Qm[o?6 6?<lY5q;  _    -@*J   e<K  ; L    	+#'##337mC\\E _  ! "   O    %  )@&
 J	 G ]<K   ; L    	+##'>77\	9:"kj9I&Na  <  c  (@%J   ~<K  ; L	+!#'&&5##33cZxWpY/wgqy'_7{7y  _    '@$    e<K;L    	+!5##3353\\\  9   ,@)_CK  _   B L    %	+ #"&546633254#{8jIo|8jJR}ER}EJ  _    !@   ] <K;L    	+!##!\< _+ \   9 }        !@  ]<K ;L    	+###5\K<K  
+  @ J G<K   ; L	+'>7#332og
4>%b_\kH	"5-4 
+ "   @   >+  & 1 X@U.-
 JH	 G_CK
	 _  B L''  '1'0,*&%!  $&$	+ #"'#"&5463263 67&#"3 654#"3S`UK.XD'P]Q]Q/X.M7-@.02-[4c?)2!~C #~:<"#<eeeffe> !        7    /@,J   h<K   ; L    ##	+#5#"&55332675\U-KL\)+#MQK2-   _j:  #@   R<K  ^ ;L	+%3#'!333PK\\J<  _    %@"<K ^   ; L    	+!3333ZX;;  _j  '@$  R<K  ^ ;L	+%3#'!33333PKZXZJ;;  _j  )@&  <K  ^  ; L    	+##'#33K\<  _   
  0@- g <K ^   ; L   
 	$	+ ##33654&##3wjwX\FA=9FEOe\UY[2:74    5   6@3 g ] <K ]   ; L    $	+ ###5!3654&##3jwX
FA=9FEOe\UY[F2:74  _   
   6@3 g<K ^  ; L   
 	$		+ ##33%3#&654&##3mjwX\<,\\=9F;Ee\UY[H2:74  %   @@= J G g ] <K ]   ; L    $	+ ###'>77!3654&##3jwX	9:"O<A=9F;Ee\UY[kj9I&Na2:74  _     8@5	g<K
 ^  ; L    #	+ ####3353354&##3xW\\\<9F=GMRV`0/  v    9  A@> J  e _ CK _   B L    $%$	+$67#"&546632&&#"3#3C6 +GYn}9iF_D+ 5=K	?;:T~D98SNF    A@> J  e _CK  _   B L    "$$	+ #"'73267#53&&#"'663;pvpbE,7&:G:6#<*%S3:;SYFRO8 L    "   M     /  "   LM  ,  "   M           _   nKPX@!  e _<K	 _  B L@)  e <K _CK ;K	 _   B LY@    &
	+ #"&'##33663654&#"3;f75gG`t^\\_u\C<B=@>D|SN}Img#fd`h`i  #     8@5J  e ]<K  ; L    	+#5##7&54635#"3\sog~]peSU995;,cNS+/2,  , " h@  JHGK&PX@]:K   _CK ;L@e   _CK ;LY@   " !/	+ '>54&#"##53573#63Q$E>'*+))@\LL\>^VKIX7C#?7S8.0,^F>
HFU A          jHK1PX@! g]<K	 ]   ; L@e g	 ]   ; LY@    $
	+ ###53573#3654&##3uu}sTT\z7FEAA@>eWY[ZFmxFn/>73  _   KPX@	 	J@		JYKPX@"	e _<K
		 _  B L@*	e <K _ CK ;K
		 _   B LY@     $"$	+$67#"&'##336632&&#"3#3"6 +GYh{^\\_{`_D+ 5=K	?;:tl|98SNF  
     0@-J   f <K;L    	+!'##5##33'C1L/C\l|>  _     8@5J
  f<K	;L    	+!'##5##7##33733'^@,L*@ZFm\\Wnt:       C@@JI	 e
] <K  ; L    	+#'##5##3'5!'7^dHXGc_Qz{ki--11  _     J@GJI
 e]	<K  ; L    	+#'##5##7##33'5!'7lh[H1X0H\Pi\\ll_],11 ) "   R   P+    9     
  (>  (@%
 J   g <K   ; L#$	+!#36632&#"/odv2/ &C~<2> 
  (@ "   Y   9+& "0   D        '@$e   ] <K ;L	+#3##5#535!rr\RRIFF  _+  D@A	 J g ] <K ;K  _   > L    $$%	+ #"'732554&#"#!#663SQFA2$@*')@\IP0]VPLP&:
J60*'H"*  j  <@9J
 e    a	<K;L	+%3#'#'##5##'3353373BK%}FXE~d`nFXGo_J   7 Q@N*)4
	 J  g    c _ CK _ BL%$!#$$&	+$#"'73254&'&'73254&##732654&#"'6632_NMF<6*;$$jM0#G.IAF68D:/)? ,(\:2W537BDUS0H3=48:=9^.%H(*'#7!@-,8<8  _j  0@-J   e    a<K;L	+%3#'#'##3373@K$C\\EeJ  _     0@-e   e	<K  ; L
	+#'##5##3353373qfw/$\\$/ha{{ss      2@/He   e <K  ; L		+#'###53573#373OmC\NN\Ee6Ff
pF    7  '@$   e ]<K  ; L	+#'###53373mC\EeF  _jB  *@'   e    a<K;L	+%3#'#5##3353PKR\\\J  _j?  $@!    a ] <K;L	+%3#'###!PKR\J<  _+$ ! F@C	 J g ] <K;K  _   > L   !  $$%		+ #"'732554&#"###!663SQFA2$@*')@\\P0]VPLP&:
J60*'<"*  9& + 6 A@>- J G  g _ CK  _   B L)$$%%-	+$0&'&'#"&546632&&#"33&546326654&#"&C::5#k{8gG/N$,5 @GG@	8QJFQ0'(  "i  $,>!T~F:fdeaS@BYQB>JG/"+/'  9 ) 9@6)
	 J ~    d _ CL$%*$&	+%#"'73254&'&&546632&&#"3267<EKF<6*;''V`8gG/N$,5 @GFA4 ./	0G3=48 ;pT~F:fdd_  j  $@!  a  ] <K ;L	+#3#'##5!PKRK  
+  @ G  < L    	+53Zb  V  
+  0@- JG<K  ^;L    	+3#5#533ShZhSb9FFV  j  )@&	 J    a<K;L	+%3#'#'#'373JK/hlnohJ  7j  8@5J  h   a<K ;L    ##	+%#'#5#"&553326753KRU-KL\)+#M\JQK2- ;  7    ;@8J  h   e<K   ; L    1	+#5#5#"&553536675\!47KL\&(7-SIQK1,  _    +@( JH  g  ; L    #	+ #4&#"#7663R\*(*@\\O1VK17//,
',  _j<  4@1JH  g   a;L    %#	+%#'#4&#"#76632<KN*(*@\\O1GRJ17//,
',VK  E " ) <@9 	J  g _ CK _ BL%"*"$"	+ !3267#"&'#"&5467336632'4&#"3EL<&@#(TdhzEG9

6
s\ip[>>q
 WR7Bs=503lzNR  E 1 8 x@%$ 	JK&PX@'   ~  g _ CK ` >L@$   ~  g  d _ CLY@%"*'#)"		+ !3267327#"&547&&'#"&5467336632'4&#"3EL<&@#(,1B18"	#9DHZiEG9

6
s\ip[>>q
 WR7#40F9,E.
i=503lzNR Z       "        _+  9@6	 J  e<K ;K  `   > L$$%	+ #"'732554&###3373IQFA2$@/8h\\Cc%QKLP&:
J8.  %jE  2@/ J   a ] <K ;L    	+%#7##'>77!EFK#R	9:"SJkj9I&Na;  _+  ;@8 J  e<K ;K  `   > L    $#	+#"'7325##335QFA2$@\\LP&:
J)  _jV  *@'   e    a<K;L	+%3#7#5##3353dFK#R\\\J  7j  8@5J  h  a<K   ; L    ##	+##535#"&55332675UKSU-KL\)+#MQK2-   <j  7@4J ~   a<K;L    	+%#7#'&&5##33FK#PxWpY/wgqy)J'_7{7y; - "O   O  -  "O   L   9 "   a   4   @@=J  e _CK _   B L    "%	+ #"&547!&&#"'6367!3r7fEevYB=&A *Ne>AE<T}Cy!XQ=?"NXKS 4  "   L       "   L'     "   L    +    _   "   V   _    "   L   9  "   L    9    =@:  e_CK _   B L    %		+ #"&54663!&#7!3{8jIo|8jJ|{~

R}ER}EIk 9  "   L     "   L   
+ "   V   
+  "   L   
+@ "   P   7    "   L    _j 	 "@  a   ] <K ;L	+#3#'#!PKRI _    "   L/    +  L@IJ ~  e
		] <K ;K ` >L    $#	+3#3#"'73255#5#535!rr\QFA2$@\RRIFLP&:
JAFL  +  C@@ J~<K;K  _   > L    $#	+%#"'73255#'#'373QFA2$@"hlnohJLP&:
JA      5@2 J f<K  ; L    		+%#'#7#53'3733@ohmkhrsdnBB >     >,  , F@C#"JH ~ _ CK _  B L   , +&&%#$	+ #"&'#"&54663232654'3 675&&#"3,>e;;W7l^i2^?Q=\/,7F];;%=C>:8;Zx985k}Q~GA76\m.F2="#fefd  i # 8@5J ~  e ] <K  _   B L'!$!#	+ #"&''#532654&##53232654'3ik\?R,6j`79>?z{kqq9-36]8;>EUF-1/,FROj(X)Wh8F  j  8@5J  e   a ] <K ;L    !$!	+%#'#'#532654&##532K(k`79>?z{kqqbJF-1/,FROj(  % ! 2@/ J ~ ] <K  _   B L#$	+ #"&&5#'>77!32654'3>e;2Q0	9:"S/,7F]8;Zx9*P7!kj9I&Na76[k1F  _'  4@1 ~  e<K ;K  _   B L#$	+ #"&&55##335332654'3'>e;2Q0\\\/,7F]8;Zx9*P7E76Zi4F 9 E    D  *@' ~] <K  _   B L#$	+ #"&&5#5!#32654'3D>e;2Q0/,7F](+Zx9*P7!KK76Zi%N 9     %+  1@. J ]<K  _   > L    $#	+#"'7325#'>77QFA2$@	9:"LP&:
Jkj9I&Na  %  +@( J G ]<K  ; L	+!#'#'#'>77373ohs@	9:"nohkj9I&Na  _+   KPX@ J G@J GYKPX@ ]<K _  B L@"<K _ CK;K _   B LY@    ##		+!'#"'3663273$54#"3	j[X2\OR-ew'@<$m<G(+ ?.$!  #  & / KPX@  	J@  	JYKPX@"	  e
_<K _BLKPX@0	  e
_ CK
] <K ;K _ BL@.	  e _ CK 

] <K ;K _ BLYY@-+)'%!&$"	+$!3267#"&'##7&&54633632'4&#"3 3367#"K>#@"(Tbdz]ug/3kV")gq[?=8@pF-.0UJ7B~lE/DR{O[WYf@)( >+ b          _    1@.J   e<K  ; L	+#'##337'773'JmC\\E/Q$P3eR\$]J382Q}:8:  %+ ) F@C&	 J g ] <K ;K  _   > L   ) ($$%	+ #"'732554&#"##'>77!663SQFA2$@*')@\	9:"SP0]VPLP&:
J60*'kj9I&Na"*  _+' % O@L"	 J
	 	g  e<K;K  _   > L   % $$$%	+ #"'732554&#"#5##3353663SQFA2$@*')@\\\\P0]VPLP&:
J60*'"*       >@;e	 g <K
 ^   ; L    $	+ ###53533#3654##3wv~rTT\z7EF@>QTRTWF<<F<,7`  _+  $ @ !	J
 GKPX@$ ~    _<K` BL@( ~    <K _ CK` BLY@$#$#"	+$#'#"'366327'3654#"3-,IO6X2\OR-e^]OH#w'@<${#wX<G(+u.t.$!  7jR   # P@M	J  		e  R ]<K
^ ;L  ##   	+%#'!#53667&&5537!35#5#RKK&&:EBZ79 JMQXL][,1
;IV   j;  $ ( S@PJ
eR ]	<K ^  ; L%%%(%('&$#	+!#'###'!#53>77!353373%#335#;m~xKK%S\qeS!S)fbo]d6  %j1  2@/ J   a ] <K ;L    	+%#'##'>77!1KR	9:"SJkj9I&Na; *  ;@8 
J   e<K   ;K ` >L    $#	+#5##"'7325335\QFA2$@\LP&:
JQ  d    -@*  e   ]:K;L    	+##!#3!
___"QC   _    -@*  e   ]<K;L    	+##5##335\\\K<  j  +@(  R]:K  ^ ;L	+%3#'!#5!#!3PK9
_N`QQc  j  +@(  R]<K  ^ ;L	+%3#'!#5!#33>PKw\JFF    "   - p   w         7  
 ,@)
J    f LKML  	  
+!'!#3%344`xzkOh d  3  %   d         A    @LK  ^   M L    
+!!`:IOP  d    /@,  e   ]LK ] ML    
+!3#!!LLL    <    d  D  '@$    eLKML    
+!!#3!3__"_C O  7}    =@: e_TK  _   U L    &	
+ #"&&5466332##5IIWWIIVZdeYwSrpTRqoUNJJ  d     @LK   M L    
+#_O d  M        7  !@ JLK  M L    
+##[d`Ob >       d  G      -      =@: e   ]LK] ML  
	  	
+!5!5!5p`h[VVUUWW  7}   ,@)_TK  _   U L    &
+ #"&&5466332#IIWWIIVZdeYSrpTRqoUN d  ?     d  % 
  0@-   e ]LK ML   
 	$
+ ###3654&##3yW_PWWQUSkjqn@SJB  (    5@2
 J 	I   ]LK ] ML    
+!!!55<YN>NNN           !  #@  JLK   M L    
+#3!`iXU  #      5@2g
	  g LK ML
+$#5&&546753654&'\\~sqsqpsqDD|FFxdhdaee^gf    /    #    .@+ J   ~LK   M L    
+#5$533665_^RZ[YTmu PN\NO   7  } ! /@,
 I _TK  ]ML   !  &
+ 3#56654&#"#53&&54663G:JnGAc[ZdCDhC:IVQml})PPv{~PP$mkT   O "   $  6  = " E\    6   " p\    6   " x\    , " E    6   #0      ,   "%G     5~ " x   S     !~ "0       d    @    e LK ML
+!#3!__-C    8  &@#~ ]   LK ML
+!#5####)Q_Q` d  G     76}   K JK.PX@ _ TK ]   Q L@   a _ TLY@&'
+$#5&&546632#"3}papIVWIeZdeYoUSr  7)
  @G  ]   LL!-
+6654&&'&&546633#"#0186ddFuwss!F;TRKS.# !)zZYRoFZ;"O:6O$  d    3@0 J    e] LK ML    %!
+32&&###!#/'__
FR     	 +@(I  f LK   M L   	 	
+#!'3jjU3U)    D   @	 J LK  M L
+!##'#'3D`d]U3`%XqYX  d+W   K@H 
J  ~  LKMK _ QL  	  	
+33%#"'73255#3d_PGA2%= lONLP&<J?pA      I@
  JKPX@  _  LK ML@   LK _ TK MLY$$
+376632&#"#inC52$" `=56' 6  ; #8        ~ "8      7}    d  %      7:  4@1  J   _TK _ UL    $$%
+ &&#"3267#"&&54663Y6/(K+]lk]4H*0]|YJNU $=;MSrqR >          4@1
	 J _TK  _   U L    #%%
+ #"&'73265#"'663JYFg,.&N4]k5Q,,3iBrS*#<<"" 7: "=  M 	3+  "?  MD 	3+   O "	      U "        "          "          "          "          #          #         W "        O "      7~ "        7^ "      B7 "      BO "	  "      BU "   "     B "   #       B "   #       B "   #       B "   #       B #    "      B #    "      6  S "r    6  _ "~    6   #     6   #     6   #      6   #      6  _ " E~    6  [ " Ez    6   "r    6   "~    6  R #     6  R #     6  C #      6  C #      6  s #/     6  s #/     6   " p~    6   " pz    dBD "      6B "r  "     6B "~  "     6BR #   "  +   6BR #   "  +   6BC #    "     6BC #    "     6Bs #/   "  L   6Bs #/   "  L   6  5 "r    6  A "~    6   #     6   #     6   #      6   #      6   #/     6   #/     6  A " x~    6  = " xz     *~ "   H   
  ^ "   9   , "  ^  , "  r  ,| "      , "     ,[ #      ,[ #      , "   t  , " Y    6   "~    6   #!      6  \ #!;     6  k #!J     6   #!     6   #0      6   #0        !~ "!        !^ "!      ,   "  %^  ,   "  %r  ,  | "  %    ,   "  %   ,  c "  %    ,  c "  %    ,   "  %   ,   "  %   ,   "  %t  ,   "  %S  7B} "%   #   ,B "  "%^     ,B "  "%r     ,B| "  #%    "   ,B "  #%   '   ,Bc "  #%    	   ,Bc "  #%    	   ,B "  #%   /   ,B "  #%   %    9$  " e@	J
GKPX@ _  OK _ UL@   OK_WK _ ULY@  "!  +
+ 73&&''#"&54633267&&#FPT7 #5	1s\dha/844+H?3KXL0)8~IjeeaXvqV  _*-  ( B@?& J
	 G  g _ NK _   U L('$!*&%
+ #"'4632654##732654&#"3t=f;RB\n`9\5RC M4
15B>4s3Y[f@b53bo-S8FR
JDF@A::Q0 (  
0+&547&&'7|W]
I;W1WB=%<=42?7!  9
 ! . 1@.(J _ NK _   U L"""."-%+%
+ #"&&547&&546632&&#"654&&'3]8iHEi:5+)P77T'/7"/-23ED=67BCsdEuE<rNKA-&A'9' I]X6H5"bJW[  9 & E@B  !J  g   _WK _ UL   & %%$!$%
+ &&#"33#"3267#"&547&5463=R#,7#0380=8>5;6(D!+%b6^qoeT7)&#*H)/(1: TKu\BN  &) # <@ J GK*PX@   ] N L@   U  ]   MY#"!
+'6654&&'&&54667##7!400<#KS'02*,SQIWR/i_/9$"2&7O$@+! d[D5J  K+  3@0  JHG   _WK ML    '
+ '4&#"#4&'7663Q\*)*@\T	S4WN78.0-e5N'&7,1  9    =@:  e_NK _   U L    
$	
+ #"&5463!&&#667!3vwopvxoCA@B-8@BK~~6xd~  Z  	 @ G   O L
+7&&53<1\&"E??  K 	  @	 H G   M L
+#4&'7&&''\T$$0!D[Le5N'	D"'(    @ H G   O L
+.''3.'7Z5$85'V(62Y)#>48bTf."6i+0<%	G  _+  -@* J GOK  _   U L"(
+$&&'5#"&'33273V	G+#-	[\OP1\PP' *8<.jY`l    	 @	 H   M L
+#&&'7JZo9P0X6!  2) 3 5@2  ,JG  c   _N L   3 2!$%
+ &&#"33#"'6654&&'.5467&&54663HS$.5!5280FB<F::<@"KS'02.1@L,\C9@.T884-07LK?,5'&2%6O$@* 2SAQ[	G8/K*  9   ,@)_WK  _   U L    %
+ #"&546633254#{8jIo|8jJR}ER}EJ  5  2@/  JG  ] OK ML    %
+&&5#"'663!=0\  +&&!E??C=H	K  U+
   ;@8 J
	 G _WK _   U L    %
+ #"'463654&#"3q0]B[/\mj8C=<D9<%L~JB $gbhchk{##  9) " %@" J G   _W L   " !%
+ &&#"'6654&&'&&5463NN$-4!@H780:#KS&01)+WUzl<b]5=("3%7O$>+!!lg~  90   ,@) J ] OK _   U L%4'
+'#"&5463254&'#"30~)48jIo|k)KT$	hGR}E|/Gg(WJ   '@$ J G  ] O L    %)
+&&5#'663!=0E'#+&a&"E??CH	K  Z  @OK  _   U L#$
+ #"&5332654'3Ci<Mf\/,6Q]Zx9\Sl76^k  A+  $ K@$ J GKPX@ _OK  U L@ OK _ WK  U LY()
+$5&&5467346326654&&#"Xy \!MS[OK ' (,wKJEJ`Xah,VHMW%7N -  	0+'&&'7][<O2Y)D*q_>6!/|n  P+  %@" J GOK  M L
+$5&5336654'3X\JXXXQ]EFG.a`  A & '@$JOK `  U L&%$$
+ #"&'#"&546733265573254&'3"hR8H	G>Od![ 22*-XTg \R~};:=8{SDUH[U2EwEV Z ' "   I *  "   LH  * "     Z' "       Z  "   L   Z "   `  9' "0       A' "   F   9$' "       9' "       K+' "        K    @H    e ML
+%!#4&'7!\Te5N'![L +  !@	 J G  ] O L%#
+##"'663!\_  +&trH	  _!   @	 J GOK   M L
+$&&5467#33;2o[kg"EIC'%Y5q~    4@1
	 J _WK  _   U L    #%%
+ #"&'732654#"'663E=qL4S'*$6&IR*=!,,S5TzA;_d: 9 "  M: 	:3+  "  M: 	:3+  9+   &@#G  _   WL%+
+$5&&54663254#"3e[V[e8jJo{cqR}E  9)B ( (0+6654&''.54677>52/,4I/ZS0%$Z&:6	CB9567 KS,"5XBYp 6:GD*7* 0%8O$  Z*  .@+ JG    a] OL    %%"
+32&&##4633#m#.'e\PGI
CILPK  
  0+'6677'7667%e& Q"&P`& Q"&K0MW*4_FXJMW*4_FW  ,G  @ H G  M L
+ '654'#&'#&'7hRZ&[$P"K@p\/*FJA  7+! % '@$ J$#"	H  _   Q L$%
+$#"'73255&&5467'4&'7QFA2$@c;2cg%pLP&:
J[8,&2Ql&"EIC&2  <   + G@D(J g_ NK _   U L     + *&$  %%	
+ #"&54663263&76654&#654&#"3N6hGzkK|GPF]YR\
%bYD3G*9%9Jw^>lB]I1Bj*U@WGQR  (  ( <@9   ~	  e _ NK _ UL('#%3"#

+##"&553326655#"&5466323&&#"7
#xMf\Y2@wsp2Z8o{(	GA19G@\SmB}]N0P/eb7,42 .+F _      1 4@1 *) J  ] OK_UL'$%%#&
+##"&'#"&5467#"'663!&'3265573265e!&/P11E	nJ_&!  CF{ !!X$+X)!(54qDLh3;:utsEp3H	l=;mA2E>9GW  7!  0+$&&5467'4&'7;2c;2cg"EIC&2Ql&"EIC&2  U(
  ) T@ JGKPX@ _   WK _ ML@  c _   WLY@)(,%-
+.'&&54632#"'32654&#BU,1ZQmjks0^AY19;Q9=$>D>;n(" PVtF{JEN))	7hkV$&gZW[  9  4@1  J   _WK _ UL    %$%
+ &&#"3267#"&&54663gQ),!8%HSRI&6$*'S4Lq==qL:fdd_;AzTSF,  "   M    9    _+ a    ++c  *@'J G   ~OK   M L
+!#'&&5#33cZxWp$X@wgqy'^5wqF<y  +
  # H@EJG  a	_ WK _UL  #"  #

+'3#5#534632#32654&#/\JJmjmq0]BQ9<%?C=<BvFDOFOL~Jhk{##gbhc 9$" "       9$" "       9$" "   n  9$" "   X  9$" "       9$" "   x  9$e "   i  9$f "   O  9$, "       9$, "       9$ "   O  9$ "   S   9$ "   V   9B$ "      9B$, "   #       9B$, "   #       9B$" "   #       9B$" "   #       9B$" "   "n     9B$" "   "X     9B$" "   #       9B$" "   "x     9B$e "   "i     9B$f "   "O     9B$ "   #      9" "       9" "       9" "   \  9" "   F  9" "   w  9" "   f  9, "     9, "       K+" "       K+" "       K+" "       K+" "   j  K+" "       K+" "       K+e "   {  K+f "   a  K+, "       K+, "       K+ "   a  K+ "   V   K+, "   #    V   K+, "   #    V   K+" "   #    V   K+" "   #    V   K+" "   #    V   K+" "   "j  V   K+" "   #    V   K+" "   #    V   K+e "   "{  V   K+f "   "a  V   K+ "   #   V   Z " "   R  ' " "   	   
" "     " "     %" "     
" "    Ie "    /f "     # , "     Z , "   J / "     "   S=   "   V.  *} "    *} "     3  & 2 < @	 J76GK&PX@%    g 	g_
NK OL@#    g 	g
g OLY@''  <;'2'1-+&%!  %%$
+&'&&#"'66323267##"&54632#"&5463&&5387#88"!!!!!!!!<<1\	
(0*,'!!!!!!!!&"E?? 9" "       9" "       9" "   ~  9" "   h  9" "       9" "       9, "       9, "       U+
" "       U+
" "       Z" "       Z" "       Z" "   {  Z" "   e  Z" "       Z" "       Ze "   v  Zf "   \  Z, "       Z, "       Z "   \  Z "   S   Z "   V   Z} "   `  Z} "   `   Z  & 2 G @	 JK&PX@0    g g_NK		OK 

_ UL@.    g g	g		OK 

_ ULY@$''  GFB@=<97'2'1-+&%!  %%$
+ &'&&#"'66323267##"&54632#"&5463#"&5332654'3L87#88"!!!!!!!!jCi<Mf\/,6Q]	
(0*,'!!!!!!!!Zx9\Sl76^k A" "   O   A" "      A" "       A" "       A" "       A" "       Ae "       Af "       A, "      A, "   G   A "       AB "   L   AB, "   #   L   AB, "   #G   L   AB" "   #O   L   AB" "   #   L   AB" "   #    L   AB" "   #    L   AB" "   #    L   AB" "   #    L   ABe "   #    L   ABf "   #    L   AB "   #J   L   B     B      6  7	 JK.PX@cK  e L@  ]c LY+%##33(^^etoa|<T >+     ,   @
JKPX@  e   c _LKPX@# g  e  W _   OKPX@  e   c _L@# g  e  W _   OYYY@    !$+#"&5473&#"'637#3HJ@=G=)%/=9}HDBLGC=-=  / 
   dKPX@   c_K ] L@g   c ] LY@   
 	#	+ #"&54633&&#67#3/@KF@CG$# ^dc]ac:3>@16;:7  7   LK1PX@_`K  _   i L@g  _   i LY@    
$+ #"&546332654&#qqooqqoA??A@@@@I  #  C  9 JKPX@`K   a L@ ]   a LY@
    +#'7C\(c;_A      Q@  JK1PX@ _`K   ] aL@  g   ] aLY@    '+ !!5>54&#"'663 [27rt-up0<2)>#<)d>0S4=ptMI`74;"'032   ) h@'&JK1PX@  g _`K  _   i L@ g  g  _   i LY@   ) ($!$%,+ #"&'732654&##732654&#"'63Y/G;CT8hD=f&7!E)?HDA2"4E<3'A"0Uj.N.=OTH:^5--3" G<B6G>8/7 7O  (    2@/ J	H  e ] aL    +%##5!5373WYMPIB g    m@JKPX@% ~  g   ] `K _ iL@# ~    e  g _ iLY@
$%%"+!632#"&'732654&#"#!38Vh:iE=`)6 D+@IB8,HjUqcBg9+*5 PIIBQ  7  # o@ JK1PX@ g _ `K _   i L@  g g _   i LY@  #"  #%&+ #"&546632&#"63654#"3gT29a;ul=rNL>$/8HT>c>l,J?B0`EGm;m[)=tXXK1+nh    B@
 J GKPX@   ]` L@  U ]   MY@
    +'!5TE@K  -  ' 5 V@	/!JK1PX@_ `K _   i L@ g _   i LY@(((5(4'&,$+ #"&&5467&&546632&6654&#654&&''3;jCDh9CA539]54]:8:=;A-(;6=I>820H>.{7W10V7>TM46N(&M62H6202:*/8@5$1%	I67=  -    ]@
J GK1PX@   c _`L@ g  W _   OY@     ,+ '667#"&&5466376&#"3mnJN14T1:a;E6;@;@<3yc&E&l$,5aADd5SoaNHFG  2  =@:J ~  g   ] :K _ BL$#%"	+!632#"'732654&#"#!6?Vg:lGvU6ASCKA8. HsisfDi:U5?QMLD[ .-b r  6 	 63+ A6 s  6 	 63+ 76X t  6 	 63+ 4-\ u  6 	 63+ *6e v  6 	 63+ 4-\ w  6 	 63+ 1-_ x  6 	 63+ C.M y  6 	 63+ *-f z  6 	 63+ 2&^ {  6 	 63+  .b   *@'g  _   B L    
$	+ #"&546332654&#NNLLNNL&##&&$$&oiippiio;HUVHHVVG  A    !@ J ]   ; L    	+#'7Mb"_R95S  7  X  .@+ 
 J  g   ] ;L    '	+ 3!5>54&#"'63K!JHTH$&17UD4"?PA>:QM6"&D  4\ % C@@#" J g  g  _   B L   % $$!$#*	+ #"'732654&##732654&#"'63I.(,8UHW4-&4%+)'"	 ($*(:L<-&2
4.7I<*)&!$8!,4  *  e  2@/ J	H  e ] ;L    	+%##5#5373e5LBqjD<``6ii  4\  >@;J ~    e  g _ BL##$"	+#632#"'732654#"#53A!"8EXHP8.%3&,H9ghH>AP:+(+)N  1_   F@CJ  g g _   B L    #$$	+ #"&54632&#"63654#"3ES@PK^R5)!+3)<	#?/""'H@BUk_i~1H@/1*Q-C<  CM  *@' J G  U ]   M    	+'#5MG7T=  *f  ! - 2@/(
J g _   B L"""-",! )#	+$#"&5467&54632&6654&#654&''3fXGGV+)BR;;QHb#!$!$*$/6*$I4ED4%4"@1<82;#!#!9"  2^   ?@<
 J G g  W _   O    ,	+ '667#"&546376&#"3N5kZVZ14FV?(!&"&#WJUlA8G=J>@L-?6+')' .br   	 3+  A  !@ J   ]: L    	+#'7Mb"_R95S  7X  -@* 
 J    a _AL    '	+ 3!5>54&#"'63K!JHTH$&17UD4"?PA>:QM6"&D  4\ % D@A#" J    c _AK _ <L   % $$!$#*	+ #"'732654&##732654&#"'63I.(,8UHW4-&4%+)'"	 ($*(:L<-&2
4.7I<*)&!$8!,4  *e  2@/ J	H  e ] <L    	+##5#5373e5LBqjD<``6ii  4\  ?@<J ~  c   ] :K _ CL##$"	+#632#"'732654#"#53A!"8EXHP8.%3&,H9whH>AP:+(+)N 1_x   	 3+  CM  $@! J G   ]: L    	+'#5MG7T= *fz   	 3+ 2 ^{   	 3+ .9br  B 	 B3+ ABs  B 	 B3+ 7BXt  B 	 B3+ 49\u  B 	 B3+ *Bev  B 	 B3+ 49\w  B 	 B3+ 19_x  B 	 B3+ C:My  B 	 B3+ *9fz  B 	 B3+ 22^{  B 	 B3+ Y+   0+';j< A "}      Al "}   #   t   Ap "}   #   u   7p "~   #   u   Ay "}   #   v   4y "   #   v   Ap "}   #   w   7p "~   #   w   4p "   #   w   *p "   #   w   As "}   #   x   4s "   #   x   Az "}   #   z   4z "   #   z   4z "   #   z   C> "   #T   z    g  *@
	 GKPX   b L   tY+''7'7'37hHONHgZ1!t54u!R=?  i'   0+O'}  2  |  @  W _   O    
$+#"&5463((((|())(  2   @  W _   O    
$+#"&5463@@00@@0A00@A00@ 2  "    p 	p3+  &Z    %@" J  W ]   M    +6#7&&5463(CB((((
( ' ",   ,    2  #    #       3    ,@)   ]`K_ iL  
  +##"&5463
QR((((5())(  36    PK.PX@   g] eL@   gU] MY@    
$+#"&5463#(((()f
)(()?       KPX@(e

`K  	]		cKaLK1PX@(
	
e  	]		cKaL@&
	
	 	 feaLYY@+#3##7##7#537#537337337#LCMNN@JAJNNCEEF  2    @ _   i L    
$+6#"&5463((((())(    ( <@9 J   ~ _hK_ iL  ('#!  *+ #546676654&#"'63#"&5463*W,& **[(!&$6/P;?T|((((+H)'7"1)-2+<$( )-H1c())(  )  ( ;@8&%J ~   g `eL  ('$"  
$+&54632#&&5466766553327#((((]W,( ))[(!&%6/P;?T|d())(+H)(7"/').*:#) )-H1c <S "        <   @ ]   `L    +3Kc &Z  "    p 	p3+  i'   0+'QNO'  2,  #@  J G   ]c L    +'!5TGdzM  r  &dD@   U   ] M    + D5!OO   ,  @
H  _   e L$ +#"'73267(GUUG(5.++.6 s4  1 	 13+ s4  1 	 13+  xD  2@/J    g  g W _ O+"3"&554&#526554633,$'(#,3dR''Rd%3-*3%GEP*"L$*PE  -x)D  8@5 J  g    g W _ O    +3"#52655467&&554&#5R''Rd3,#('$,3DEP*$L"*PEG%3*-3%G  A0  (@%   e U ] M    +#3#xx0ML  20  (@% e   U  ]   M    +#53#5xx0\LM  s  0+.54667.++.1'//'F~\\~F!9TnFFnT9  s  0+'6654&'7//'1.++.1TnFFnT9!F~\\~F! s    	 3+ s    	 3+  (oM  	0+.546674=##=4:BG11GB%Mygf{L(^yooy^  (oM  0+'>54&&'7G11GB:4=##=4:yooy^(L{fgyM( s    	 3+ s    	 3+   `  @   U   ] M    +5! NN   `  @   U   ] M    +5! NN  &t  @   U   ] M    +5!&NN  `     <W`  @   U   ] M    +5!<NN  <W`  @   U   ] M    +5!<NN 7 ' "       7 ' "        7 '   0+'577&&?  7 '   0+'7'n7?& (dj k "        ,n   L JKPX@ ]  bL@  U  _ OY@    +&546773#2&546773#R&
C<('&
C<('%%%% (j '     3+3+  ,   < JKPX@ ]   bL@   U   _ OY@
    +&546773#R&
C<('%% (    	 3+  (d  k  %@" J  W ]   M    +6#7&5463&
C<('k%% 2  |    &Z  "    p 	p3+ j 6 
 I@  J
HKPX@     ] b L@     U  ]   MY+'7##3'I77+_o+6HH	77 j 6 
 I@
 	J HKPX@   ]   bL@    U   ]  MY+3##'I+o_+76	7t|7	H j D/  @
	 H   t+'#'7'766911966/691q1966 j   .KPX@   bL@
    tY@
    +#|  de%8   % 
!	0+$#5#335332654&#654&##3%PPH5EUe;JNPbVSCn\;MIN93;-1CB:  9f  .@+ J    a ] `L$&+%#5&&546753&&#"32678?PZfgZOA6,5 @GFA4 .-
ss	-:fdd_  7e8 # * 0 e@-,*#"
 JK1PX@  _ `K   i L@    h   i LY@
/+$#7&'#7&&5466773273&'667$&##&_=<<:A:e@<<$%2P%:!. SP^*F4<**h`W;	 : {E|j   XS  ' j@!
 JH	 GK1PX@   c _ kL@  g  W _   OY@'&+,%+ '#"''7&547'76327654&#"3%L7N5CB4N5N$#M7N1CE4O5L%??<;??;6K7L #O7N5CA6P7P"!O7M4FHAAHI@AH  e8 , 6@3JI     g _ iL'#+$#5&'732654&&'&&546753&&#"`UP{R6Hd?Q>:g_bPP0M#5"I+5C><?T3nhP;F>9!," WJF^	%!: 1.'!.N<  >SF  % ) @JHKPX@*  e 	
	
a _ cK_aLK!PX@.  e 	
	
a _ cK aK_ iL@,  e  g 	
	
a aK_ iLYY@&&  &)&)('%$   %#+##'#"&5466325#535675&&#"35!FOQ	N0_h2^?O?\<:%=C>:nBE&*wMwD=}BF
<$& "a`a_EE  
+_ ' 6 CEKPX@@ 0 J21 GKPX@@ 0 J21G@@ 0 J21GYYKPX@% ]	`K _
kK `  a LKPX@- ]	`K _
kK  ^   aK_ iLKPX@+	 e _
kK  ^   aK_ iL@2 ~	 e _
kK  ^   aK_ iLYYY@77((  7C7B=;(6(5/- ' %5$$+ ##5>5376654&&'#"&&54633#"'463654&#"3#"^(k`x>`A6		@LFq0]B[/\mj8C=<D9<%I/+V29rip&2! 27CL~JB $gbhchk{##  ' % @  JK1PX@)	e
 e _ `K   _ iL@'  g	e
 e   _ iLY@%$#"! $"%!+63267#"&'#735#736632&&#"!#3#PK'A$&H,gXFUJ_cS$&@({$ OP|w=Z>p{8?>Z=  ,  [@ JGKPX@_ bK ]  cL@  g ]  cLY@    #+3#'>5#5354632&#$
v$E>'*TTWN$9!-/%'IGXIX7C#?7GHDSC   4 }@4JK1PX@)e	
e _ `K  _   i L@'  ge	
e  _   i LY@20,+*(%%!+%#"&547#5367#5!6654&#"'66323#13!3267YpG">BB4+J&3.`B=_6"h'C!Q?4S)JVjX(;<'.29'&+M24"<;/9:"!  (    K@
	JKPX@ `K  ^   a L@   ^   a LY)"+%##5'75'753773267!~i8Q6Q[DHX VW7&J9%L8YKM8X7D    ~   # ' , @
	
,JKPX@*	 	 fe

`KaL@*
	
	 	 feaLY@&$$+*$'$'&%#"! +#3##'##5#535#53533533$3'3'#5#&'#~HHH|xVHHHHxwWH4;EoV(rc=Ik4;;4<<<4444V/  (     jKPX@%	 g  e

] `K aL@# 

g	 g  e aLY@$!+73##5#535#5332##32654&#[KKKK~y=9SWWQ=oo=JFaigni`?QIA  <    
0+#3###53267!5!&&##5!8SMJHq|pHKLDe_?>GXI:C>+(E  9  S4  & C@@ ~ |
	e  ^  a L  &&"   !+#467#5!2#54&&#%#!332665\AEVj5]!B5'jd[<A9,@V"P&_T<APN\/}:9[  (   ! b@ JK1PX@ e _ `K   ] aL@  g e   ] aLY@%#+6!!5>55#5354632&&#"3##@[#"BBdY7X$<6%158MI/+u<oSg)*.95p<v      " & * . 1 4 KPX@1
 	 fe`KaL@1 
 	 feaLY@8++##  4310+.+.-,*)('#&#&%$"!  +3#3##'##'#53'#53'3373373373'#7#7#7#22>IU3v78s3TH=12Z-6b7/=
\<oW
u&E!G<4;;4<l<4444444      k 	JKPX@!  fe
		`K aL@!
	 	  fe aLY@    +3#3##5#535#533q^rf>Z==Z>C' 2  |   Y+     J TGE  -@* U  e] M    	+3##5#535[[G[[EYAWWAY  J F   @   U   ] M    	+753JAA  J pF(   /@,   e U ]M    	+75353J??y?? 2  |    JF Y  1 	 13+ JFc  ; 	 ;3+  JF   @   U   ] M    +53J$AA JF'  ; 	 ;3+ JiGZ   	 3+ JF   	 3+ JF=   	 3+  >   '@$  e ]cL    +3##5#535#TLL  >&s  @   U   ] M    	+5!>x&MM  H    0+''7'7t8xx8x|8xx8x9x|8||8x|9} > #w '  / '     /3+3+ >  & _   _3+3+  > =T  5@2HG  eU]M	+#3#'7#537#5373vDP3?LzEN2=HtMjMtMg  2 s'   0+'%%So!G'^J  2 s'   0+%5!G!'LJ^ 2  E &     3+3+ 2  E &     3+3+ >   '    3+3+ #  &
 
 d  3+d3+  #   <dD@1 J  W    g _O    $#$+ D$&'&&#"'6323267#"+'!82W*$7/W6a[  > i  %@"   U] M    +#5!5SiM  T0  ! + 
("0+ #"'#7&&54663273 &#" 6654&'3Fbdn\(GB9?cdfT"G:1,iFPTQP72LZFUea;7Z2Peb2.Or+(STRTFz+1  7 lH  ' 3 A@>0
J
	  c_<L((  (3(2.,'&"   &$&	+ #"&'#"&&546632663 67&&#"3654&#"3Y,,Z@;f"#_A@Y,,Z@;f"$_@G!I8/::/::/4E$J89^99^8E:<C9^99^8D;=BFC4KF>>FF>>FDD4L +T  2@/  J   g _ >L    %%$	+ &#"#"&'73265463D8!--'ME$2!&!OITB&'GIC$!KL 7  } %     A     9+  ; GKPX@  ] : L@   U  ]  MY	+###5!CZZHQ&&L  2    V@
 J 	IKPX@   ]:K ] ;L@   e ] ;LY@    	+!!!55(mN*NN N  *  T  %@" J   e ;L    	+##7hQTM{ _+       ! /@,JH  g _   B L! *&&	+#"&&546632&&'76'&#"3G5cB:a93V5.Iz?,X0?A7lP|E4eF@c5+#j$Cde]HDJP  -    & 1 @JGK1PX@)    g
g	_`K _ iL@'	g    g
g _ iLY@"'''1'0-+&%!(+'#"&54633254&# #"&54633254&#e@1@[[HG[[G,%%,Q$-ZZHH[[H,%%,Q$-*D*\MM\\MM\></.=k.=\MM\\MM\?;/.=k.<  -w    & 2 = H @JGK1PX@/    g		g_`K
_iL@-g    g		g
_iLY@2>>33''>H>GDB3=3<97'2'1-+&%!(+'#"&54633254&# #"&5463 #"&54633254&# 3254&#e@1@[[HG[[G,%%,Q$-ZZHH[[HZZHH[[Hj%%,Q$->%%,Q$-*D*\MM\\MM\></.=k.=\MM\\MM\\MM\\MM\?;/.=k.<;/.=k.<  JG v  -@* U  e] M    +73##5#535[[G[[vYAWWAY JG  ; 	 ;3+      0+''&'#&7997&Z("=="(  z }  0+'767!5!&&''7C'CI9+P9  {  0+%67773&77&Z^("=="(  p 
}  0+!!'CDP+944  <@    0+&5####73'3,,kk*,#  ( e   0+463!55!"&57!7'(*,Goo  <    0+ 334633#7#kk*,#  ( e   0+$#!!2'!55!*,G,,oo      	 <@
	 JKPX@:K   ; L@ ]   ; LY@
    	+#?k5PMC  `      0+!#3s1O\  F+ 5 ? Z@W87	) *J  g _
hK	 _  aK _ eL66  6?6>;9 5 4$&$%$$%+ #"&'#"&546323254&&#"327#"&&5466375&#"3bda8?	G6P]xb*J)""jLknXUr_a8c?ss)!!&0.kk>),9xd~>3aOcoo_"GoyVKN  Q  + 5 D@A54%
	
 J G_hK  _   i L    20 + *  + 67'#"&&5467&&54636654&#3267'dS.KB(V#6pBa+lFBe9FE2/_T)0&)342*P0M?/L#'F+;U'QXtQi6^//.U8>],0L0DWD0&$9'=%*/E,7>$$  Z)R  &@#G     ]` L    +#&&5463RSrSqor?nXaj  F / @ V@=4/  JK*PX@    c _ `L@  g   W  _   OY@	$"$#+$#"'732654&&'&&5467&&54632&&#"&6654&&'&'lWaG#A),835SH)$hSaJ#!@(-243SIL'8+$--# =CO2="@9$?1"CM6:#B5E3r$(*  \ y   8 cdD@X".#/J	g
 g  g   W  _   O     8 720,*&$  &+ D #"&&54663326654&&#&#"3267#"&54663SSVVTTVHsBBsHGsBBsG&6#&()21*' 4CJZ,J-QZZPPZZQ4BxLLvBBvLLxBG/@B?@0.dZ<V,  C >   , 4 cdD@X"J~
 g  		g  e  W _   O  42/-+)('&%$#  &+ D #"&&546636654&&#"36#'##323254&##uCCuGEtCCtE:[33[:8Z33Z8m$JC=9Nz6EvFFuDDuFFvE15^;;_66_;;^5'	sjjT**  #*,    0+###5#'&547####33tyM	K	ZCcHi[Sl@G@y !%*  7}   8dD@-    gW_O    &+ D&&546632#6654&#"3K..K++K..K+%22%%23$}&I11I&&J11I%>2//32//3   '  @    t    +#S's   '   0@-   eU] M    +##SSS'll  ~  ! 0+67#"&55'7463236654#!(3;6!WO@>F4,-@@=7x*-D%PRH:n'(;pCB  *    LKPX@`K ]  cK aL@ ]  cK] aLY@    +3###535+XMCM  *    ^KPX@!e `K  ]	cK aL@!e  ]	cK ] aLY@
+#3##5#535#53533XXMMM  Gk    0+ !32673#"&&54663!5&#CopMK(:8fqilmU']`l-43/BH^gga(50e  d  *   $ ( O@L
J  g]
:K  ]	  ; L%%%(%('&$# %	+!##3&&53 #"&54633254&#5!GY|
Y~eg[\fh[dcc11xIEuS6xob_rpa_rEHDMM  (H  'dD@ J   t    + D#'#7baH9  <@     @

 0+7##'3'3##"&55!35,,/kk**u*QQ  dt    0+&5463!2#!777'7''TCCCCqCCEE  dP 
  0+!2#!777'7''d|>CCCC`iCCEE  dP 
   0+&5463!!777'7''>|CCCCqCCEE  x<   / ? O _ o        &6 SA(,'                 u p e ` U P E @ 5 0 %         0+&5463!2#!3326554&##23326554&##23326554&##23326554&##23326554&##23326554&##3326554&##23326554&##23326554&##23326554&##23326554&##3326554&##"32$3326554&##23326554&##23326554&##23326554&##23326554&##3!26554&#!`JJJJJJJJJJJJJJJJJJJJ6^JJJJJJJJJJfqJJJJJJJJJJJJJJJJJJJJJJJ^JJJJJJJJJJJJ   z   0+ 6332#!!7#!55!w */w13*+oo  (xk  ' @@= 
g	  e  g _ BL  '&"   "%#	+##"&5466323267#5$6654&#xp	dDvJ8U.iahJ(t/,Lpr\K+I.dm	YTLB8gE
L@'-  2    *@'   g_ iL    
$+#"&5463#"&5463$$$$$$$$$%%$$%%$  (J   ;dD@0 J  W ]  M    + D#7&54632#7&5463#	<6$##	<6$#!!!!  >	N  &dD@   U   ] M    + D5!>R	EE  >   5dD@* U  e] M    + D3##5#535LDD  #9  9dD@. J    W `P    "+ D&555733267#JxvW@$2D9F>@L>FF;&  >    /@,   e U ]M    +5!5!>RR^EEEE  )  N@ JKPX@  _   L@   W   _  OY@    %'+5'&&54632&&#"-,QA$6)#!($*0.7B*    :  ,dD@!    U  ]   M    + D3#5!nCO    :  &dD@    U ^ N+ D3!53JOC    :  *dD@   U  e   ]  M+ D3##53JJOC    :  *dD@   U  e   ]  M+ D3#5#53JJOC    :  *dD@   U  e   ]  M+ D3##53JJO7C  > j  0dD@%   U ^   N    + D%!5353jv?;;     <      <{    @    t    
+7#Ucs  ">   JK	PX@  _    LKPX@K  _    LKPX@  _    LKPX@K  _    LKPX@  _    L@   W  _   OYYYYY'%+#"&547'373&'325&##'$kS>=R(!!+,     4dD@)  W _  O    
$+ D #"&54632#"&5463!!!!!!!! !!!!!!!! a  'dD@  W _   O    
$+ D#"&5463B$$$$$##$ ~!   0+'!r1V ~!   0+'G)!MV1 z@    0+'7'N`:Nj:@)) z  dD@ G   t+ D'73''=(~z-qq-T s  dD@ H   t+ D#'7E'=(~-qq-T   -dD@" H   W   _ O    
$+ D&'7327#S=DG=U>G>LL>G pD   7dD@,g   W  _   O    
$+ D#"&546332654&#^@@22@@2D=--==--=2   <dD@1	 J  W    g _O    %%$+ D&'&&#"'66323267#87#88"
(0*,    dD@   U  ]   M+ D!5!E cN  2dD@'	   J     W  _   O#%+ D6654&#"'632#' )539*'E31*%+: rZ  &dD@   U   ] M    + D53uWr z@    0+'7'V:jL:`@) f  .dD@# G  W _   O    
$+ D&#"'663yU=GD=S=G>LL>G jG"  ,dD@! J   U   _ O    + D&546773#u!)5"G   Vt jG"l  o 	 o3+ 3   0+'1k1O 3   0+'F(1MO1   *dD@   U  e   ]  M+ D3#5#53^@@?t9   1dD@& U    e] M    + D3##@?u9t" +R  FdDK
PX@ o   U   ]  M@    U   ]  MY+ D3#5#?x~ \_  dD@ H   t+ D6654&'7H?=!137 p  *dD@   g   W   _  O+ D"&54635"32@@22=--=Gx 	 3+   (dD@     U  ]  M+ D##5#5!w?v,;8 	 83+U8 	 83+ +   6dD@+  J     W   ` P    $+ D'732553#2$@\QF&:
JB:LP a9  &dD@   W   _ O    
$+ D&54632#{$$$$$##$@L   	 3+T  | 	 |3+ j  -dD@" J  W ]   M    + D#7&5463?!)5"M   Vt     8dD@- 
	 J  g   W  _   O$%+ D#"&'732654&#73{0-F60!*/;8/"044s  !  %dD@ H   W   _  O#$+ D#327#"&5467G48"	#9D\a50F9,7P   &dD@   U   ] M    + D53W   QdDKPX@o   U   ]  M@   U   ]  MY@    + D5!#5#?ZZ d;  ;dD@0J  W _  O    ""$"+ D#"&'#"&'73267332679)/0)7,C@>G(%%(G>#$#$  , 	 ,3+   dD@ G   t+ D'73''=(~-qq-T<Z   	 3+HU   	 3+ S   dD@   U  ]   M+ D!5!E HS   dD@   U  ]   M+ D!5!fE@  
  ` m  `    q  0dD@%    g W _O    + D654&#2#]@@2=--=22   IdDKPX@  n U ^ N@   U ^ NY+ D3353!??[ZZ    2dD@'    e U ]M    + D5!'35#6@ d<  <dD@1 J  W_O    """+ D&&#"#&&#"'6632663[9.C,7)0/<G>$#$#>G(%%( XF  -dD@"	 J  U ]  M+ D#'#7'373aW;9UaWV1.S[[~pMM,O    aN  &dD@ G   W  _   O$"+ D&&#"'632&GUUG(a.++.5 G   0+''77ulvu)>>-aNN9 M  ,dD@! G  U ]   M    + D#'7$EX.o ~   ,@)  W _  O    
$	+ #"&54632#"&5463!!!!!!!!~!!!!!!!! a  @  W _   O    
$	+#"&5463B$$$$$##$    0+'k1O    0+'F(MO1     0+'7'N`:Nj:))   @ G   t	+'73'(='-nn-Q   @ H   t	+#'7E'=(~-nn-Q ~  %@"	 H   W   _ O    $	+&'73267#T=B"/=V=D7B#7D    /@,g   W  _   O    
$	+#"&546332654&#^@@22@@2=--==--=2   4@1	 J  W    g _O    %%$	+&'&&#"'66323267#87#88"
(0*, ^  @   U  ]   M	+!5!E   *@'	   J     W  _   O#%	+6654&#"'632#' )539QEO32+G0     0+'7'V:jL:`) \G  @ H   t	+654&'79H?={-!137 j  %@" J  W ]   M    	+#7&5463?!)5"M   Vt     0@- 
	 J  g   W  _   O$%	+#"&'732654&#73{0-F60!*/;8/"044s G   0+'77')uvlU9NNa-> `  ,dD@!H  U ]   M    + D#'77qEp>h `  $dD@H   U  ]   M!+ D'#537qpEh M  $dD@ G   U  ]   M+ D'#53${.XE 3 ^,    2M   &dD@   U   ] M    + D'3n<=M  2      2dD@'   e U ] M    + D'33#n<==M  K R  ,dD@! J   U   _ O    + D&546773#D&
C<('K%% < "       ~! N,   c N W   3 ],    <   dD@   t    + D3<Ucs  p D  *dD@   g   W   _  O+ D"&54635"32@@22=--= ~! O,    u o    r uZ X    ~! O,    A    0+7'v2S
 M Sk   sj R    ,   M~ k   j       m   j    c~L ~  ~3+  M  ~  ~3+  ,   PPn ~  ~3+ /^VM ~  ~3+ T  ~  ~3+ lU ~  ~3+    m   zj Q   c  L     M    ~! N,   zP@ Pn    A 	   0+'H-	/      0+'H-/ / VM   A ! n*   pD T    l U     <dD@1	 J  W    g _O    %%$+ D&'&&#"'66323267#87#88"
(0*, B  ZdD@

 JKPX@   n W `P@    W `PY@    "+ D&5533267#;O*".590.,*	/#     @ J   _A L    	+#7&5463u!)5"   Vt      @ J   _A L    	+#'&&5463o"5)! tV     (   @ J  _   :L$	+&54632#'7;"!)5FS/N    V  -   %@" J G   _: L    	+#'&&5463'o"5)!/<F tV     (   @ J  _   :L$	+&54632#'7;"!)5</SN    V  (   %@" J G   _: L    	+#'&&5463'o"5)!~SF< tV     l  ( :@7	 J g  a   _ A L  ('!  %%$	+&'&&#"'66323267#&54632#87#88"S ! 5D
(0*,p    $  l  ( C@@	 'J g a   _ A L  ((#!  %%$	+&'&&#"'66323267#'&&5463287#88"B ! E
(0*,$    >      0+'~%AD      0+'C`DA  T '  dD@  H   t
+ D#!b#B'     @  H   t	+#!b#B  pc    BdD@7 H   ~ W_O%
+ D#&#"&54632#"&5463U97!!!!!!!!!!!!!!!!  G "  -dD@" J  W ]   M    
+ D#7&5463r!)5""   Vt  G "l o 	 o3+  G "  -dD@" J  W ]   M    
+ D#'&&5463o"5)!" tV     A("   3dD@( J G  W ]   M    
+ D#7&5463'u!)5"/<F"   Vt   A*"   3dD@( J G  W ]   M    
+ D#'&&5463'o"5)!/<F" tV     A("   3dD@( J G  W ]   M    
+ D#7&5463'u!)5"xSF<"   Vt   A%"   3dD@( J G  W ]   M    
+ D#'&&5463'o"5)!{SF<" tV     Ale  ( HdD@=	 J    g g W ] M  ('!  %%$
+ D&'&&#"'66323267#&54632#87#88"S ! 5
(0*,p    $  Blf  ( QdD@F	 'J    g g W ]M  ((#!  %%$
+ D&'&&#"'66323267#'&&5463287#88"B ! 
(0*,$    > pc}    pc}     pl  & 2 [dD@P	 J    g g
	W
	_O''  '2'1-+&%!  %%$
+ D&'&&#"'66323267##"&54632#"&546387#88"!!!!!!!!	
(0*,'!!!!!!!!  S ,   0+'~%AD,  S ,   0+'C`DA,  l  <dD@1	 J  W    g _O    %%$
+ D&'&&#"'66323267#87#88"
(0*, (    	 3+  M  =
	 HK*PX@ _   AL@   W   _ OY@
    %	+&'73267#wS=
+$$.
=U>?6 6?  Mx  %@"
	 H   W   _ O    %	+&'73267#wS=
+$$.
=U>?6 6? +B   6@3J  g cK _   e L'$%+&&'#"&54632367&#"3,8VE;FPD$\88%!M8bIJ;08?f0490  pc}    S@ JHKPX@  _b L@  W _  OY@(+'#"&54632#"&54638&-!!!!!!!!}6~#
!!!!!!!!  pc}    S@ JHKPX@  _b L@  W _  OY@(+'#"&54632#"&5463qv&7!!!!!!!!}#~e!!!!!!!!  o #   0+'8&#6~#  ,o #   0+'dv&##~  l   0+&'&&#"'66323267#87#88"
(0*,  pj    Y HKPX@   _bL@   W_OY@(+#'7#"&54632#"&5463C'=(~P!!!!!!!!-nn-QP!!!!!!!!  c    7@4 JH  W _  O(	+'#"&54632#"&54638&-!!!!!!!!6~#
!!!!!!!!  c    7@4 JH  W _  O(	+'#"&54632#"&5463qv&7!!!!!!!!#~e!!!!!!!!  j    9@6 H   W_O(	+#'7#"&54632#"&5463C'=(~N!!!!!!!!-nn-QP!!!!!!!!    d  #@   ] `K] aL+#3!53#5!dttssFcPPN  >+ $ 1 @('	 JKPX@+ _ bK _ kK	_ iK _   e L@)  g _ kK	_ iK _   e LY@%%  %1%0,* $ #$$%%$
+67#"&55#"&54663254632&&#"3&67&&#"3N$2AFQM/^i2^?S;PGA2$@@<;%=C>:
:&PL'+}Q~GE|LP&;JeJ''"#fefd  n # / KPX@ ,+! JH@ ,+!JHYKPX@*  g _ hK _	kK
 _  i L@.  g _ hK _	kK aK
 _   i LY@$$  $/$.*( # "#%#"%+ #"'#&#"'63257327#"'63654&#"3j2^?S9	Q*!82W
\+7/W9\E@;F5="R}EF:f6a,f0[iN"chk_R!&  9 $ 1 @$  ('JHKPX@)    g _ hK _ kK	_aL@-    g _ hK _ kK aK	_ iLY@%%%1%0'%##%#!
+#"'#'#"&5466325&#"'6325327 67&&#"3/WQ	N0^i2^?Q=*!82W
\+<;%=C>:[I(-}Q~GA6a7[0''"#fefd    + @(
	) 
JKPX@-  g  g

	_ 		bK ]  cK aL@+ 	
 	
g  g  g ]  cK aLY@   + *&$"$"+ 3#3267#"'#&#"'6325#5354632&#$
v$7/W\'!82W^^WN$9!-/%'IG}['
6aQGHDSC     % - 5 @4,
5.-&%$	
	 JKPX@%   g 	  	 g

_cKaL@)   g 	  	 g cK

_kKaLY@20*(#"$"+$#5'#5'#5"'66753632663227%54#"54#"z:'\\\"5	:'O;]1EK3AN"5J(6J'68,(8MY2-.1WJ~,Pf./D3nf-0b    r  ) y@()!	 JKPX@"   g    g _cKaL@&   g    g cK _ kKaLY@'#	+$#5&'&'#5'6675366326754&#"i9'\2f,\!5	9'OS2HQ!5Y*)*@8
+(8N*0VK~+m8.0-D + $ / @(' JGKPX@'  g    c
_cK _	iL@+  g    c cK
_ kK _	iLY@%%  %/%.,* $ ###%#$+'327#"'5&#"'63236632#3254#2+7/W\*!82W	OR-e^lc2@<$w<p

0[3r6a'G(+|.$!     $ KPX@"	 J!H@!"	 JYKPX@"  g    g_cK aL@&  g    g cK_ kK aLY@   $ ###"$$	+ 3267#"'#5&#"'632536632&#X<$7/W\'!82W	O	H0HL[
6ak;<Z     " K@H 
 J   g   g _ kK aL   " !$$#"$+ 67#"'#5&#"'63254632&&#"3I$7/W\'!82W	QFA2$@[6a7LP&:
Jm   3 8@5#32/$	
 J _ kK  _   i L(&!#%+ #"'732654&&'&''67&546632&&#"667"$yWxO1CQ4=64 :!#1W66V''$A$-41@%:	$<NRE83+%!
/$7)C%:%  $	   * Z@W"!&	 	JH  g  	g]cK
		 _   i L   * )$"$#+$7#"&55&#"'6325#53573#3267#"'3H'#4BCK'!82W\\\}
s$7/W"@=$MI|6atGwG[F)%      K@H
	 J  g   g ] cK   ] aL####+7!!57&#"'6327#5!327#"'
*!82W_d
+7/W MME6aNF0[      7  ^   8 I                         2  e          6  N          :  R  j            /  Q  B  Z    -  `            ]  u    	m  
2  
                             :  J          0  H      l          1  I  4  L          8  P  h                          A  Y    4  L    c  {      $  <  T  l  ;    b    M                k                 !  !.  !F  !\  !t  !  !  !  !  !  "j  "  #  #'  #d  #|  $  $n  $  $  $  %  %  &  &%  &}  '%  '=  'U  'm  '  '  '  (%  (  (  (  )  )  )  *  *(  *@  *X  *p  *  *  *  +L  +  +  ,  ,  -O  -  .  .,  .D  .\  .l  .  .  .  /
  /=  /p  /  /  /  /  0  05  0M  0e  1  1  2  3s  4o  5  5  6  6  7  7?  7  8  9`  :a  :  ;  ;  ;  <  <M  =o  =  =  >  >  ?)  ?  @  AI  Aa  Ay  A  A  A  A  Bt  C  C  C  C  D,  DD  Ei  E  E  E  E  F  F  G  Gp  G  H  H.  HF  H  H  H  IR  Ij  Iz  I  J  K  K^  Kv  L   L  L0  LH  L`  Lx  L  L  L  L  M
  M"  M:  M  Nf  OT  O  P  Q  Q  R  R.  R  S{  S  S  S  T%  T  T  UL  Ud  U|  U  U  Vf  W
  W`  W  W  W  W  X  X(  X  X  X  Yq  Y  Z  Z_  Zw  Z  Z  Z  Z  [`  [  [  \  ]  ]  ]  ^  ^p  _  `
  `  `  a  a  a  a  b	  b:  bm  b  b  b  c  c!  cR  c  c  c  c  d  d1  dI  d|  d  d  d  e  f  f  g  g  i  j  j+  j  lJ  lb  lz  mW  my  m  m  n  o  pc  p  q  r  s^  sv  s  s  tj  t  uV  un  vQ  v  w  xZ  y  zC  ze  z}  {  }  }1  }I  ~                  ,              "  B  s            7  O  g        E            ,      `  Q  i  y    =        E                            (    E    G    o  +  ;    \                    C      Q  i                /  G  _  w      m    x             0    >  V        A    :      ;    g        ^      l        9      c  {          f  ~            +  C  [  s  9        m        '  7  O  g          6  g            -  E  ]        K  B      |          $      v            R  "          n  ^                          M    v        ;      D  \  t            ,  D  k  G  ,    8    K  	          i            T    y  #      U                '  =  S  i            u    t    b  z      j      %  Y    L      Y  q        :   4     ' ? W   	    _ w   |   4  '  h 	r 
  H t      H c i j 9   r 3  x       b  D \ t     .  H `    a      3  I     !i ! " "m " #8 # $< $ %l %| & & & & & '` (0 ( )L )\ ) * +@ + ,Z , - - .r . / /+ / 0+ 0 1 2
 2~ 2 3Q 3 4b 4 5 6N 6 6 7 7} 7 8 9  9 :\ ; ; ; <: < =5 = > > > > > ?w ? ? ? ? ? ? @ @ @ @ A A A2 AJ A A BL B Cb C D E- E FF G G G G H# H I; I I J J KH L L M7 MG M N N N O< O PO Pg P P Q R R! R9 S S{ S S Tb T U$ Ui Uy U U V( V> W- W= W W XQ X Y Yx Y Zy [ [ [ \H \ \ ] ]) ]9 ^ ^ _V _f `$ a! a b b c7 cO c_ co c c d dZ d e fu f gL g h hv h iq jP k kU k l lh l mt m nd o p9 pI pa p qg q rD r sK sa sy s t0 tH t` tx t t t t ua uy u u u u u v< vT v w w x x yn y z { {! { { |1 | }   #  ]    Y "   |  <     , < L    Y  ( 8           ~  	      	 ! 7 O g     $   >  n     H X   & < R j        & > V t      2 R h ~      
   6 N f ~      
 ( F f       2 J b z        4 J b z        4 L d |         8 P h ~      ( H h   ~ 8  B   *   j  Y  h  [   	 w    N    ( @ X n      6   }   4  (    ^    D      I   ( > T l        $ < \ |      6 T r        0 H ` x        2 H `        > ^ |       ( > T j        B Z r        . F ^ t        , D \ r   
 " : R j        2 R r      2 R r     "  s  v Y   j    % B _ |      * G   ~ 0       r   O  h   Y v      $ A ^ {      0 P p      0 P p    6 Y    i   	     P h    , j    x  S     = Z      W     C [ s       ;        ;   N N  Q W =  @ H :     }   W  W g w   R b      ( E    9 b   2 ]    e   B !    4      _    Q   $ t  	 	 	 
    ' %  ! R    &  b     :       M     <    p      C       !
 !H ! ! "d " #2 # # $ $s $ $ % %/ %y % &, &v & & '4 'Q 'n ' (% (B (_ ( )9 ) ) *F * * +1 +N +k + + + , , ,s , -3 - ." .4 . . / /y / / 0 08 0n 0 0 1u 2 23 2 2 3 3c 3 4 4R 4 4 4 5+ 5 5 5 6 6 60 6k 6 6 6 6 7 7. 7@ 7R 7d 7v 7 7 7 7 7 7 8 8. 8J 8f 8x 8 8 8 8 8 8 9 9& 98 9J 9\ 9 :z : ; ;y ; <: < =W > >9 >Z > > ?O ? ? @, @ A A A B C C C D D D Ev E F Fa F G HJ Hk H H I J4 J K] K L N$ OL P\ Q Ry S T U` V4 W W    3#,_<     . R    f#PP          {	  	  = = = = = = = = = = = = = = = = = = = = = = = =  7= = = = = = 000` d` d` d` d 
l C d0 70 70 70 70 70 70 7 0 70 7 du du d   d d  d d 
 dC / d/ d d d d d d d d d  d d Z d d d d d d d d	 - 6 ( d d 
 
 - d dw 7w 7* w 7w 7w 7w 7w 7M 7 
 7 
 d # d d d 
d ( d' dX d' ''''''' R' R' ' <'' 
'n Z9 '1 1I9 M dM dM di d d d  ' 
 d d d d d d 
 >
 >
 > Z d d d d d d d d d d d d d d 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7F < 7 70  7 7 7 7 7 7E dE dE d 
E d 7 7] d] d] d] d] c] d] dh ] d! ! !   <! ! ! ! ! !  d -         + 
  =  (  Z Z # Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z 7 Z Z Z,  Z= : : : : : b E d & & & & & & J & & ] d& & 
 
 
 
 
 
 
 
 4 _0 90 9Q _M  _S _ 9 _ _    -  -  -  -  -  -  -  -  -  -  -  -   -  -  -  -  -  -  -  -  -  -  -W 9W 7  -  -  -  -  -  -  2Q -Q -Q -R _R _R _[ _R _T  7 X R _ 9 9 9 9 9 9 9 9 9 J 9V >: 9f >V >V >\ > >V >V >C 9 >V >V >V >V > > > > >! 9! 9! 9! 9! 9! 9! 9! 9! ! 9! 9! 9! 9! 9! 9! 9! 9! 9! 9! 9 99 9 9 9 ! 404  ! 9! 9* 4* 4 4      O 
O 
j 
 V >  
     V >     V >  J _P J _J _J _J _J _J Z  u _ L _  L L  62 L % Z9 39 9 9   _  _  _ _  _   % Z%  9 k % Z% % Z ZL Z% Z Z _= Z Z8 
 ZY _Y _Y _Y _Y ZY ZJ _J _J _ (J _J _J _ _J _J _J _J _JJ _b _J _J _H 9H 9H 9H 9H 9H 9H 9H 9H 9H H 9H 9H 9H 9H 9H 9H 9H 9H 9H 9S 9S 9S 9S 9S 9S 9H 9 9H 9H 9H 9H 9
 A 9H 9H 9 H 9H 9H 9H 9H 9B 9 9R _R _R _t .R _R _V >V >V >f > _ _   H Q - Lp Zp  _ 
 V _ 
  
     <      Q _  O 
i 	i 	i 	 	i 	i 	i 	 	i 	i 	i 	> 	i 	i 	   #i 	i 	 	i  F ZF Z_ F ZF ZF ZF ZF ZF ZF ZF ZF ZF ZF ZF ZY ZY ZY ZY ZY ZY ZF ZF ZF ZF ZG 9F ZF ZF Z 
E Z 
 
       M _  
 
 
 
 
 
 
 
 
  
 
           ? 
P 
 A 89  d dS d5 5     +   2   \ X  ( = C d` d d d dc d d d5 	 
 d d d dM dM d 
 > d 7 dE d0 7     4 ( d ( d d d d> d 3 d  d! 0 7 ' d'1   d^  F <w   dG 9 d q d  # 7` `  7 
^ dB 	 
M dR dQ   d d d 70 7 & & # d (d (^ d d    ' d5 S d  d dd (
 >= =  d - -5 	 
 
 d d 7 7 7       d ( d3 d 
0  > Q     dw 7 	 - (  dI  7: M d  dI E d  -C 94 _ _ _ _.  ! 9! 9! 9  X _X _X _X _ _ _@ % <Q _H 9N _R _ 9  
 
0 > ( 7I _ _ _I _ _X  _ %. _  9  LP  _' #M 
 A  _ 
 _  _  PH 9 
 
0 9 " _   _ _ A Q _N _V __ 9 9  
 
 ( 7( 7E _K _y y % Z  _O %Q _` _( 7 <  -  -! 9* 4* 4    X _X _H 9H 9H 9  
 
 
( 7 _ _   V >d >  N %_ _0 9|  9@ % %  _B #V >  _H %Y _ R _z 7E  @ %Q d _  0Q -1 = ` d dG  d
  d 7' dM d= 
 > d - 7 dE d ( & * #  # 7U s 6 6 6 , 6 ,'& 	 dG  d 7 7 d J a dJ  6J  7E dN 7
 >N N 7N U [       ] U = = = U [        6 6% 6% 6 6 6 6 6 6& 6 6 6 6 6 6 6& 6" 6 d 6& 6 6 6 6 6 6 6 6 65 65 6& 6& 6V 6V 6 6 6'' 
 ,& , , , , ,( , , 6 6a 6p 6 6 6 6& &  ,& , , , , , , ,( , , 7 ,& , , , , , , ,Q 9[ _C 9 9 &P K> 9 Z K L _ 2H 9S H U 9K 9; Z A P
 A Z; Z; Z; ZH 9
 AQ 9 9P K KX _  9 H 9 9 Z 
 X 78 < (t . X 7H U 9 9R _ +H Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9Q 9 9 9 9 9 9 9 9 9P KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP KP K Z '    
 # ZH 9H 9H 9H 9H 9H 9H 9H 9H UH U; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z; Z
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A
 A' '  V >J M . 7 #   (  7 ' - -0 2 . A 7 4 * 4 1 C * 2 . A 7 4 * 4 1 C * 2 . A 7 4 * 4 1 C * 2 . A 7 4 * 4 1 C * 2 Y A A A 7 A 4 A 7 4 * A 4 A 4 4h C  i  2D 2  2  &A  2  3  3   2   <  <  & i 2    s sB B -B AB 2 s s s sD (D ( s s    0    < <? 76 7T 7T 7 ( , (  ,  (  (  2  &0  	  	                  R d 9" 70  \ > 
@ U  ! ( 0 ( < 9 (-    2 Y J J J  2 J J J J J J J > > H > > > 2 2 2 2 > # # > T 7v 7G V 9 20 *L _ : - - J J  z  p < ( < ( M ` F Q Z F* \ Cr # 7    * * Gb d ( < d dx d x  (  2v ( > > # >G X X X X X  > 0 <0 <\     a                            j  j          +  \  p            a      j          d            H  @      q      d        G      a                        \  j    G      ,   2  2   <,  , 0 <  ,     ,  s Ak  , k       , n M         , n     M  A           F K F F                  F H F C             (k k 3      ,      V >  9w  R         YP                .   X   KX  ^ 2<     `            CTDB    	                            2   2  / 9 ~!-26=BE\aw#:Cy/?Jv%/7AGMW[cqy'?EMWY[]}      " & 0 : ? D J p y          !
!!!"!&!.!T!^!_!!""""""""+"H"`"e"#(#+#%%,f,m,sS      0 :  #/49BE\apz$;D?Jl
$.6<DJPZ`jx  (@HPY[]_        & 0 9 ? D J p t z         !
!!!"!&!.!S!U!_!!""""""""+"H"`"d"#&#+#%%,d,m,qS  -     3          s    N    JIGFEDB}$           } |         Q    \                                    Y  :?  6.-,  n                      vLi    @D  64  .P@B2            1  ktX      X    Z   0  L   
    .6                      .<F  P    P  Z    n          			  	          	            	  

t




  

  

                
  
    
    
                    

  
  
  
        
  
        
  

  

         %$  % , 6 E a d p x           %(/0<3Os}0\bfv,
-'()+&    !   " 0 T F J Q  z }  :        	1 dPXn_kp/B16W=Ua i Q j -~ 1 2 / ; = W G R X H i g k j s q   {   y          % #" * M 4 J [ g j i w | { z   #" *23=@?{ ) +|  4 9 @ B Z  Y c l f   
	  .  D K `9 [!&6C ^ ` 8 D    - W | 5 ` c $r n h  R S _ 7 C e w. ) l #q V ^ f P V ~  < L k q }  o r  ZB a I > Y ? @8&e   5   m *
' \   d t:oghwTEhH+,J3KQ_uspromnLMNyDFGIczx>=?KABDFECNOQUVSMLWTPRX/0IJ1X&'()+,-.789:23456;H<=>?@A" !z{|}~#$%&'()*+,-./ xy0123456789;<=>?@	
ABCEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvw :D &t 'u > ? A < b t      ' ( $ X O N ] ^ l ~   $,)+A b e Y [ \ ] Z R T 	U 
V S S U ] K M N O L   A C 7 9 : ; 8 E G H I F547;_`abcdefrstuvwxy@ABCDEFG,-89HIOPQRSTUVjklmnopqNOPQRSTULMJKNW
	]^ghi!"#$ %|}z{;<=>./:?LKMJV/0! 4758 m-;@ y v   3 (v P   ,  UXEY  K QKSZX4(Y`f UX%a  cc#b!! Y C#D  C`B-, `f-, d P&Z(
CEcEEX!%YR[X!#!X PPX!@Y 8PX!8YY 
CEcEad(PX!
CEcE 0PX!0Y PX f a 
PX`  PX!
` 6PX!6``YYY+YY# PXeYY-, E %ad CPX#B#B!!Y`-,#!#! dbB #BEX
CEc
C`Ec*! C  +0%&QX`PaRYX#Y!Y @SX+!@Y# PXeY-,C+  C`B-,#B#  #Babfc`*-,  E Cc b  PX@`Yfc`D`-, CEB*!  C`B-	, C#D  C`B-
,  E +# C%` E#a d  PX! 0PX @YY# PXeY%#aDD`-,  E +# C%` E#a d$PX @Y# PXeY%#aDD`-,  #B
EX!#!Y*!-,EdaD-,`  CJ PX #BYCJ RX #BY-, bfc  c#aC` ` #B#-,KTXdDY$e#x-,KQXKSXdDY!Y$e#x-, CUXCaB+Y C%B%B%B# %PX C`%B #a*!#a #a*! C`%B%a*!YCGCG`b  PX@`Yfc Cc b  PX@`Yfc`  #DC >C`B-,  ETX#B E#B
#`B `a  BB`++"Y-, +-,+-,+-,+-,+-,+-,+-,+-,+-,	+-),# bfc`KTX# .]!!Y-*,# bfc`KTX# .q!!Y-+,# bfc&`KTX# .r!!Y-, + ETX#B E#B
#`B `a  BB`++"Y-, +- ,+-!,+-",+-#,+-$,+-%,+-&,+-',+-(,	+-,, <`--, `` C#`C%a`,*!-.,-+-*-/,  G  Cc b  PX@`Yfc`#a8# UX G  Cc b  PX@`Yfc`#a8!Y-0,  ETX/*EX0Y"Y-1, + ETX/*EX0Y"Y-2, 5`-3, Ec b  PX@`Yfc+Cc b  PX@`Yfc+      D>#82*!-4, < G Cc b  PX@`Yfc` Ca8-5,.<-6, < G Cc b  PX@`Yfc` CaCc8-7, % . G #B%IG#G#a Xb!Y#B6*-8, #B%%G#G#a	C+e.#  <8-9, #B%% .G#G#a #B	C+ `PX @QX  &YBB# C #G#G#a#F`Cb  PX@`Yfc` + a C`d#CadPXCaC`Y%b  PX@`Yfca#  &#Fa8#CF%CG#G#a` Cb  PX@`Yfc`# +#C`+%a%b  PX@`Yfc&a %`d#%`dPX!#!Y#  &#Fa8Y-:, #B   & .G#G#a#<8-;, #B #B   F#G+#a8-<, #B%%G#G#a TX. <#!%%G#G#a %%G#G#a%%I%a  cc# Xb!Yc b  PX@`Yfc`#.#  <8#!Y-=, #B C .G#G#a ` `fb  PX@`Yfc#  <8->,# .F%FCXPRYX <Y..+-?,# .F%FCXRPYX <Y..+-@,# .F%FCXPRYX <Y# .F%FCXRPYX <Y..+-A,8+# .F%FCXPRYX <Y..+-B,9+  <#B8# .F%FCXPRYX <Y..+C..+-C, %& .G#G#a	C+# < .#8.+-D,%B %% .G#G#a #B	C+ `PX @QX  &YBB# GCb  PX@`Yfc` + a C`d#CadPXCaC`Y%b  PX@`Yfca%Fa8# <#8!  F#G+#a8!Y.+-E, 8+..+-F, 9+!#  <#B#8.+C..+-G,  G #B .4*-H,  G #B .4*-I, 5*-J,7*-K, E# . F#a8.+-L,#BK+-M,  D+-N, D+-O, D+-P,D+-Q,  E+-R, E+-S, E+-T,E+-U,   A+-V,  A+-W,  A+-X, A+-Y,  A+-Z, A+-[, A+-\,A+-],  C+-^, C+-_, C+-`,C+-a,  F+-b, F+-c, F+-d,F+-e,   B+-f,  B+-g,  B+-h, B+-i,  B+-j, B+-k, B+-l,B+-m, :+..+-n, :+>+-o, :+?+-p,  :+@+-q,:+>+-r,:+?+-s, :+@+-t, ;+..+-u, ;+>+-v, ;+?+-w, ;+@+-x,;+>+-y,;+?+-z,;+@+-{, <+..+-|, <+>+-}, <+?+-~, <+@+-,<+>+-,<+?+-,<+@+-, =+..+-, =+>+-, =+?+-, =+@+-,=+>+-,=+?+-,=+@+-,	EX!#!YB+e$PxEX0Y-   K RXY  cp B@	kWC1  * B@r^J8** B@|hTA1$* BA	!@
  	* BA	 @ @ @ @ @ @ @  	* D$QX@XdD&QX @cTX DYYYY@t`L:, * Dd DD                                                            a a I I4  > a a I I4  > c c J J    ++ c c J J  ++ c c J J    ++ c c J J 6  + -+ c c J JBZ  !9Z+    f  	       	     	     	  6   	  "   	    	   .  	  4N D i g i t i z e d   d a t a   c o p y r i g h t   2 0 1 2 - 2 0 1 6 ,   T h e   M o z i l l a   F o u n d a t i o n   a n d   T e l e f o n i c a   S . A . F i r a   S a n s R e g u l a r 4 . 2 0 3 ; C T D B ; F i r a S a n s - R e g u l a r F i r a   S a n s   R e g u l a r V e r s i o n   4 . 2 0 3 F i r a S a n s - R e g u l a r h t t p : / / s c r i p t s . s i l . o r g / O F L        2                         $  	
 b  c   % ! & "  d#$%&' '()* +,-./01234 ( e567 89:;<= >? @ABCDEFGHIJK )LM *NO PQRSTUVW +XYZ[\]^ ,_ `a b c d efghijk -lmn .opq /rstuvwxyz{  0|}~ 1 f 2   g     3  4 5 6   7 8   h  9 : ; <   =  	
 D i k l j !" n#$ m% &' E()*+,-./0 F 1  o234567 G 89:;<=>?@ABCDEFG H pHIJ rKLMNOP sQR qSTUVWXYZ[\]^_`abcdefghij Ikl Jmno pqrstuvwxyz{|}~ K L  t v w u M N O  P Q x R y { | z  }  S  T U  V   	
 W X ~ ! " #$%&' ()*+,-./0123456 Y789 Z:;<=>?@ [ \ A BCDEFGHI ]JK LMNOPQR    STUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$% &'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~                 ?          "   
   B	
 ^ ` > @                 !  "#$ %&'()* + ,-./012345678        !      a 9  :;   <   =>?@ABCDEF G # 	       _ H  IJ AKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~        C      Abreveuni1EAEuni1EB6uni1EB0uni1EB2uni1EB4uni01CDuni1EA4uni1EACuni1EA6uni1EA8uni1EAAuni0200uni01DEuni0226uni1EA0uni01E0uni1EA2uni0202uni2C6DAmacronAogonek
Aringacuteuni023AAEacuteuni01E2uni1E02uni1E04uniA7B4uni0181uni0243uni0182Cacute.loclPLKCcircumflex
CdotaccentuniA7B3uni0187uni023Buni01F1uni01C4uni0189Dcaronuni1E12Dcroatuni1E0Auni1E0Cuni018Auni1E0Euni018Buni01F2uni01C5EbreveEcaronuni0228uni1EBEuni1EC6uni1EC0uni1EC2uni1EC4uni0204
Edotaccentuni1EB8uni1EBAuni0206EmacronEogonekuni0190uni018Euni01A9uni0246uni1EBCuni01B7uni01EEuni01B8uni1E1Euni0191uni01F4uni0194GcaronGcircumflexGcommaaccent
Gdotaccentuni0193uni0241uni01E4uni021CHbaruni021EHcircumflexuni1E24uniA7AAuniA78Duni01F6IJIbreveuni01CFuni0208uni1E2Euni1ECAuni1EC8uni020AImacronIogonekuni0196uni0197ItildeJcircumflexuniA7B2uni0248uni01E8Kcommaaccentuni0198uni01C7Lacuteuni023DuniA7ADLcaronuni1E3CLcommaaccentLdotuni1E36uni01C8uni1E3Euni1E40uni019Cuni01CANacuteNacute.loclPLKNcaronuni1E4ANcommaaccentuni1E44uni1E46uni01F8Enguni019Duni01CBuni0220uni0222Oacute.loclPLKObreveuni01D1uni019Funi1ED0uni1ED8uni1ED2uni1ED4uni1ED6uni020Cuni022Auni022Euni0230uni1ECCuni1ECEOhornuni1EDAuni1EE2uni1EDCuni1EDEuni1EE0Ohungarumlautuni01A2uni020EOmacronuni1E52uni1E50uniA7B6uni01EAuni01ECuni0186Oslashacuteuni1E4Cuni022Cuni1E54uni1E56uni01A4uni024ARacuteRcaronRcommaaccentuni0210uni1E5Auni0212uni024Cuni2C64SacuteSacute.loclPLKuniA78BScircumflexScommaaccentuni1E60uni1E62uni1E9Euni018FTbarTcaronuni0162uni1E70uni021Auni023Euni1E6Auni1E6Cuni01ACuni1E6Euni01BCuni0184uni01A7uni01AEuni0244Ubreveuni01D3uni0214uni01D7uni01D9uni01DBuni01D5uni1EE4uni1EE6Uhornuni1EE8uni1EF0uni1EEAuni1EECuni1EEEUhungarumlautuni0216UmacronUogonekuni01B1UringUtildeuni1E78uni01B2uni0245WacuteWcircumflex	WdieresisWgraveuni2C72uni01F7Ycircumflexuni1EF4Ygraveuni01B3uni1EF6uni0232uni01A6uni024Euni1EF8ZacuteZacute.loclPLK
Zdotaccentuni1E92uni0224uni01B5uni0299uni0262uni029Buni029Cuni026Auni029Funi0274uni0276uni0280uni0281uni028Fabreveuni1EAFuni1EB7uni1EB1uni1EB3uni1EB5uni01CEuni1EA5uni1EADuni1EA7uni1EA9uni1EABuni0201uni01DFuni0227uni1EA1uni01E1uni1EA3uni0203uni0251uni0252amacronaogonek
aringacuteuni2C65uni0250aeacuteuni01E3uni1E03uni1E05uniA7B5uni0253uni02ADuni0298uni02ACuni0180uni0183cacute.loclPLKccircumflexuni0255
cdotaccentuni0188uni0297uni023Cuni0238dcaronuni1E13uni0221uni1E0Buni1E0Duni018Duni02A4uni0257uni1E0Funi0256uni018Cuni01F3uni02A3uni01C6uni02A5ebreveecaronuni0229uni1EBFuni1EC7uni1EC1uni1EC3uni1EC5uni0205
edotaccentuni1EB9uni1EBBuni0207emacroneogonekuni025Buni029Auni025Cuni025Euni025Duni0258uni0283uni0286uni01AAuni0285uni0247uni1EBDuni01DDuni0259uni025Auni0292uni01EFuni0293uni01B9uni01BAuni1E1Funi02A9g.ss04uni01F5uni0263gcarongcircumflexgcommaaccent
gdotaccentuni0260uni01BEuni0294uni0296uni0295uni0242uni02A1uni02A2uni0261uni01E5uni021Dhbaruni021Fhcircumflexuni1E25uni0267uni0266uni0265uni02AEuni02AFuni0195ibreveuni01D0uni0209uni1E2F	i.loclTRKuni1ECBuni1EC9uni020Bijimacroniogonekuni0269uni0268itildeuni0237uni01F0jcircumflexuni029Duni025Funi0284uni0249uni01E9kcommaaccentkgreenlandicuni0199uni029Elacuteuni019Buni019Auni026Clcaronuni1E3Dlcommaaccentuni0234ldotuni1E37uni026Euni026Duni01C9uni026Buni02AAuni02ABuni1E3Funi1E41uni0271uni0270uni026Fnacutenacute.loclPLKnapostrophencaronuni1E4Bncommaaccentuni0235uni1E45uni1E47uni01F9enguni0272uni0273uni01CCuni019Eoacute.loclPLKuni0275obreveuni01D2uni1ED1uni1ED9uni1ED3uni1ED5uni1ED7uni020Duni022Buni022Funi0231uni1ECDuni1ECFohornuni1EDBuni1EE3uni1EDDuni1EDFuni1EE1ohungarumlautuni01A3uni020Fomacronuni1E53uni1E51uniA7B7uni0277uni01EBuni01EDuni0254oslashacuteuni1E4Duni022Duni0223uni1E55uni1E57uni0278uni01A5uni02A0uni024Buni0239racuteuni0264rcaronrcommaaccentuni0211uni1E5Buni027Euni027Funi027Duni027Buni0213uni027Cuni027Auni024Duni0279sacutesacute.loclPLKuniA78Cscircumflexscommaaccentuni1E61uni1E63uni0282uni023Flongstbartcaronuni02A8uni0163uni1E71uni021Buni0236uni2C66uni1E6Buni1E6Duni02A7uni01ADuni1E6Funi01BDuni0185uni01A8uni01ABuni0288uni02A6uni0287uni0289ubreveuni01D4uni0215uni01D8uni01DAuni01DCuni01D6uni1EE5uni1EE7uhornuni1EE9uni1EF1uni1EEBuni1EEDuni1EEFuhungarumlautuni0217umacronuogonekuni028Auringutildeuni1E79uni028Buni2C71uni028Cwacutewcircumflex	wdieresiswgraveuni2C73uni028Duni01BFycircumflexuni1EF5ygraveuni01B4uni1EF7uni0233uni024Funi1EF9uni028Ezacutezacute.loclPLKuni0291
zdotaccentuni1E93uni0225uni0290uni01B6uni0240uni01C2uni01C0uni01C1uni01C3uni02B1uni02B0uni02B2uni02E1uni207Funi02B4uni02E2uni01BBuni02B7uni02E3uni02B8uni052Cuni052Auni052Euni0528uni0410uni0411uni0412uni0413uni0403uni0490uni0414uni0415uni0400uni0401uni0416uni0417uni0418uni0419uni040Duni048Auni041Auni040Cuni041Buni041Cuni041Duni041Euni041Funi0420uni0421uni0422uni0423uni040Euni0424uni0425uni0427uni0426uni0428uni0429uni040Funi042Cuni042Auni042Buni0409uni040Auni0405uni0404uni042Duni0406uni0407uni0408uni040Buni042Euni042Funi0402uni0460uni0462uni0464uni0466uni0468uni046Auni046Cuni046Euni0470uni0472uni0474uni0476uni0478uni0492uni0494uni0496uni0498uni049Auni049Cuni049Euni04A0uni04A2uni04A6uni0524uni04A8uni04AAuni04ACuni04AEuni04B0uni04B2uni04B6uni04B8uni04BAuni0526uni04BCuni04BEuni04C0uni04C1uni04C3uni04C5uni04C7uni04C9uni04CBuni04CDuni04D0uni04D2uni04D6uni04D8uni04DAuni04DCuni04DEuni04E0uni04E2uni04E4uni04E6uni04E8uni04EAuni04ECuni04EEuni04F0uni04F2uni04F4uni04F6uni04F8uni04FAuni04FCuni04FEuni0500uni0502uni0504uni0506uni0508uni050Auni050Cuni050Euni0510uni0512uni0514uni0516uni0518uni051Auni051Cuni051Euni0520uni0522uni048Cuni048Euni0430uni0431uni0432uni0433uni0453uni0491uni0434uni0435uni0450uni0451uni0436uni0437uni0438uni0439uni045Duni048Buni043Auni045Cuni043Buni043Cuni043Duni043Euni043Funi0440uni0441uni0442uni0443uni045Euni0444uni0445uni0447uni0446uni0448uni0449uni045Funi044Cuni044Auni044Buni0459uni045Auni0455uni0454uni044Duni0456uni0457uni0458uni045Buni044Euni044Funi0452uni0461uni0463uni0465uni0467uni0469uni046Buni046Duni046Funi0471uni0473uni0475uni0477uni0479uni0493uni0495uni0497uni0499uni049Buni049Duni049Funi04A1uni04A3uni0525uni04A7uni04A9uni04ABuni04ADuni04AFuni04B1uni04B3uni04B7uni04B9uni04BBuni0527uni04BDuni04BFuni04CFuni04C2uni04C4uni04C6uni04C8uni04CAuni04CCuni04CEuni04D1uni04D3uni04D7uni04D9uni04DBuni04DDuni04DFuni04E1uni04E3uni04E5uni04E7uni04E9uni04EBuni04EDuni04EFuni04F1uni04F3uni04F5uni04F7uni04F9uni04FBuni04FDuni04FFuni0501uni0503uni0505uni0507uni0509uni050Buni050Duni050Funi0511uni0513uni0515uni0517uni0519uni051Buni051Duni051Funi0521uni0523uni048Duni048Funi052Duni052Buni052Funi0529uni04A4uni04A5uni04B4uni04B5uni04D4uni04D5uni037FAlphaBetaGammauni0394EpsilonZetaEtaThetaIotaKappaLambdaMuNuXiOmicronPiRhoSigmaTauUpsilonPhiChiPsiuni03A9
AlphatonosEpsilontonosEtatonos	IotatonosOmicrontonosUpsilontonos
OmegatonosIotadieresisUpsilondieresisuni0370uni0372uni0376uni03D8uni03DAuni03DCuni03DEuni03E0uni03CFuni03D2uni03D3uni03D4uni03F4uni03F7uni03F9uni03FAuni03FDuni03FEuni03FFuni1F08uni1F09uni1F0Auni1F0Buni1F0Cuni1F0Duni1F0Euni1F0Funi1FBAuni1FBBuni1FB8uni1FB9uni1FBCuni1F88uni1F89uni1F8Auni1F8Buni1F8Cuni1F8Duni1F8Euni1F8Funi1F18uni1F19uni1F1Auni1F1Buni1F1Cuni1F1Duni1FC8uni1FC9uni1F28uni1F29uni1F2Auni1F2Buni1F2Cuni1F2Duni1F2Euni1F2Funi1FCAuni1FCBuni1FCCuni1F98uni1F99uni1F9Auni1F9Buni1F9Cuni1F9Duni1F9Euni1F9Funi1F38uni1F39uni1F3Auni1F3Buni1F3Cuni1F3Duni1F3Euni1F3Funi1FDAuni1FDBuni1FD8uni1FD9uni1F48uni1F49uni1F4Auni1F4Buni1F4Cuni1F4Duni1FF8uni1FF9uni1FECuni1F59uni1F5Buni1F5Duni1F5Funi1FEAuni1FEBuni1FE8uni1FE9uni1F68uni1F69uni1F6Auni1F6Buni1F6Cuni1F6Duni1F6Euni1F6Funi1FFAuni1FFBuni1FFCuni1FA8uni1FA9uni1FAAuni1FABuni1FACuni1FADuni1FAEuni1FAFalphabetagammadeltaepsilonzetaetathetaiotakappalambdauni03BCnuxiomicronrhouni03C2sigmatauupsilonphichipsiomega	iotatonosiotadieresisiotadieresistonosupsilontonosupsilondieresisupsilondieresistonosomicrontonos
omegatonos
alphatonosepsilontonosetatonosuni0371uni0373uni0377uni037Buni037Cuni037Duni03D9uni03DBuni03DDuni03DFuni03E1uni03D7uni03D0uni03D1uni03D5uni03D6uni03F0uni03F1uni03F2uni03F3uni03F5uni03F8uni03FBuni03FCuni1F00uni1F01uni1F02uni1F03uni1F04uni1F05uni1F06uni1F07uni1F70uni1F71uni1FB6uni1FB0uni1FB1uni1FB3uni1FB2uni1FB4uni1F80uni1F81uni1F82uni1F83uni1F84uni1F85uni1F86uni1F87uni1FB7uni1F10uni1F11uni1F12uni1F13uni1F14uni1F15uni1F72uni1F73uni1F20uni1F21uni1F22uni1F23uni1F24uni1F25uni1F26uni1F27uni1F74uni1F75uni1FC6uni1FC3uni1FC2uni1FC4uni1F90uni1F91uni1F92uni1F93uni1F94uni1F95uni1F96uni1F97uni1FC7uni1F30uni1F31uni1F32uni1F33uni1F34uni1F35uni1F36uni1F37uni1F76uni1F77uni1FD6uni1FD0uni1FD1uni1FD2uni1FD3uni1FD7uni1F40uni1F41uni1F42uni1F43uni1F44uni1F45uni1F78uni1F79uni1FE4uni1FE5uni1F50uni1F51uni1F52uni1F53uni1F54uni1F55uni1F56uni1F57uni1F7Auni1F7Buni1FE6uni1FE0uni1FE1uni1FE2uni1FE3uni1FE7uni1F60uni1F61uni1F62uni1F63uni1F64uni1F65uni1F66uni1F67uni1F7Cuni1F7Duni1FF6uni1FF3uni1FF2uni1FF4uni1FA0uni1FA1uni1FA2uni1FA3uni1FA4uni1FA5uni1FA6uni1FA7uni1FF7uni1FBEuni037AuniAB53uni210Auni1D4Auni1DBFfive.tfuni2080uni2081uni2082uni2083uni2084uni2085uni2086uni2087uni2088uni2089	zero.dnomone.dnomtwo.dnom
three.dnom	four.dnom	five.dnomsix.dnom
seven.dnom
eight.dnom	nine.dnom	zero.numrone.numrtwo.numr
three.numr	four.numr	five.numrsix.numr
seven.numr
eight.numr	nine.numruni2070uni00B9uni00B2uni00B3uni2074uni2075uni2076uni2077uni2078uni2079uni215Funi2153uni2154uni2155uni2156uni2157uni2158uni2159uni215A	oneeighththreeeighthsfiveeighthsseveneighthsuni2016uni204Auni203Funi208Duni208Eparenleft.dnomparenright.dnomparenleft.numrparenright.numruni207Duni207E
figuredashuni2015uni00AD	anoteleiauni037Euni2007uni2008uni00A0uni200Buni200Euni200Funi200Duni200CuniFEFFuni0E3Fcolonmonetarydonguni20AFEurouni20B4uni20BAuni20A6uni20BDuni20B9uni20AAuni20A9uni2219uni2215	plus.dnom
minus.dnom
equal.dnomdotmathuni208Cuni207Cuni208Buni207B	plus.numr
minus.numr
equal.numremptysetuni2126uni2206uni00B5uni208Auni207Aarrowup
arrowright	arrowdown	arrowleftuni21E7uni21E8uni21E9uni21E6uni25AFuni2113	estimateduni2116uni21EAuni2327uni232Buni2326uni2328uni23CEampersand.ss03uniA789uni02EEuni02D7uni02D6uni02DEuniA78Auni02E4uni02E5uni02E9uni02E6uni02E8uni02E7uni02D4uni03F6uni0374uni0375uni02E0uni0308uni0307	gravecomb	acutecombuni030Buni0302uni030Cuni0306uni030A	tildecombuni0304hookabovecombuni030Duni030Funi0311uni0312uni0313uni0316uni0317uni0318uni0319uni031Auni031Buni031Cuni031Duni031Euni031Funi0320uni0321dotbelowcombuni0324uni0325uni0326uni0327uni0328uni0329uni032Auni032Buni032Cuni032Duni032Funi0330uni0331uni0332uni0334uni0335uni0336uni0339uni033Auni033Buni033Cuni033Duni035Cuni0361uni1DC9uni1DC7uni0308.caseuni0307.casegravecomb.caseacutecomb.caseuni030B.caseuni0302.caseuni030C.caseuni0306.caseuni030A.casetildecomb.caseuni0304.casehookabovecomb.caseuni030F.caseuni031B.caseuni0326.caseuni0327.caseuni1DC8uni1DC5uni1DC4uni1DC6uni02CFuni02D1uni02D0uni02BBuni02BAuni02CBuni02C0uni02CEuni02B9uni02BFuni02CAuni02CCuni02C8	caron.alt
acute.case
breve.case
caron.casecedilla.casecircumflex.casedieresis.casedotaccent.case
grave.casehungarumlaut.casemacron.case	ring.case
tilde.caseacute.loclPLKacute.case.loclPLKuni0342uni0345uni1FBF.caseuni1FFE.caseuni1FCD.caseuni1FDD.caseuni1FCE.caseuni1FDE.caseuni1FCF.caseuni1FDF.caseuni1FEF.caseuni1FFD.casetonos
tonos.casedieresistonosuni1FBFuni1FBDuni1FFEuni1FCDuni1FDDuni1FCEuni1FDEuni1FCFuni1FDFuni1FEDuni1FEEuni1FC1uni1FEFuni1FFDuni1FC0uni02BCbrevecybrevecy.casejcrossedtaildotlessdieresisacutecombdieresisgravecombacutedblgravedbltildedbldieresiscaroncombdieresisacutecomb.casedieresisgravecomb.casedieresiscaroncomb.caseuniA7AEuni1D91uni1D6Cuni1D6Duni1D6Euni1D6Funi1D70uni1D71uni1D72uni1D73uni1D74uni1D75uni1D76             F  	      \ K L    L\ ]` aa bb cm ow {~             
 d  DFLT cyrl *grek :latn J                   	         
          kern Jkern Jkern Jkern Jmark Rmark Rmark Rmark Rmkmk ^mkmk ^mkmk ^mkmk ^                    	 
   <
n&VXZZp[ 	          ]    g    n 	   . 6 > F N V ^ f n v ~             u    {*    |    }                     #   $$   6   Aj   B   Fl   Jp   Ub   b   e   ~        4  Hf  Lm  ox "{ , 1 D E  Z2 G [h [ [n [t [z [ [ [ [ \ [ [ [ [ [ [ [  Y  Y  Y  Y [ [  Z6  Y  Y  Y  Y  Y  Y  Z   Z  ZH  Z  Z  Z<  ZB  Z  Z  Z  Z$  Z*  Z0 &  Z6  Z<  Z<  ZB [ \ \ [ [ [ [ [ [ [ [ [ [ [ \ \
 [  ZH  ZN \ \ \  ZT M@MFTNTNK<STNTNK B H N T ZTNTNHDvTNTNS
TNTNP@"TNTNFFhTNTN - /   w6       #   >      H Y Z Y Y Y Y Y Z Y Zz Y Y Y Y Z Z Z  X4  X4  X:  X: Z Y  X  X@  X@  XF  XL  XR  XX  X^  Xd  X  Xj %V  Xp  X  X  Xv  Xv  X|  X  X  X %\  X  X  X  X Z Zn Zt Z  Z& Z, Z2 Z8 Z> ZD ZJ ZP ZV Z\ Zb Zh ZP  X  X Zn Zt Zz  X
RRRRRR jRRRBBC RRFFR@RCBFRRR@ARRRERRRERRRERRRRRRNBFRBXRNB.RBXRNBRBXRRRRMRRRRRRRRRRRRRRRJRRRJ RRR jRRRDzDnRRRBBC RRG>GDREERRREGRRRG>AJAzRRFFFRRKGRRRKGRRR4&RRRKGRRRCFfRRRRRRR\EjRRR\EjRRRRRRRFFRRRDzpRRR4,RRRJRRR28RRRFTFfRRRGGRRRDbRRRCC~RCRCCTRCRCCRRR>DRRRJRRRIPRRRV\RRREERRRbRRRITIZRRRQdRRRGGRRRNhRRRntRRRRzRRRMAJRRRG>GDRRRRRRRRRREELxGzRRRN"GRRRRRRMRRRJRRRJBRRRJRRRRRRBBC RRRRRRRRRRRG>AJAzRRFFFRRKHRRRKHRRRKGRRRCFfRRRCFfRRRGRRRGRRRRRRRCC~RCRRRRKRRR jRRRBBC RRBBC RRCFfRRRDzDnRRRFFR@RF@R@RNBFRBXRFlFrRRRFlRRRRRRMRRRHBdRRR
RRRRRRG>E.REEG>GDRRRG>E.RRRRRRK"RRRK(RRRKGRRRC.RRRERRR4:RRRLxGzRRRKGRRRKGRRRFFRRR@FRRRLRRRORRRRDDRRRO*XRRRDBRRR^dRRROH4RRR jRRRDzpRRROvRRR|RRRFFRRRGGRRRJRRRRRRC RRN:B|RRRNGRRROHRIRC RRRJK"RRROPRRROKLRRROPRRRN4RRRN:JRKRN:Q4RKRN:JRKRQRRRJJRRRHHRRRHHRRRHHRRRHHRRRPHRRRPRRRH:JRRR RRRIfO6RRRQdQjROOJQRRROTO6RRRIQ^RRRPPRRRRNRRRRRNRRRRRRRQR RRR RRRN:RRRRDzRRRDzRRRN:RRRRHJRRRRRR bRRRDzRRRMMRRRPR RRR ORRR""RRROLfRLROL6RLRLLRRRKKKRRA RRR RRRRRRNNRRRORRRRRRRRRRRR RRRRRRP2RRR t zRRRQdNFRRRR0RRR$RRR*0ROO6I$RRR<BRRRQRRRJJRRRPHRRRNTRRRZRRRIfO6RRRJQRRR`I*RRRAPRRRIQ^RRRPPRRRKRRRRRKRRRRRQR RRR RRR RRRNfRRRNfRRRN bRlRN bRlRM>MPMRMzQRRRrxRRRH:JRRRIfO6RRRIfO6RRR~ RRR RRROHRIROHRIRN:JRKRKK"RRRKRRRQRRRJRRRM2PRRRHRRRHRRRQdNROOQdNFRRRQdRRR"RRRRNR<RRRRNRRRRRNRRRRRRROPRRRRRR RRRORRRORRRIIJDRJ>RRRJRRRR~RRRRCRRRRRRH:H@RRRRRRKJRRRH:JRRRARRRRRR&RRROfOlRRRQQRRRPPRRR &RRRMMRRRK,RRROTO6RRR28RRR>DRRRH:JRRRIfO6RRR R6 6  > 26 2 &            4 g6 g <   }             6    (     6  j6 j /   x   x !    * =~    ~  ~ X^ X~ 	    ~ ^ ~ ~    ~     o    U   U J  {     6  6  6 ! 6  V   (6 (   a   a     c   c J   J t   t        @ =6 :     6   
   
 R 6 #   6  6 P     h      . .  %          o   q    6         L   >   >  6     6   96 9 6         X   "D    X HHK H J* Jl J0 J6 J< JB JB Jf JH J JN JT JZ J` Jf Jl Jr  H  H  H  H Jx JH  H  H  H  H  H  H  H  H  H  I
  H   H  H  I  H  H  H  H  H  H   H  H  H  I J~ J J J J J J J J J J J J J J J J  I
  I J J J  IL4*40CCC771<CC1`1rCCC6FxCCCAZCCC?^22CC88CCC3F3^C3dC77CCC4 34CC4<4BCCC77CCC44CCC5D5&CCC2CCC776"C6. CCC6F8 CCC23(CCC77$C7*C;h8hCCChCCC;8&CCC>1CCC734CCCCC2CC$C*CB^09CC6T<CBHNCCC9TCCC4 34CC;h8>CCC?8CCCAZCCC`fCCCl76"C6.CrCCC6FxCCC~CCC>2CCC4BCCC;h8PCCCCCC;hCCC77CCC?^8 CCC; 3CC44CCC; 3CC; CC; CCCCCC:~3CC5&CC28CC<pDJCCJ
VCCJbCCCCCC71 1<CC71*1<CC71<CCCCCC3CC 5&CC,28CC>DJCCPJ
VCC\JbCChnCC9CCtCCtCCz
CCzCC9CC8CC64CCCCCCCC
CCCCCCCCCCCC3^C3dCCCCCCCCC
CCCCCCCC?CC"7CC9CC9CC>V
CC>VCCCCCC"(7CC7.CC4 34CC4 34CC4:C@FCL5RCX ^dCjvpCv|CC:C;CCCCCCCCCCCCCCCCCCCCC;h8>CCC;h8\CCC6CCC3CCCHCCC TCCC`CCC`CCClCCCxCCCCCC>D$CCC*34CCC06CCC<3CCCBHCCCNTCCCZ`CCCZ`CCCflCCCrxCCC;h\CCC??CCC;@CCC4`~CCC;;CCC=CCC@*CCC7CCC:<CCCCCCB@HCCC>CCC=@CCCCCCAA?vC?8>CCC:<9RCCCCCCCCC;,CCCACCCCCCCCCCCC?4?:CCC:<CCC:CCC:<CCCACCCACCCACCCAA?vC??4?:CCC;h\CCC;;CCC@*CCCD@CCC;@CCC9L9RCCC28CC2C>C2CCA?vC?;@CCC;CCC@CCCCCC9RCCC7 CCC??CCC&,CCC9L9RCCC:<:BCCC28C>C=<CCCD@CCC??CCC58JCCC:<9RCCC;hbCCC;hhCCC;hnCCC;htCCC;hzCCC;hCCC;hCCC;hCCC;h\CCC;h\CCC;hCCC;hPCCC;hVCCC\CCC\CCC\CCCbCCChCCCnCCCtCCCzCCCCCCCCCCCCCCC;CCC;CCC;CCC;CCC;CCC;CCC;;CCC;;CCC@*CCC@*CCC@*CCC@*CCC@*CCC@*CCC@*CCC@*CCC@*CCC@*CCC@*CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC:CCC:CCC:
CCC:CCC:JCCC:CCC:CCC:"CCC:<CCC:<CCC:(CCC:.CCC:4CCC:<CCC:<CCC:@CCCAF?vC?AL?vC?AR?vC?AX?vC?A^?vC?Ad?vC?AA?vC?AA?vC?:<jCCC:<pCCCvCCC|CCCCCCCCCCCCCCCCCCCCCACCCACCCACCCAnCCCACCCACCCACCCCCC?4CCC?4CCC?4CCC?4CCC?4CCC?4CCC?4CCC?4CCC?4?:CCC?4?:CCC?4CCC?:CCC?:CCC?:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC   R   R  ~        Y         j      $ V   V Z6  <       16     ~ l iZ    Z =               ? 9   7     jB B 7 B = 7   B    B    B     B     ,B    'B       5      "       A   =   b   S          Y B B Y B Y B bY B SY B Y ?                    G        /       $ ^    )   8         1         ~     t N     ]                      Y   ^   @   f   \        B B  B B W B \ B > B d B Z "  6       6    6   &       o6 o  6   y6 y    DF  F  
 $6  6   @6 @ ,6  l   l       A
     P    7"  "  "  "  "  " 0e f ^B   "  "  "  "  " & I" "  "  "  "  " Be (f  B &  "  e"  >"  ("  H"  e  f            S G" "  "  "  "  " O" 	" D"  "  "  "  "  " =e #f    %S " b" ;" %" V" E" e f B   B              .  n  Lx  { - 2 E F  
         y {txzpvx H 5 5 5 5 5 5 5 5 5 6F 5 5 5 5 5 5 5  4   4   4  4 5 5  4`  4  4  4  4  4  4$  4*  40  4r  46 "  4<  4f  4l  4B  4B  4H  4N  4T  4Z (  4`  4f  4f  4l 5 6: 6@ 5 5 5 5 6 6
 6 6 6 6" 6( 6. 64 6  4r  4x 6: 6@ 6F  4~    ="b"h.h.h"b.h.h"b\.h.h"b.h.h'\.h.h"b.h.h"b.h.h"b .h.h"b&.h.h"b,2.h"b8D.h',2.h"b8D.h"b>D.h"bJP.h"bV.h.h"b\.h.h"bb.h.h"bh.h.h'"h.h.h"bn.h.h"bt.h.h"bz.h.h"b.h.h".h".h.h"b.h.h"b"h.h.h"b.h.h"b.h.h"b.h"h.h.h"b.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h".h
.h:".h.h:".h
.h:".h.h:.h
.h:".h:".h.h:".h(.h.h..h4.h.h..h4.h:$.h#.hF.h@.hF.hL.h^.h"2.hd^.h"2.hd$.hR.hX.h#.h^.h"2.hd$.hj.h+&.h#.hp.hv.h|.h#.h.h.h.h.h.h.h.h*.h.h*.h.h*.h.h*.h.h*.h.h*.h*.h.h*.h*.h*.h*.h.h*.h.h*.h.h.h.h*.h.h*.h.h*.h.h* .h.h*.h.h+D.h#.h.h(.h.h.h.h.h.h&.h.h*.h.h#.h$.h.h#.h*.h.h#.h0.h.h!.h<.h.h!.h6.h.h!.h<.h.h .hf.h.h .hB.h.h#.hH.h.h .hN.h.h .hT.h.h .hZ`.h .hf.h.h .hl.h.h&|.hr.h.hx.h~.h.h#.h".h.h,.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h"&.h.h.h.h.h\b>.h.hb.h.h\b.h.h\b.h.h\b.h.h\b.h\b.h.h\b.h.h\b>.h.h\b.h.h b>.h.h\b&.h.h\b,.h.h\b2.h.h\b8.h.h\b>.h.hD.hJ.h.h(8PV.h.h\bh.h.h.h.h.h.hnt.hz.h.h.h.h.h.h.h.h.h.h.h.h.h.h.h!.h.h.h%V.h  .h  %V.h  .h.h%V.h  .h  %V.h  %V.h  .h   .h 
  $.h  " ( :.h ..h.h :.h 4.h.h :.h @.h.h F.h L.h.h .h .h.h R.h X.h.h .h ^.h.h .h .h.h .h d.h.h j.h .h.h .h .h.h .h p.h.h v.h .h.h .h |.h.h .h .h.h .h .h.h .h .h.h .h .h.h .h .h.h"!~#!.h .h .h.h"!~!!.h"!~#!.h"!~ !.h"!~ !.h".h#.h.h"!~  .h"!~  .h!!~  .h"!~  .h"!~  .h"!~  .h"!~ !.h"!~ !.h"!~ !.h"!~ !.h"!~! !.h!!~#!.h"!~!!.h"!~!!.h"!~#!.h"!~!!.h!!~#!.h"!~!!.h"!~!!.h"!~!r!.h"!~#!.h!$.h!*.h.h"!~!0!.h"!~!N!.h"!~!6!.h"!~!<!.h!B.h!H.h.h"!~#!.h"!~!N!.h!T.h!Z.h!`".h!f.h.h".h!l.h.h"!~!r!.h"!~!x!.h"!~!!.h!.h!.h.h!.h#|.h.h!.h!.h.h!.h!.h.h'6.h!.h.h*.h#|.h.h".h".h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h!.h!.h.h".h"&.h.h".h!.h.h".h"&.h.h".h!.h.h".h"&.h.h".h"".h".h"&.h.h".h".h.h" .h"&.h.h",.h"2.h.h"z.h".h""8.h">.h"D"z.h"J.h""z.h".h""P.h".h""z.h".h""z.h".h.h"z.h"V.h"#.h".h"%&.h#..h.h"\.h".h""b.h"h.h.h"n.h"t.h.h"z.h".h"##"#(.h##"#(.h"""".h##"#(.h##"#(.h##"".h##"#(.h##"#(.h##"#(.h##"#(.h##"#(.h##"#(.h"#"#(.h##"#(.h##"#(.h##"".h##"".h"#"".h##"".h##"".h###".h##"#(.h##"#(.h##"#(.h##"#(.h".h#.h.h###
#(.h####(.h###"#(.h%\.h#..h.h#4.h#:.h.h#@.h#F.h.h#d.h#v.h.h#d.h#L.h.h#d.h#R#X.h#d.h#^.h.h#d.h#j.h.h#p.h#v.h.h*.h#|.h.h&.h#.h.h&.h#.h.h&.h#.h.h&.h##.h&.h#.h.h#.h#.h.h&.h#.h.h&.h#.h.h&.h#.h.h&.h#.h.h).h#.h.h&.h#.h.h&.h#.h.h#.h#.h.h#.h#.h.h#.h#.h.h#.h#.h.h#.h#.h.h'f.h#.h.h#.h#.h.h+D.h#.h.h&v.h&.h.h#.h$ .h.h*.h(.h.h%&.h*.h.h$.h$.h.h$.h'.h.h$.h).h.h$.h$$.h.h+D.h$.h.h+D.h$.h.h,p.h,v.h.h+D$$.h.h+D$$*.h.h+D$$0.h.h+D$$6.h.h$$$0.h.h+D$$6.h.h+D$$<.h.h+D$$B.h.h+D$$H.h.h+D$$N.h.h+D$$T$`.h$$$N.h.h+D$$T$`.h+D$$Z$`.h+D$$f$l.h+D$$r.h.h+D$$x.h.h+D$$~.h.h+D$$.h.h$$$.h.h+D$$.h.h+D$$.h.h+D$$.h.h+D$$.h.h$.h$.h.h$.h$.h.h+D$$.h.h+D$$.h.h+D$$.h.h+D$$.h.h$.h$.h.h+D$$.h.h$$$.h.h$.h$.h.h$.h$.h.h$.h$.h.h%.h%.h.h%.h%.h.h%.h%.h.h+&.h+ .h.h%&.h+.h.h%.h.h.h.h%.h%.h.h% .h%.h.h%&.h+.h.h%V.h-.h.h%V.h,.h.h%V.h-.h.h%V.h,.h.h%,.h-.h.h%V.h,.h.h%2.h%8.h.h%V.h%>.h.h-.h%D.h.h%J.h%P.h.h%V.h-.h.h%.h%%&%\.h%b.h.h%h.h%n.h.h%.h%%&%t.h%%&%.h%%&%z.h%.h.h%.h%%&%.h%%&%.h%.h.h%.h%%&%.h%.h.h%.h%%&'0.h%.h.h%.h%.h.h%.h%%&%.h%%&%.h%%&%.h%%&)&&j.h.h)&&
.h.h)&&.h.h)&&.h.h&&&j.h.h)&&".h.h)&&(&4.h-&&".h.h)&&(&4.h)&&.&4.h)&&:&@.h)&&F.h.h)&&L.h.h)&&R.h.h-&&j.h.h)&,.h.h)&&X.h.h)&&^.h.h)&&d.h.h)&&j.h.h'N.h&p.h.h&v.h&.h.h&.h&.h.h&|.h-.h.h&.h&.h.h&.h&.h.h&.h&.h.h&.h(.h.h&.h&.h.h&.h&.h.h&.h&.h.h)&&.h.h&.h&.h.h&.h&.h.h&.h&.h.h(.h,v.h.h(.h&.h.h(.h,v.h.h&.h+h.h.h+.h'H.h.h&.h&.h.h&.h' .h.h).h'.h.h,.h,j.h.h,.h'.h.h'.h-.h.h,.h'.h.h,.h'.h.h,.h'$.h.h,.h,j.h.h,.h'*.h.h'0.h(.h.h'6.h'<.h.h(.h(.h.h'6.h'<.h.h'N.h'T.h.h'B.h'H.h.h(.h(.h.h'N.h'T.h.h'Z.h'`.h.h'f.h,j.h.h'l.h'r.h.h'.h'.h''x.h'~.h''.h'.h''.h''''.h'.h''.h'.h.h).h'.h.h'.h-.h.h'.h'.h.h'.h'.h.h'.h'.h.h+(J(&.h.h+(J'.h.h+(J'.h.h+(J'.h.h+(J'.h.h+(J'.h.h+(J'.h.h+(J'.h.h+(J'.h.h+(J(&.h.h+\(J(&.h.h+(J(.h.h+(J(.h.h+(J(.h.h((J(.h.h+(J( .h.h+(J(&.h.h(,.h(2.h.h(8(>(D.h.h+(J(P.h.h(h.h(V.h.h(h.h(\.h.h(h.h(b.h.h(h.h(n.h.h(t.h(z.h.h(.h(.h.h(.h(.h.h(.h(.h.h(.h(.h.h(.h(.h.h(.h(.h.h(.h(.h.h(.h(.h.h(.h)):)@(.h():)@..h+.h.h(.h((((.h(. ((.h)):)@(.h)):)@(.h)):)@(.h(.h.h(.h)):)@)
.h)):)@).h)):)@)".h)(.h.h)..h)4):)@)F.h)L)R)X)^.h)d.h.h)j.h)p)v)|).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h-.h.h).h).h.h-.h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h).h.h).h* .h.h-$*-**.h-$***.h-$*-**.h-$.h*.h.h-$***.h-$***.h-$***.h-$****.h*Z***.h-$****.h-$**$**.h-$**0*6.h-$**<*.h-$**B*.h-$**H*.h-$**N*.h-$**T*.h*Z*-**.h-$**`*.h-$**f*.h-$*-**l.h-$***l.h*Z*-**l.h-$**`*l.h-$**f*l.h-$***l.h-$*-**.h*r.h*x.h.h-$**~*.h-$***.h-$***.h-$***.h*.h*.h.h*.h*.h.h-$*-**.h-$***.h*.h*.h.h*.h-*.h.h*.h*.h.h-$***.h-$***.h-$***.h-<.h*.h.h*.h*.h.h+.h*.h.h+.h*.h.h+.h+.h.h+.h+.h.h+.h+.h.h+.h+.h.h+&.h+,.h.h+&.h+ .h.h+&.h+,.h.h+2.h+8.h.h+.h+.h.h+.h+>.h.h+D.h+J.h.h+.h+P.h.h+.h+.h.h+.h+V.h.h+\.h+.h.h+b.h+h.h.h+n.h+t.h.h+z.h+.h.h+.h-.h.h+.h+.h.h+.h+.h.h+.h+.h.h+.h+.h.h+.h+.h.h+.h-.h.h+.h+.h.h+.h-.h.h+.h+.h.h+.h-.h.h+.h+.h.h+.h-.h.h+.h+.h.h+.h-.h.h+.h-.h.h+.h+.h.h,.h,,L,R,.h,,L,R,.h,,L,R+.h,.h.h,
.h,,L,R,.h,,L,R,.h,,L,R,.h,.h.h,:.h,.h.h,.h,",L,R,(.h,,L,R,..h,4.h.h,:.h,@.h.h,F.h,,L,R,X.h,^.h.h,d.h,j.h.h,p.h,v.h.h,|.h,.h.h,.h,.h.h,.h,.h.h,.h,.h,-<-B--N.h-<-B,-N.h,,,,.h-<-B,-N.h-<-B,-N.h-<-B,-N.h-<-B,-N.h-<-B,-N.h-<-B--N.h-<-B,-N.h-<-B--N.h-<-B,-N.h,-B--N.h-<-B- -N.h-<-B--N.h-<-B--.h-<-B,-.h,-B--.h-<-B- -.h-<-B--.h-<-B-6-.h-<-B--N.h-<-B--N.h-<-B--N.h-<-B--N.h-$.h-*.h.h-<-B-0-N.h-<-B-6-N.h-<-B-H-N.h-`.h-.h.h-T.h-Z.h.h-`.h-f.h.h-l.h-.h.h-.h-r.h.h-.h-x.h.h-.h-~.h.h-.h-.h.h-.h-.h.h-.h-.h.h-.h-.h.h-.h-.h.h-.h-.h.h..h-.h.h..h-.h.h..h-.h.h..h-.h.h-.h-.h.h..h-.h.h-.h-.h.h..h-.h.h..h-.h.h..h..h.h..h..h.h..h. .h.h.2.h.V.h.h.2.h.&.h.h.2.h.V.h.h.2.h.,.h.h.J.h.V.h.h.2.h.8.h.h.>.h.V.h.h.>.h.D.h.h.J.h.V.h.h.P.h.V.h.h.\.h.b.h.h ! !l -7 ! !   g       !~ # ! &  / ! !^ ! "P    !      ^ 6   / 86 - 06 0     B   9 ] ] l [ [  ] 
6 
     UZ { m   } 1 .2 8   OY 1     Y .S U Q   W CY $ $ "  !g        $~ $ %6 " 2 $ $^ "          $      ' % e  e~ e c  c e '         X   X XY V T   T  V6 T TY     Y 2       6          f  ~    6        ^                             6    6   J ;   H 5 x6    "        Q       2  6   n6 q                   D6 N c c Y2 c Y6 a a 66 9 P6 P W   c F   F \ Z  Yg   X  - \~ ^ \ a \ \6 Z j Y 6  \ ^ b     \^        Z U W \ \    \ %     %     % v O6 O - -   76 - @   6 5   +          6  E   ;   W  2  S             Y Y      Y T M K   M~ J O M M6 K [ z M M^ K Z   Z M M K      M F  D   D        ~         #     ~ 6   # ^ /          6      1           *       !    E     qh E q^  @   \  6 E ! N  ,   ,   D        =   !     ; 9        :   )   (   #   56 7       &     62 q6 q 4   / 66 "6 " 6 ? ? 6S -  +   + 1     -   3 6   / !   1    h E ^  @    'N        '              *6    36  6   L    t               6        !  6     +6                 6  6  6   .   * * & (   $ D *6 $ $ % !6 v6 v      !        g@       !  N   6                                   6    6       6            9             >|       `|  2  6       ,  6   6 x  6   6    )|         c| [   ^         /|    r !  6     ,!     , '2 n6 , 6! 6 /6 6  * %   * # & & &    h  E ^  @ &  &\ & 'E &6 0! 4N  6  & &x .x     }   | &       #   &! $ &| {   &2  !     ) +! + :6 : )6 ) . .6 . 6   !        @  6              6  6        6                      !              6  7  6          2  6      _  6 6         S                      6    6   |   _    v   0      0  # # #  @ #  # #\ #! #6 -! 1N % # # ! $   $ #D ! !      #|                g i! i i  g   s! n   n f   f '6 '        !      r6   !  6   N    6    6          !          6    6        6               R  !]^_`cdefghijkmopqrstuvw{|}~ ! D D J P V \ \ b h n t z                      l3 ~ z  N f e _+ 6 B@ r  '  > >2 M< =H \S S  Z  X %< y  3  L          v  LO  QZ aa         " # % * . 1 5 6 8 r x ~ ~                      &,28>DJPV\bhntzj B   l! > > M rD \ N Z K@ M  ^F B~  t l = > M~ r = \^  K  5  N  LZ        ~      ~  a    ^    X       a  !    D           *  b  b       
       5       4  :<  ]`  cm ow {~         ~   ~                                                                                        j   |   L   d   c         @   p   m      <   K   ;   Z         V   #      g   7     B       :  f  L\  aa    " # $   %                             J                             >  D                        &  ,  2  8  >  D  J @ ` j  < p Z o  q K    \ @  t j ! = < K p ; Z o x  3 ;  * 0 0 6 6 < B H N T Z ` ` ` ` ` f l r x ;  \            r  Y"  \"  e  f  S      h  ,                                                             
                                                                                                                                                                                                     	                                   	                                                        V                                                                                                                                       
                                                                                        
                                                                                                         / / /                                                                                                                                                                                                                                                                                                                      	                     	                        Y z U                      
                                                                                                                                                                                                                                                                                                                                                           	                                                                         $%'(*+/2:     
           	   $$ '' (( ** ++ // 22 ::   <]] !^^ __ `` aa cc  dd ee ff hq r{ |       	     & " ' #   ( $       +  * ) 
  %              $$ %% )) ** ::  V     -    	 	  	 	 	  	   	                                                                                                                        	                                  &                                                	                                 &                                                                                     	                                                                                                                                                                                                                                                                                                                                                                                   	             	                                  &                     	                         	                                                                                                                                  	               	 	 	  )  ,               	                                  
                        ;]] )^^ 	__ `` aa cc !dd ee 'ff hq r{ |       (   
     * +   ,   $  $  % &           #   $$ %% (( )) ** "++ // ::     |  -                                                                          	                                                                               
                                                                                                                                            
   
 	 	                                       	                                       
                                                                 	                                                                                                                                                                                                                                 	     	                                           	                       	                          	 	                  	                                        	    ]a  cf h 	 1 @ A C G I L S  ]] 	^^ __ `` aa cc dd ff hq r{ 
|  
   
   
        ;]] %^^ __ 
`` aa cc dd ee ff hq r{ |       #  '     )    +       "    $ (       ,   $$ !%% (( *)) ** 	++ // &::   L    8&&&&&&&>Tbpvl&,,::Lf   , - . / 0 1 2 4 5 Y ` l w    CEhopqrstuw{|}~,0123456789:;<=>?@ABCDEFGHIJLMNOPQRSTUVWXYZ[\]^_`adei  p u u    p u u            7 7 B 
=>y   ] ] @ @ K  	 	 	  	    . =  " y | 	} 	~ 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	     	 	  	 	     	 	 	 	 	 	<       "  y              <        	 	  H 	      ` ` v                         
    =  >  y              +    &  +  c B    B     c B    B 	 	      B  	      6     f f f l l f l v                	%24<@is    EF     	  	      	  
 c 	  B c 	   B c  	 B  t    5 *L  5"/3=@hijklmnopq
=>Jy J 	 !#.89: 6LMN hijklmnopqJ  "  	     "   " C      "   #B(D !    	 	    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	                                                               	 % %                                                                                                                                                                                                                       +                                          	                                                                                    
                                                                                                                                                                                                                                                                           	                                                                       	   	                 	           	           $                                                                                                                                                             	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	               	   	   	   	                     	        	   	          	 	                                                                                                     	                                                    ~                                                                  	                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                        	          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            	                         
                                 # 
           
         
   
                                                             
                                                                                      
                                                                                                                                                                                                                )                                	                                                                                                                                                          	           
                                                      	                                                                                                                                                      	                         
                                                                                                          1  B   E v @ x  r        C yy:;?@D
LVZ[ !g#'i**n,.o33r57s<?vBBzEE{GI|KKMMO`bbdhjtxy#&+-.1244668!"#$%11&      " $  % *  + +  , 2  3 3  4 5  6 6  7 8   9 A  B B  E X  Y Y  Z Z  [ [  \ ]  ^ _  ` `  a c  d e  f f  g l  m m  n n  o o  p v  x x  y y  z  	      	      
      	      	                                                                                                !! "$ %% && (, -- .. // 05 66 78 99 :; <C  yy                 		 

               	    !! ## $$ %% ** ,, -. 33 57 << == >? BB EE GG HH II KK MM QQ RS TT UV WX Y\ ]_ `` bb de ff gh jk ll mm nn oo pq rr ss tt xx yy                      !! "" ## '' () ** ++ -- 	.. 11 22 44 8: ;; << == >> ?? @@ AA W^ _{ |} 	~       11     0     ! 0 " $ 1 ) ) 	 , 2  3 3 9 4 5  @ @ 	 B B O Y Y P Z Z 2 [ [ 7 ^ _ < ` ` P d e  f f  g l  m m  n n  o o  u u 	 v v       3   4   3   S         5      	      6   &   6      	  > 
   !! "$ %% && '' 0(- 8// 908 :; <C ;DD gEF hGJ gKK hLM gNN NOf Tgg hhh gin Too ppr Tsw ayy {| a} h x h Z F h  h z  ' h  {  \ ] ] N ] h    ^   ^ h ] D a p ' a | g w | w | w | w | p | w c w }  c a g a C d a		 e
 f a d a d a f d f d g p! g"" &#* g++ z,/ g0S hTT U[ h\\ g^^ g__ h`a abe hfg ghh Nim gnn 'oo gpp ?qr gss ?tt guu ?vx kyy &z k a k \ m g m p q p N p N B r B g C N B s \ G v H 0 v 9 < H S 		 

    9   H 6  < 3 !! I"" ## $$ && 0(( :** <++ ,, -. // 22 933 <77 ;< == >? @@ 9AB EF HH 9JJ HMM NN SOP 0RS TT 9UV <Y[ ]_ `` de 9fg Qhi jj Hll mm nn Pop Hrr Iss tt 8vv Hzz T{{ W| g K h C F g K y g h g h + N h C X g + g K g k h F | w c a g b a a g B g E g p h N h g C F g a + g h + N C X a  a C g K g X y T h C F  g h N X g C h  K g h + Z K g b h r g K  g K g g		 

 + 1 T 3 0 0 ;  0 S 2  7   !! "" ## 9$$ %% J.. 00 23 55 R66 08: ;; == >> S?? 5@@ AA 5LN 0  h a N h Z u g n p g e g N h $ j h * p h = p h w p h Z g * g  h  h j   @ g W o h i g j h c h a y j h Z g p w % w&- h./ j0? p@V hYY =ZZ h]] t^^ "__ -`` Maa bb >cc ldd (ee Yff !hq /r{ | . .      # #  ~ # % &  L ) A /    .  .  _ ` _ ` # & #   h  6 h 	 \     / . / .    [  [
  [ J 0 7 g / .$$ V%% U(( )) ** ,11 :: ;; << &=> HH FII &JJ #yy    & & h a h g p     p   	                                                                                                                                                                                                                                 	                                                                                                                                                                                                                                           
     
   
       
               +                     	 
 
 
             
              
 
 
                                                                                                                                                                                              
   C D w   Ehopqrstuw{| -0123456789:;<=>?@ABCJLMNOPQRSTUVWXYZ[\]^_`aey{&'()*+,-./@ABCDEFGHIJKLMNOPQRSTUVb<HI  O C D  w w          EE hh ou ww {|                    -- 0C JJ La ee yy     {{                              &/ @V    << HH II      r   M  ! M " $ N ) )  @ @  B B Q [ [ T ^ _  f f  m m  o o  u u  v v O            
         ,         U %% '' M(- 08 :; <C EF cKK cNN ;Of Ggg cin Goo npr G} c Z c ] C c ( c F  - c    l l ; l c (   ( ! (   ! c l @ n - " " " " n " " ` >		 %
 a a a n"" ,++ F0S cTT (U[ c__ cbe chh ;nn -pp .ss .uu .vx 0yy ,z 0 0 4 4 n o n ; n ; < = < > ; < B P  M P  

   O      !! "" $$ && M(( ** ++ S-. 33 77 == >? AB OEF JJ MM OOP MUV ]_ `` Ofg Rhi jj mm op rr tt vv zz G  c > C  c c 6 ; c > 6  0 c C " I < A n c ; c > C 6 c 6 ; > >  G c > C  c ; > c #  c 6 ]  I c =  		 

 6 N G  M M  M T   !! $$ S.. 00 55 	66 M8: ?? 
AA 
LN M  c ; c ] n % ; c * e c 5 n c  n c " n c ] 5 ( c ( c e $ 1 c e c c e c ] n " % "&- c./ e0? n@V cYY ZZ c]] h^^ '__ 9`` 7aa ^bb cc fdd 2ee \ff &hq Lr{ D| E E   m j k J J b J + d , k 3 K : L X Y D E E m _ H _ H J , J m k c  c  / g ? m D m L E L E m m
 m M T ) L E$$ W%% i)) ** 8++ // [:: V;; k<< ,=> mHH CII ,JJ Jyy m m k , , c c #P   %+> / `   
                                                                                                                                                                  	 
                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                     
                  
                                                                                                                                              
                                           
           
 
                                                                                          
                                                                                                                                                                                                                                                                                        9                                                                               	                                                   
               
                                         
             
                                                                                                                                                                                                                  ! I           I             .   2 7                                                             P C   8       !                                                                                           B B 8                            `                                 	     I                                                                                          
                                                                                                 
                                                                                                                                                 
               	                                                           2 	         >                  2 F   <      <              $ $                                          < 0   P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &                                                                                                                                                                                                                                      !            2         &         	                      8                / /                                                             	   %   /                                                                                                                                                                                                                                              
                             
           
                                                                                                                     	     	                                                                                                                                                                                                                                                                                                                                                                          	 	       
 
 
    	 	          
 
                                                                                                                                                                                  	                                                                                                                     
                                            
                                                                                                                                                                                                                                                    j                                                                                                                                                     	                                                                              
                                                                                                                                                                                      	                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	                                                   	                                            	                                                                                                                                                                                                             
                                         	           
                                                                                                                                                                       
 
         
                   
                 
                                                                                 	 	                                                                                                                         
      
                                                
                                                                                                                                                                                                              ]DD  Fg in #vv )} * 6 < A B C F J T \ ] ^ m {    , ./ DI KK bd fx z 	 //"zz#||$%*-./0245=?@BFGJKLOPUWZ[\^cgimotvyz{}~%0?ZZ  DD (FF GH %JK %LL MM NN 'Of gg in vv }        	  
       -  ( !    !        '         .     %             ,  		 
  	  
          %% && 
', ./ DI KK bb cc dd fg hh 'im nn oo pp qr ss tt uu %vx  z       #  # 
 #  # % " % #   $ %  % & % ' + ) * + ) , ' + ' ) - % // 'zz || ( , ( % , % % %  ' , % % % " % "       %  "  )  + '  ( , "   ' , %   , % % %  , (  % ' % % ,  " " "  % ,  * " , %  '     % '                 % 0? ZZ     %    f f Z    K08 Z:; ZDD NEF GJ NKK LM NNN $Of )gg hh Nin )oo "pr )sw T{| T}  J  C =  6  S 
    0     $   6  6  6     & T "  T X N L X L X L X L X " X L 1 L [  1 T N T <  T		 5
  T  T  T     N "! N"" #* N++ S,/ N0S TT 6U[ \\ N^^ N__ `a Tbe fg Nhh $im Nnn oo Npp -qr Nss -tt Nuu -vx 2yy z 2 T 2    N   " # " $ " $ / % / N < $ / H >? Zzz ){{ ?| N \  < = N \ _ N  N  3 $  < @ N 3 N \ N 2  = X L 1 T N ] T T N / N ^ N "  $  N < = N T 3 N  3 $ < @ T A T < N \ N @ _ )  < =  N  $ @ N <  Y \ N  3 C \ N ]  % N \  N \ N N

 3 )!! Z.. Z8: Z Z  T $  C G N D " N 5 N $  7 Q  9 "   "  L "  C N 9 N 6  6  Q 4 8 N ? E  P N Q  1  T _ Q  C N " L % L&- ./ Q0? "@V YY ZZ ]] '^^ __ :`` Vaa bb Kcc dd ee ff hq ,r{ I| ( (     B  R  M W    B .  ; , * + I ( O (          B    F  I  , ( , (    	  	
  	 N U , ($$ >%% (( )) ** !,- R:: ;; B<< => HH =II JJ yy   B    T  N 8   d  ,                                             
         
     
         
                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                             $%+/:     
           	$$ ++ // ::        +  !  " $  ) )  , 2 + 3 3  4 5 + @ @  Z Z  [ [  ^ _  d e + f f  g l + m m  n n + o o 	 u u  v v             +      +      +   *      *   +      !! +%% '' (- // 08 :; <C 
EF  KK  NN Of gg  in pr yy +}     (   $             $  $  $       &		 "" 0S  TT $U[  __  be  hh nn pp !ss !uu !vx %yy z % %  " "   #  # &  # '  ) )    +		 +

  +    * +   "" ## +&& ** ,, +-. // +22 33 77 ;< +== >? @@ AB HH MM OP RS +TT UV Y[ +`` de ll +mm ss +tt zz    & (        & %   ( #      & (    & &    & (     &       		       
 +   +    !! "" +## .. 23 +66 8: ;; +== +?? @@ +AA LN                    $   $          &-  @V  ZZ  [\ )bb      + *      11 +<< ?G )HH (II KK ) ) )  )  )        P  =   	   	    	 ! 
  	 	 	                                                                                                        "                                                                                                          	                                                                        	 	                     /   
            	     :                7 % 	                                                 	                   /   
           	     ?   	             2 % 	 	 	                                                                                                                                                                                                                                                                                                       	                                                                                                                                                                     
                                   
                     
                                                                   /                       D             $   8 +                                                                                        	                                                                                                                                                                                      	                      j             Y       $ `      	                     	     Z  ),-        
         	  	,-  t      1  !  " $  ) )  , 2 1 3 3 % 4 5 1 @ @  B B  Y Y  Z Z  [ [ ( ^ _ ) ` `  d e 1 f f  g l 1 m m  n n 1 o o  u u  v v  z  #   #   8   #   $   #      $   8   1      1      1   '      '   1     + 2   8!! 1"$ 8%% && 8'' (- 	// %08 :; <C DD 5EF GJ 5KK LM 5NN Of 
gg hh 5in 
oo 7pr 
yy 1}  3  9 .  /  "    & * &  4 4  4  /  /  /    4 0 7  5     7     ;    5  <		 ,
 ! < < ! < ! < 5 7! 5"" #* 5++ ",/ 50S TT /U[ \\ 5^^ 5__ be fg 5hh im 5nn oo 5pp qr 5ss tt 5uu vx 6yy z 6 6   5  7 : 7  7     5    -   % ) 1		 1

  1 %   ' 1 ) # $ "" ## 1&& ** ),, 1-. // 122 %33 )77 ;< 1== >? @@ %AB HH %MM OP RS 1TT %UV )Y[ 1`` de %ll 1mm nn ss 1tt 	zz 
| 5   . 5 5  5     5 5 5 6  .    5 5  5 5 7    5  . 5 5     5 5 
   . & 5   5   5  9 5   5  5 5 5		   
 $    1   1 (   !! "" 1## %-- #.. 23 166 8: ;; 1== 1?? @@ 1AA LN |} #     9 5 7 5 , 5    7  7   7  9 5 5 /  /  5  5      9 5 7  % &- 0? 7@V ZZ bb +    1 '     ( 511 1<< HH .II      5       9                                                                                                                                                                                                                                                                                                                                                    	             (                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                  	                                                            	 ?                     	    ? 	                  8  ]a  cf h 	 1 @ A C G I L S  ]] 	^^ __ `` aa cc dd ff hq r{ 
|  
   
   
       d      +  !  " $  ) )  , 2 + 3 3 
 4 5 + @ @  B B * Y Y 6 Z Z  ^ _  ` ` 6 d e + f f  g l + m m  n n + o o  u u  v v    7            7   +      +      +            +      '   7!! +"$ 7%% 	&& 7'' (- // 
08 :; <C DD /EF 0GJ /KK 0LM /NN Of (gg 0hh /in (oo 2pr (yy +} 0 0 ,  0 1 0 8   0      - -  - 0 1  1  1   0 -  2  / ) ) ) ) 2 ) ! ) "  ! / 		 
 . . . / 2! /"" #* /++ 8,/ /0S 0TT 1U[ 0\\ /^^ /__ 0be 0fg /hh im /nn oo /pp #qr /ss #tt /uu #vx $yy z $ $  4 / 4 2 3 2  2  % 5 % /   % &   
  +		 +

  + 
    +   "" ## +&& ** ,, +-. 	// +22 
33 77 ;< +== >? @@ 
AB HH 
MM OP RS +TT 
UV Y[ +`` de 
ll +mm nn 6ss +tt zz (| / 0   / / 0 / 0  0  / / / $ 0  ) ! / / % / / 2 0  0 /   / / 0    / / ( 0    / 0  /  0 / 0 , / 0 5 /  / / /		   (     +   +   !! "" +## 
.. 23 +66 8: ;; +== +?? @@ +AA LN   0  0 , / 2 /  /  0 0 2 0 2 0 ) 2 0 , / / 1 0 1 0 / 0 / 0 ! 0 0 , / 2 ) % )&- 00? 2@V 0ZZ 0bb    0 +  0    /11 +<< HH II    0 0 /      P T      
  	   [\ 
?G KK               h    
 ^    	                                                                                                                                                                                                 	                                                                                                                                                           
                                                                                                      {              	j       k                                                                                                                                      	            	   	    	  
                                                  	 
                                     
                                                 
         	                       
                                                                                                                                                                                                                                                  
                                            	               
                                                                                 ' "()+012489:;@ACDJLNaciuvw$7  "           "" () 	++ 00 11 22 44 88 99 :: ;; @@ AA CC DD JJ LL NN aa cc ii vw  $$ 77     /     ! / " $  , 2  3 3 \ 4 5  ^ _ 9 d e  f f  g l  n n  v v    4      6         7      7       C !! %% '' /// \08 :; DD IEF KGJ IKK KLM INN Of :gg Khh Iin :oo Tpr :yy } K K  Y K L K K B B  K L L L K T I T    I W		 H I T! I"" #* I,/ I0S KTT LU[ K\\ I^^ I__ Kbe Kfg Ihh im Ioo Iqr Itt Ivx yy z   I T T  T  U V U I W  U 0 1 / 0 \ 9 1 4 		 

    \   1 7  9 !! 2"" ## $$ 	&& /(( 8** 9++ [,, -. // 22 \33 977 ;< == >? @@ \AB EF HH \JJ 1MM NN 4OP /RS TT \UV 9Y[ ]_ `` de \fg hi jj 1ll mm op 1rr 2ss vv 1zz :{{ <| I  K W Y I   I K I K   K W  I  I  I  K Y  I F I U I X I T K  K I W Y I  I K   W  $ W I  I   : K W Y B I K @   I W K &  I K    I F K V I   I  I I		 

   : / /  / 4    !! "" ## \$$ [%% 5.. 23 55 366 /8: ;; == >> 4?? 6@@ AA 6LN /  K  K  Z I T I H I  K N K Q T K = T K T K  I Q I L K L K N G O I < R K M I N K  K  N K  I T&- K./ N0? T@V KYY =ZZ K]] -^^ __ S`` ]aa Dbb Ccc +dd )ee >ff 'hq r{ | . . " 
  #    A J  (   P *      .  .  % E % E      K  7 K     .  .    ?  ?
  ? 5 / I  .$$ ;%%  )) "** ,11 :: !;; << => HH YII JJ yy      K K I    | 	 @                                                                                                                                 
 	 	   	 	  	  	  	                                                                                                                                                                                               	 	  	     	       	                                                                                         
                   	                                                                                           	 	      	    	       
                                               
 
                                    
      
       
     
   	                                               	                                        !}~	
  }                        	
         (EF KK NN Of "gg in "pr "}   ' 3    4 4       6		 7"" 0S U[ __ be hh vx yy z     1   1 6  1zz "{{    6 3        6      3  + 1 2    6 3     6   6    "  6 3 4    6      '  +     

  "    ' ; 7   8       '    8 9  :  8     8  '&- ./ 8@V YY ZZ ]] ?^^ __ 0`` /aa )bb (cc -dd ee &ff 5hq r{ | ! ! $  
 =    	 ,     .       !  ! 
  *  *    
    
  
  !  ! 
   > 
 >
 
 >  !$$ %%% #)) $** :: <;; << => 
HH 3II JJ yy 
 
                                      
                                          	 $%:       $$ ::   #      $$ (( ++ EF JJ ]_ fg jj op vv       	 
        	  

 $$     f     	                                                                          	                   	 	     	          	 	                         	                                                                   
                                                                                                                   j        j #         )      	 
          /       !! $$ (( ++ EF JJ ]_ fg hi 
jj op rr vv          	               

 $$      T                                                                                                                                                                                                                                                                    	                       
       	             	              ]]  _a cf h  0 ? @ B F H K R  ]] __ `` aa cc dd ff hq r{ 	| 
 	   	 
 
 	  
  
  
  1       !! $$ (( ++ EF JJ ]_ fg hi jj op rr vv {{     	  	   
 	 	         	    

 	$$       
  C                                                                                                     	                                                                                                                                                                                                                                                                                                   %%  ,, /0 33 55     %% ,, // 33 55    R      2  !  , 2 2 3 3 0 4 5 2 Z Z  [ [  d e 2 f f ( g l 2 n n 2   2      2   2      2  ' ' ) '!! 2%% .'' (- /// 008 (:; (<C DD EF GJ KK LM NN ,gg hh oo @yy 2}    &     ,      @  @ 		   @! "" #* ,/ 0S TT U[ \\ ^^ __ be fg hh ,im oo qr tt yy   @ @ , @ ,  ,  0 2		 2

 ' - 2 0 ' 2 '"" '## 2&& ,, 2-. .// 222 077 ';< 2== '>? (@@ 0HH 0OP RS 2TT 0Y[ 2]_ -de 0ll 2mm 'ss 2tt /{{ 6|   &       ,      &     @  ,   &    ,     &   ,            		 '    2   2    '!! ("" 2## 0%% 3.. (23 255 166 8: (;; 2== 2?? @@ 2AA LN  (  ,     > @    ,  ;   " @   @  @    "       :   6 ?  <          @&- ./ 0? @@V YY ZZ ]] A^^ __ %`` #aa bb )cc =dd  ee ff +hq r{ B|     
 7 8       8  !   B   
 	 * 	 *    
 8  2  
 B 
     
   9 
 9
 
 9 3     $$ 5%% )) ** $11 2:: 4;; 8<< => 
HH &II JJ yy 
 
 8         l  A                                                                                         	  
                                                                     	                            	 
                                                                                                                                                                      	 	 	 	                                                                     
                         	                                                       	                                   	                                                                               	                                      	   
                                                                                       	                    	                                                                                                  	                                                                      
 
                                                                                                                                                                                 	                                     	                                        	             	                   	                                	               
                 	 	   	 	   +Y        
 	   
     YY      . (EF KK NN <Of !gg in !oo pr !}  %   5     ' <        +  +		 
 , , , "" .0S TT U[ __ be hh <pp /ss /uu /vx 0yy .z 0 0   <  < 3 3 < 3zz !{{   5    <  0  5 + * 3 4   <  5  < #  !  5  <    *  !  <        <                            +      &- ./ 0? @V YY ZZ ]] ^^ __ `` 1aa )bb (cc dd ee &ff hq 8r{ 6| 7 7 "    $ - - 9 -  . $ ; : 2 8 > ? 6 7 @ 7  	 
 	 
 - . -  $    6  8 7 8 7  
  8 7$$ %% )) "** :: =;; $<< .=> HH 5II .JJ -yy   $ . .   d     
                
 
   
                                                        8                                 
                                                                                                                                                                 $%(*+/2:           
$$ (( ** ++ // 22 	::   00       	YY                
 ;; => JJ yy    p     s    	 	 	  	                                                                                                                                                                                                                                                                                                                                                                                                                                                                       	                                                                                                                                                                                                                                     	                                                                                                                                                                                                                                                                                                                                                                                                                                                          
              
           
 
  	 
  
 	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                           	    t   
   	    	                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   t                                                                                                                                                                                                                                                                                                                                                                                                                           .
);=>Jy  $  	      
         	       	  	 	 	 	

 	;; => 	JJ yy 	 	        [  !  " $  ) ) > , 2 [ 3 3 ? 4 5 [ @ @ > Z Z 8 [ [ = ^ _ A d e [ f f  g l [ m m  n n [ o o  u u > v v X   ]   :      :   ]   [   ;   [   >   [   <   k   <   [   >  "   ]!! ["$ ]%% && ]'' (- ^// ?08 :; <C EF jKK jNN 2Of Bgg jin Boo npr Byy [} j j V j ( j D N j E F E ! d d 2 d j ( $ ( e ( $ e j d T n N n H g  H 6		 J
 i i i n"" k0S jTT (U[ j__ jbe jhh 2nn Npp *ss *uu *vx ,yy kz , , ! / / n o n 2 n 2 3 4 3 6 2 3 7 !     ? A  [		 [

   [ ? X   < [ A : !! 9"" ## [$$ && (( @** A++ \,, [-. // [22 ?33 A77 ;< [== >? @@ ?AB XEF HH ?JJ MM XOP RS [TT ?UV AY[ []_ `` Xde ?hi Yjj ll [mm op rr 9ss [tt ^vv zz B{{ `  j 6 V  j j 0 2 j 6 a 0  , j V H & 3 U n j 2 j 6 V 0 j 0 2 6 a  6  a B j 6 V E j 2 a 6 j I  j 0  & j 4  		 

 0  B :    [  8 [ =   !! "" [## ?$$ \%% r.. 00 23 [55 Z66 8: ;; [== [?? ;@@ [AA ;LN   j 2 j  m n J 2 j   j  n j  n j n j  ( j ( j  
  `  j   j H j  j n&- j./ 0? n@V jYY ZZ j]] p^^ '__ Q`` 1aa #bb "cc ldd -ff Khq W| q q _  	     ) M k  O . R W  q q 	 f G f G  k  	  j [ < j >   ! % h + 5 S 	 	 W q W q 	 	
 	 r  = L W q%% C(( b)) _** P// c11 [;; << k=> 	HH VII kJJ yy 	 	  k k j j p   J                                                                                                                                                                                                      	  	            	     	            ]]  __ aa cf h  / > ? A E G J Q  ]] __ aa cc dd ff hq 
r{ | 	   
  	 	  
 	 
 	 
 	  )%% 00 55              ./ YY   	 
 
 
 	  
 
  	    
  ;; 	=> JJ 
yy   	    
* DFLT cyrl 0grek Flatn \           * 8 P          + 9 Q          , : R @ 
AFK  RAZE  fCAT  zCRT  KAZ  MOL  PLK  ROM  TAT  TRK        - ; S        . < F T      ! / = G U      " 0 > H V      # 1 ? I W      $ 2 @ J X    	  % 3 A K Y    
  & 4 B L Z      ' 5 C M [      ( 6 D N \      ) 7 E O ] ^calt6calt6calt6calt6calt6calt6calt6calt6calt6calt6calt6calt6calt6calt6ccmpJccmpJccmpJccmp@ccmpJccmpJccmpJccmpJccmpJccmpJccmpJccmpJccmpJccmpJdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRdnomRfracXfracXfracXfracXfracXfracXfracXfracXfracXfracXfracXfracXfracXfracXligabligabligabligabligabligabligabligabligabligabligabligabligabligabloclhloclnlocltloclzloclloclloclloclloclloclnumrnumrnumrnumrnumrnumrnumrnumrnumrnumrnumrnumrnumrnumr                                   	                                         
    2 2  L    
6~L>Z            {         .   >!2x   -   =~ 1w     
 $      .                                 	           
 
  "          P |}~       $ rstuvwxyz{  ]f   
                     ]f       
 "     4                     r{    |                            ( 2 < F P Z d n x     x   x   x   x   x   x   x   x   x   x   x  : %  s\fmv     
 D     4        &'  *+ B^ ~ ! )       .        &'  ** B^ ~    !     
   6  L           :               &  LW  bb lm          %        z      &  P            >        ]`  bk m~    "  L\  aa                   r         C  yA     
      @  $         .             &  'LMNOPQRSTUVWYblm            y         
                 H -.!%!!!!!!!!%%%%%%%%%%%%%%%%%%%rstuvwxyz{         OO   00  !! &, B | oLW yYY bb lm                    GDEFdd X(  rGPOS}Nl Y  GSUBr f  O4OS/2 d   `STATc    ^cmapeS   
Bgasp    X    glyf    headC    6hhea @   $hmtxL 	  .locaO

    	 maxpo      name>__ &  postaG (  /preph &     Z     	  3!%!!Z,,&2; ;  2  &    33#'#3'&&'2y[00B8&@VV?  2  &&    Y  2  &&    ]   2  & &      2+& &]  &    B
  2  & &      2  & &      2  & &      2  &&    \   2  &&    [   2  g &      2+& &[  &    B
  2  & &      2  & &      2  & &      2  &&    V   2+&&    B
  2  &&    X  2  &&    >   2  &&    `    25I   !  "&5467333%3#'#3'&&'7C&/K"<y[00B85(:!	-<&@VV? 2  &&    ^   2  &&    _      :    3!#3#3!5#3#(68RR Rr    :&    Y#   ]     $  332'56#'32654&##532654&##]dq*M6:U/4`C|?II?|v:CB:wdY2J(.V;>\1QC:<KN>55>   X   "&&546632#4&#"326530Ba55aBB`4ZA;;CC;;AZ4`
2_AJB^23^A>CB>>CC>@_3 X&    Y#  X&    \   X5  2  532654&#73#7"&&546632#4&#"32653F72#98&B6	Ba55aBB`4ZA;;CC;;AZ4`7_=$"12_AJB^23^A>CB>>CC>@_3  X&    [  X&    W   \       332#'32654&##\Gg99gGccBKKBc6bCCc6PJB#AJ  
        5!32#'32654&##
Gg99gGccBKKBcOKK6bCCc6PJB#AJ  \   & !   \    
        5!32#'32654&##
Gg99gGccBKKBcOKK6bCCc6PJB#AJ   d     3!!!!!d(KRQR  d  & %   Y2  d  & %   ]  d  & %   \  d  & %   [  d  g& %      d+ &[  & %   B  d  & %      d  && %      d  & %      d  & %   V  d  & %   W  d+& %   B  d  & %   X  d  & %   a   d  & %   `   d5    "&5467333%!!!!!7C&/K"<W(K5(:!	-<RQR d  & %   _   _   	  3!!!!_<RR  X #  "&&546632#4&#"32655#530Ba55aBB`4ZA;;CC;;A4`
2_AJB^23^A>CB>>DD>ZR@_3 X& 8   Y  X& 8   ]   X& 8   \   X& 8   [   X& 8   f  X& 8   W    ]     3333##]ZZZ8&P  
  N    5!333##
DZZZKK8&P ]  & ?   [    i     353#5!#3iR6RRR  i  & B   Y  i  & B   ]   i  & B   [   i  & B   V   i  & B   W   i+& B   B   i  & B   X  i  & B   a  i  & B   `    i5    "&5467333%53#5!#337C&/K"<5(:!	-<R6RRR i  & B   _    -   "&533265#5!ixZG@@G	y
vfCIICRfv  -& N   [<   \  0   3333##\Zlbgi9R  \0& P   f    s     33!sZJxR  g  & R   Y  s  & R   7  s& R   f  s  & R   C         	  75%3!rZJPP xR   L     3366773#4>7#LvL
HvX
v_w
 ??!&	,puk(m'gsr1   Z     33.53#ZxWxIQ$&qIQ%f Z  & Y   Y  Z  & Y   \   Z& Y   D    ZL   53265#3.53#A5>WxW3\>R=4bIQ%fIR$M5;X0 Z  & Y   _    X     "&&546632'2654&#",B_33_BB_33_B;??;:@@
2_AJB^22^AA_2QC>J>CC>>C  X & _   Y  X & _   ]   X & _   [   Xg& _      X+  &[  & _   B   X& _      X&& _      X & _      X & _   V   X+ & _   B
  X & _   X  X & _   a   X*   +  5326553#"&&546632'2654&#"K90}B_33_BB_33_B;??;:@@{AKP+4{2_AJB^22^AA_2QC>J>CC>>C X& l   Y  X+*& l   B
  X& l   X  X& l   a   X& l   _  X& _   Z   X & _   `    X5  $ 2  "&54667""#"&&546632332654&#"{7CB_33_BB_3+'!<;??;:@@5(!$2_AJB^22^A;Z-<C>J>CC>>C  #5   #  37"&&546632'2654&#"#TBB_33_BB_33_B;??;:@@(2_AJB^22^AA_2QC>J>CC>>C  #5& u   Y  X & _   _    (?  -  "&&54663235!#3#3!5#'2654&#"0F%%F0#.	.
*00**00
.V:r;U.)PRRRP*P;3r3;;33;  \  &    332##32654&##\Dd77dD;GG;5`BAa5}I=>H   Z  &    3332##32654&##ZZBa6vc:BC92Z<[mA78@   PL  %  '"#"&&546632'2654&#"k
Cc66cCDb6:5u;GG;;GG5aA@B`55`BCdJ=@>II>=J   \  !    332##32654&##\Ab6MBju8DD85^?Jj6G:;F  \  !& |   Y  \  !& |   \   \!& |   D    H *  "&&'332654&''&&546632#4&#"0Hg8ZKC?G/,cKQ5`A`tZA;:A0-dIP8e
0Z>7@>7,BlI;W1kY6=82-B nJ<Z2  H&    Y  H&    \    H5  =  532654&#73#7"&&'332654&''&&546632#4&#"F72#98&B6Hg8ZKC?G/,cKQ5`A`tZA;:A0-dIP8e7_=$"10Z>7@>7,BlI;W1kY6=82-B nJ<Z2 H&    [   H&    D    \   "  34663356##532654&##57#"\4_?9V/6`AC9<FF<-7A>]3X3^@@a6RH=<FNB:  Z  $  "&&55!54&#"#46632'2655#7,A^3J=;:>Z2^BC]23^A>:;
4_?>CD>A^32^B?_4KFAAF  7  !   3#5!#RRw   7  !    5!#5!#n|'KKRRw 7  !&    \    75!    532654&#7#'#5!#F72#08&B6N7_#$"1RRw  7!&    D   Z   "&5332653,flZ;=<<Zk
qa<FF<bp Z&    Y  Z&    ]   Z&    [   Z&    V   Z+&    B   Z&    X  Z&    a    ZSH    5326553#"&53326532K90flZ;=<<ZkAKP+4]qa<FF<bp  ZS&    Y  Z+SH &B
     ZS&    X  ZS&    a   ZS&    _   Z&    Z   Z&    `    Z5 &  "&54667""#"&&533265333{7CB^2Z>:;=Z)'!<5(!$2_A>CC>;Z-< Z&    ^   Z&    _    2  &   336673]|{[4YY4&    ? $  33>73>73#.'mTV7D]>9RVq>C/**//**/&&,&&,    ?&    Y    ?&    [     ?&    V     ?&    X   (  0   3366773#'&&'(hq		scg}		~rh'''&  #  5   336673]]##,7 #  5&    Y  #  5&    [   #  5&    V   #+5&    B
  #  5&    X  #  5&    a   #  5&    `   #  5&    _    U   	  35!5!!UISZ.RZR  U  &    Y  U  &    \   U  &    W    A0  '  "&5463354&#"#6632#5#7'2655#"WddU=81BZ	tW_nX]7@R-4?
YLMX737)#GTbTi<FG@2N2+.5 A&    5#  A&    :  Az&    w   A+ &: &    B  Az&    x   A&    y   A&    z   A&    9  A&    8  Aq&    {   A+ &8 &    B  A!&    |   A&&    }   A&    ~   A	&    2  A+0&    B  A&    4  A9&    >  A&    =   A510  , 7  "&546733%"&5463354&#"#6632#5#7'2655#"7C&/@"<WddU=81BZ	tW_nX]7@R-4?5(:!
,<YLMX737)#GTbTi<FG@2N2+.5 AD&    ;  A&    <   #50 4 @ I  "&55463354&#"#46323>32#32653#"&&'#'2655#"354&#">ISFJ ##UI<'41%DM% &UPA%27 (H"#%!$
L@<>IJ,("?M%%VJi%."?M%%M.%i#<"K&--& #5&    5   \  $  "&5##334632'26554&#"LDRZZSCSddq9BB97AA
I?i}>Jn_^nND@@DF>>F   U0   "&&5546632#&&#"326730Bc66cB_tZA8;FF;8AZt
2_AB^2fX59C>>D:4Xf U&    5"  U&    9   U50  0  532654&#73#7"&&5546632#&&#"32673F72#98&B6
Bc66cB_tZA8;FF;8AZt7_=$"12_AB^2fX59C>>D:4Xf  U&    8   U	&    3    U  $  "&554632'3'53#5#7'26554&#"RedSDRZZR&8@@89BB
n^_nJ>}&i?INF>>FD@@D   F ! .  "&&5466323&&''57'37'2654&&#"+Dh95_?.  AxHh,jN,5:gF@M#?+>MM
8fCCc7
5%[LP8c@EP1q@@Fi:PPA,A$PAAP  ?X   (  53"&554632'3'53#5#7'26554&#"Z
LYYL>IZZI 2772188&l[\lJ>}&i>JNC<<CC<<C  ZX  $ (  "&554632'3'53#5#7'26554&#"5!R`_SDPZZP&8>>89==	^
n^e_nJ>}&i?INF>Z>FD@Z@DKK  U0  #  "&&5546632!3267354&#"!,Aa55aAAa5B=4@Z	u(A>=B
4_?@^44^@a5AE%%EQC%AFFA  U&    5  U&    :   U&    9   U&    8   Uq&    {   U+ &8 &    B   U!&    |   U&&    }   U&    ~   U	&    2   U	&    3   U+0&    B   U&    4  U9&    >   U&    =    X5 0 , 6  "&5467""#"&&5546632!326733354&#"!u7CA_44_AA_4?=4=Z2'"<>>=? 5(34_?@^44^@a5AE%%+@-<EAFFA  U&    <    Z0  #  "&&55!54&#"#6632'2655#7,A^3L<>4:Z	pWA^33^A><=
4_?a5AE%%EQ4^@?_4KFA%AF  <     3#5354633#"3#RH!R_AKR_Rc  XL0  ,  5326557#7#"&554632'353#26554&#"*'PCUbbUCPY[Q%8@@89??R&(Fd<Fo^t^nF<iJV%F>i>FD@i@D  XL&    5  XL&    :  XL&    9  XL&    8  XLp&    @  XL	&    3   \     3334632#4&#"\ZNESbZ?68AiAGfXh;AF@         &    8j  U  +	&    3   U  +& 	  353#5!3URR,R  U  +&    5-  U  +&    :  U  +&    8  U  +	&    2  U  +	&    3  U++	&    &3  B  U  +&    4  U  +9&    >  U  +&    =   U5+	   &  "&5467333%53#5!3"&54632B7C&/K"<!&&!!&&5(:!	-<RR,R"##" U  +&    <  UL	&   3U   UL&   53265#5!#U>E@xeSC=Rar UL&   8   _  -   33373#'#_Zjgiki _-&   D   a  #&      &   !"&&5#5!33w0H(& &F/R"'R    &&	   Y    &&	   7   &&	   D  
  v &	  C       &    75%"&&5#5!33dr_0H(& PP &F/R"'R   B  0 '  3334632'34632#4&#"#4&#"BO1*.2*3*49SH&B.6D>6.6N@^"&%"\#%%"\   \  0   3334632#4&#"\ZNESbZ?68A&iAGfXh;?D@  \  &   5#     &   DBu \  &   9  \0&   D    ^L0   532654&#"#334632#?5>=68?ZZLES`3\>R=4Y;AF@&iAGfX;X0  \  &   <   U.    "&&5546632'26554&#",B`55`BB`55`B;BB;:CC2_AB^22^AA_2PB@@BB@@B  U&   5  U&   :   U&   8   Uq&   {   U+ &8  &   B
  U!&   |   U&&   }   U&   ~   U	&   2   U+.&   B
  U&   4  U9&   >    U   +  5326553#"&&5546632'26554&#""K:/B`55`BB`55`B;BB;:CCAKP+4'2_AB^22^AA_2PB@@BB@@B U&$   5  U+&$   B
  U&$   4  U9&$   >   U&$   <  U&   6   U&   =    X5 0 $ 2  "&5467*#"&&55466323326554&#"t7C"B_33_BB_3.+"<;??;:@@5(/2_AB^22^A>[-<B@@BB@@B  #5N   #  37"&&5546632'26554&#"#[HB_33_BB_33_B<CC<<CCl2_AB^22^AA_2PE=>DD>=E  #5&-   5  U&   <    #50 ( 6 ?  "&5546323>32#32673#"&&'#'26554&#"354&#"CNNC(33(CN$%U
L8(33$$ &&& $
WIJV%%VJd&- >I%%M-&&--&&- M&--&  \L0  %  334632#"&5#726554&#"\ZSDSc-Q8CTy9AA97BBi?Im_?\2J>}D@@DF>>F   WV   (  537"&5##334632'26554&#"WZDRZZSCSddq9BB97AAI?i}>Jn_^nND@@DF>>F   XL0  $  57#7#"&554632'353'26554&#"RDSabRDRZ8@@89??}>Jn__mI?i&F>>FD@@D   o  0   3334632#54&#"oXMLWgZ?:9A&iAY[m]!AEF@  o  &4   52  o  &4   9  0&4   D[    Z. ,  "&&'3332654&''&&546332#&&##"#8S1Z5,*54/.JQO^^&O`
Z0)&3/(+JYQab#@,"+$#)IFJQJ?&&" LHLW  Z&8   5(  Z&8   9
   Z5.  ?  532654&#73#'"&&'3332654&''&&546332#&&##"#F72#98&B68S1Z5,*54/.JQO^^&O`
Z0)&3/(+JYQab7_=$"1#@,"+$#)IFJQJ?&&" LHLW Z&8   8
  Z.&8   D   \   ,  346632'56##532654&##532654&#"\4_@@`5+O6:U/6`AB8<FE=,*8?@77B>]3+S<2N,.V;=^5RG::BNF5:@B:        34633#"]L#,;GXP,$  7     !"&5#53533#33hGOZ<LECRR?R  7      75!"&5#53533#33UsGOZ<KKLECRR?R  7  (    73"&5#53533#33tZZd\GOZ<lLECRR?R  75  %  532654&#73#7"&5#53533#33	F72#98&B6
GOZ<7_=$"1LECRR?R  7&@   D    Z&   "&5332653+_rZ@78AZt
qa^>EE>^aq Z&E   5  Z&E   :   Z&E   8   Z	&E   2   Z+&&E   B   Z&E   4  Z9&E   >    ZX   733265326553##"&ZZ@78AFK+/t__r^>EE>^KP+4aqq  ZX&M   5  Z+X&M   B  ZX&M   4  ZX9&M   >   ZX&M   <   Z&E   6   Z&E   =    Z5& %  "&5467*#"&533265333t7C"bpZ>:;=Z,+"<5(/pb^@BB@^>[-<  ZD&E   ;   Z&E   <    7  !&   336673\z
w[&!==!r  #  5&   3366736673#&&'{XP7	=V=		9L\c;
>&z33z33|88 #  5&Y   5  #  5&Y   8   #  5	&Y   2   #  5&Y   4   2  &&   3366773#'&&'2jmnijvw		  7L!&   736673Qdxa//T&  7L!&_   5  7L!&_   8   7L!	&_   2   7+!&&_   B    7L!&_   4  7L!9&_   >   7L!&_   =   7L!&_   <    Z  & 	  35!5!!Z4EZzRZR  Z  &h   5  Z  &h   9   Z  	&h   3      )  5#54&#"#6632"&54633#"32653#u#$2=15>-681ee"',
37&*0*/''.($-        "&554632'26554&#",4??44??4$$$$:/P/::/P/:($P$$P$ 2  &     ^      3!!32#'32654&##^yFd77dFyy>FF>yR5`AA`5RG=>F ]       n     3!!nRx n  &q   Y#   n  9   3!53!nTU_x  t?    53>7!3#5!73#-vFPz; DV/s=Mv  d   %   d  & %   V     L   333333####z^h*L+g^x]p-L-qxbDDVV  5 .  "&&'332654&##532654&#"#46632'56"Dh=ZP=DOPCZY=JI>=JZ8eDi|+O6:U/;m
0X;5>H:;GRL78=E8>\3`Y2O,/W;?a8   Z     333#4667ZWxWf$QIq&%QI Z  &y   ]   \  0 P   \  0 &Y  P       53267!###,'xZQVTO`&v} L   X   ]   ?   X  _    ^     3!##^Z&x  \  & y   X    7  !     2  &   3736673Jbsb"=="e& 2  &&   ]    6"  ! +  5"&&554663532#'"3266554&&#=\32\>T>\23[>T%66y&55&F4]?A_5FF5_A?]4F!=+);  ;)+=! (  0     K     !#"&55332673G3^oZG;0>
Zr`;Gq&  ^t5   5!3333yZZKvv   @     333333BTuHtSjj&   @t?   5!333333QQtFtQ/rrr   ^   5#333#ZZ}}x&}   ^  &    3332#'32654&##^ZBc77cB;II;6`A@a6RI<<I    &    3#5332#'32654&##iBc77cBid;II;dR6`A@a6RI<<I   A       3332#'326554&##3AT)[ih\))5995).TfX3XeO;425:& D  !  53267!32####%326554&##<HXXHJ?^<$,,$<P@7UFxFU3\kP,$x$,  5  D    333332###7326554&##5PP<JVVJ<&**&<,TGxGTcK+%x&*  H     Z #  "&&546632#4&#"3#326530B`44`BB_3Z?;;AA;;?Z3_
2_AJB^23^A>DC>zR>DD>@_3   T #  "&&5332655#5354&#"#46632(A`3Z@:;AA;:@Z3`AC_44_
3_@>DD>Rz>CD>A^32^BA_2  i   B   i  &   V   - N          3#5!#7632#4&#"nn@xLWGUZ-*8:,OORaR(=>>/   <0  #  "&55##3354632'2654&#"MZOSSOYNP[[P+--++--
fXYefXXfN:6r6::66:   8      3&&546633##3#"8BL6bAZty7ED@jJ?^5&6G;:H    L    532654&#"##5!#7632#F5>-*8:,Zn@xLWGU3\>R=4=>>/OORaR;X0 #  5     Z      "&54632'2655#354&#",bppbbp3^A;>??>;;>
qbIbppbA_3OD@@DYt@CC@ A0     Z  (  "&554633#"36632'26554&#",aq{QTNCWa2^B:>>::>>
sdZ_ZA;BpbPC`4PFAPAFEBPAF  ^  &   !  332#52#'32654&##532654&##^V^N@FUdZ0550*10+&ME9EF;JSO*&'*N($$)    &   3!!&R,   &   5<        3!53!6U&i,  t5&    53667!3#5!73#-%gFP< dM'Ob U0    U	 &2         F&   33353373#'##5#xpW`5L3cVpxZd6L6e  A- /  "&'3332654&##532654&&##"#66332#Wo_=./1753yv.0*2(:_
nO2;T-@:G@l[J? .%(.N,$"$>P%D/1?B>IV  ^  &   333#4667^VsV&@9,@;) ^  &   :   a  #&   33373#'#aZ^gi_&  a  #&   5   &   53267!###.%uZ#I;TH]4Wl2   L  &   3366773#54>7#LzH
DzWb_c& ??!U-jla%7-BU   ^  &   33353#5#^ZZZ& U.    ^  &   3!##^Z&,  \L01   S0     7  !&   3#5!#OO)  7L!&_   7L! &: _    6L"   #  5"&55463532#'"326554&#`no_P`nn`N:BB;AA;l^]kk]^lD==FF==D 2  &&^    N  &   !5#&55332673A$fqZE=*;Ze[3;  ^t5&   5!3333yZZK&**   @  &   333333BTuHtS&   @t?&   5!333333QQtFtQ/&&&&   ^&   5#333#ZZ}}&,}   b  && 
   3332#'32654&##bZ]kl\4774&]QP^R/--/     &&    3#5332#'32654&##x]kl\xx4774xP]QP^R/--/  A  & 
    3332#'32654&##3AT-YggY--5;;5-.T&]QQ]H6006&   I&  !  53267!32####%326554&##<HXXH{IAY<$,,$<U>4dUE*EU[lO,$*$,   @  B&    3335332###7326554&##@SI=HXXH=$))$=&UF(FUK,$($, Z.8    Z0 !  "&&5546632#&&#"3#326730B`44`B_rZ?8;AA;8?Zr
2_AB^2fX59C>P(>D:4Xf  T0 !  "&'332655#5354&#"#6632(_rZ@7;AA;7@Zr_C_44_
fX4:D>(P>C95Xf2^BA_2 U  +	&    3  U  +	&    2  UL	&   3U         53533#36632#4&#"#\ZL?SbZ?68AZ:KUUKPi7<fX,;AF@:  >&0  #  "&55##3354632'26554&#"ETXSSXSFJZZJ&++&%**
^LS&KM]]ML^F5//55//5  <  &    37&&54633#5#35#"<?Ek]Zyh2::V@Q\1,+1   L &  532654&#"##53533#34632#%>E=68?Z^^ZLES`xeSC=;AF@:KUUKPiAGfXar <L&    Z0   #  "&&5546632'2655#'354&#",@_33_@@^44^@;?@@?;:@
3_AA^34]@@_4OD@''@D#?DD? 2  &    ]      n  q    2  &    33#&&'#5!2y[{z!&4[Z4PP  d   %   U      ]   ?    X    #  53"&&546632'2654&#"_B_33_BB_33_B;??;:@@PRR2_AJB^22^AA_2QC>J>CC>>C  i   B   \  0 P    2  &   33#.102y[{z&0J++J/  L   X   Z   Y    P       5!5!5!PHf|RRxRRIRR  X  _   ^     \  & y    7     355!!'7!7>HH6RRP[P  7  !    #  5    6"   (  0     6  "   !5"&&533326653#=\3T6%T&5T3[>4]?`);  ;)`?]4   2  ' )  3535.5466323#52654&#"326%6cCDb6%5(2G;;G2(P#E5B`55`B5D#PnI9>II>9In  
  &&   u)    & %   u     'u   ?     'u   B    'u   _    5 'u       '&   u   i  &   V   #  5&   V    \LD    5326553#%333##l-8V_\ZlbgiO7.GGX\9R   Z0  #  "&554632'353#5#7'26554&#"S_`RDPZZP&8>>89==
n__mI?ii>JNF>>FD@@D  \L  )  46632##32654&##532654&#"\4_@@`5>7=F6`A{<FE=,*8?@77B>]3+S<=V_H=^5G::BNF5:@B:  <L&   5310>73\xu[&))m  F  )  7466327'5!!#"&&7326654&&#"F3Y9)t0#;gCCh:\#>()>$$>)(>#?b8	VKAX5Af::fF,D&&D,,D&&D   P- /  #"&54675&&5466332#&&##"33#"332673F/[lAF:@-T;2Pm
_9)2)0.vy3571//<_
pVI>B?1/D%P>$"$,N.(%. ?J  DL   74>7!5!332#76##"&D.NvR2D*7/JFZ5[d"BJ]xORZ3PC9/7:F0`  \L0   3334632#4&#"\ZNESbZ?68A&iAGfX;AF@   X    #  "&&546632'2654&#"!!,B_33_BB_33_B;??;:@@N
2_A@B^22^AA_2PB@@@BB@@BJN   7  &&   !"&&5#5!330H("& &F/9Ru"'R  a  #&    2  &   3'3#&&'2J`bt&e#<<#  ]L&   332653#"&&'#2]Z=78>Zj\.@$;BB;d^n$%  7  !&X    BN ,  7467&&54632#4&#"33#"332#76##"&BEB:?{hGe7ZJ==JJ=YYGMMGXJFZ5Xv}G^W>Vc2\?8E=87LRA<<A:F0o  U.    +&   "&5###5!#33L[ZP_%#`O,*OL),T   ^L0  #  46632#"&5#726554&#"^3^@A\2+O8CQv9==99=??\11[@?\2J>}D@@DD@>F  XL0    7546632#4&#"332#76##"&X5aB@`6ZD8;CC;_JFZ5_dtB^2.U;59C>?@:F0l  X0  %  7546633#'2#"&&7326554&#"X3_Bs)$3_BB_3Z@:;??;:@B^2P#0A_22_A@BB@@BB@   7  &   !"&5#5!#33GO<}LECRR?R  Z&E    7L!&    5"&53332#'26554&##`lSB<lP]l`;C0*$m]\=FVJ]mF=*0 (L0&   L  6L"&   5"&53332653#alSD;H;DSlam]\=F!F=\]m  7!0 -  "&55467326553326554&'5#"&53<FN> !!H!!$>SF<6@@
VNSo
_;+',,'',,'+6_
jSNVG==G  7  &&   t   7  &	&   2   7  &&   v   Z&E   t  Z	&E   I   Z&E   v   U&   t  7!&
   t   Z  # '  "&554632'353#5#7'26554&#"73S_`RDPZZP&8>>89==jao
n__mI?ii>JNF>>FD@@DA P&   t  \L&   t#   ^L&&    5326553#%33#4667N-8V_\VsVO7.GGX\&@9,@;)  Z      33&&53#%3#Z1BBM&0MR'   P   +  "&&546632'2654&#"7"&54632,Cc66cCDb66cC<II<<II<!!!!
5aA@B`55`BAa5MM=@=MM==M"!!"  Z   
  3535733Z{R=d{xR  H     3576654&#"#>32!\94C:@IZ9eCBa4BKM\=_,=FH?Ba43^A>zNR   F   "&&53326554&##57!5!52!Bc6ZE=>DD>Kdv7d
5^?=EH:4>DZRZr`4?^5  P     !5!53353!bZ@(\   U "  "&'3326554&#"#!!34636*Yr
Z@7???>':ZK?Ycr
\N+/D>G>D)"R/6ocGaq  D  !  "&&546736632'2654&#"-Fi:dB)<X0:gG@NN@@NN
;jF7j1'8fFFj;PUFFUUFFU  P     3!#5!ZlX~   P  6  "&&546776654&#"'2654&''&&546632,Cc6GMa,0?66?/)aPHwe=G.+`PH2\??\2HS`)-G
/X;A^%/D)0890(D.%_BYiP?5+F/'Z?8R,,R8?Y)/E*6@  D    !  3'#"&&5466322654&#"B);Y0:hEFi:@NN@@NNL8gEGi;;iG7j1^UFFUUFFU  E,   ;-   E.   </   <0   ;1   ;2   ;3   ~;4   E5    H    "&554632'26554&#",HSSHHSSH(--((--OFEOOEFO?.((--((.  > 
  535733za_h@*WOG@  H   576654&#"#66323*##*FP@DN*%Wy-&++&BNMA#H_@   ?   "&5332654&##57#5352DPE*%#)(#]uBNPL@#**##)CY@OoH>@L   ?   5#573353fNF\]h  >   "&'332654&#"#5!#6632=PF*$*+%#	A5&9CQA7+%%+@"'H>BM   >    "&54677336632'2654&#"-FVkL}"%5"7ASH'--'&..NAGH=AN>,%&++&%,  >   ##5!E"i?P   H  3  "&546776654&#"'2654&''&&54632,EQ6.N("!&J.5QE%+I/7MABM6/M+?5$@" !	@&5?>"$	?!2992"= 	#"  H    7#7#"&54632'2654&#"~"%4#7ATFGUj&..&'--H=ANNAF,%&++&%,   Z     33Ze?&    :  * .  !576654&#"#6632663353557333;x##$$<E68E-)]*mv>FUke?@E)##4>>2<4
22
6F=2k&          53557335#573353!3v>FUa~Es<>e?2
6F=2kFPY&       ' +  !5#573353"&5332654&##57#53523~Es<~:F<%%%Qk7DFye?FPY:/9?27S://:p&      "&54632,&--&&--
,%'..'%,  `w    3P7   0    "&54632"&54632,%..%&--&%..%&--)""))"")\)""))"")   `0    3"&546332#P(!*+  +*!7:*! ++ !*   <    )  "&554632!"&5546323"&554632m
FFFFFF   w    %53"&546332#j/"""xxu""!#   Lw,    53"&546332#@?$$$$}y}h" "     "  7532654&##532"&546332#2@KKA}}Fg90U8="""G;;GU5`B9[6i""!#   nV+  "  "&&5466753#"33"&546332#TGg8/U9Z2@KKA}$$$$3_@9X4iB;:CU]" "  :        %"&54632,4DD45CCD45CC54D  # ^5b ;  7'7>7'.''77.553>77'.'#H6$%01XX-*X)-YY10%#7H7^2N%! S 15__51 S !%N2N....   #  5    37#537#53733733#3##7#37#S%Ua$bn%F%%F%Ua$bn%F%%1$AAAA	   :    K>   3Kc_nT   K>   3_cnT C@  x  C    H   &&554667I\@^43_@x#bnUU~OM~S  sH   5>554&&'5sA^34^@]IxYS~MO~UUnb   U> '  "&&776&##5326''&6633#"#5233;U,
&AnnA&
,U;--/2
F@?G
2/-n'K45/P/55J'P++AMNA++P  U> '  5326''&63"&776&##53233#"#U-/2
G?@F
2/--;U,
&Ann@'
,U;nP++ANMA++P'J55/P/54K'   >   3#3nPP   >   53#53nPPT   n     33ko       !3ko  i   GRX   @     GSX   @   "r   5!@"PP  "rV    P"r   5!P"PP    "Xr   5!X"PP "rV    <   5!<dKK `w ;    U`     3!3;PP77   K    3!31PPPP77  U    3!3;PP77  ;]g  r ;q   (:    %'73!'73jj(    (:    %7'3!7'3ii(    (   %'73]f(   (   77'3i(       '53!'53maaZZZZ  W   '53a  4"r    5!!5!-h"PPPP  "r     5!!5!35!_"PPPPPP  #q   3#7667!5!&&'ji
q
P  \Y   !5!3]ZUwP|  #q   3#7667!5!&&'jivqP
   #q    '7667!5!&&''337667&&''3pJjj#P
   #q 
  %'!5!73;i.2#P7=  #q 
   7'!5!7333^i.2i.2#P7=''7=      7"&'!5!32>32#54&#"d/G6''#)9*/E'U& '$)8$"P"$+,$A,<< &+,  CE> ' +  "&&776&##5326''&6633#"#523333<;U,
&AnnA&
,U;ss/2
F@?G
2/sZn'K45/P/55J'P++AMNA++PT  E>    !!!33'ZnPPT  T>      53#53!3#3!3!3_hZZnPPTPPTT> 'P    >5>   '  37!5!7!5!733733#3##7#37#53#53S%$O%F%%F%Ua$bn%F%%1$PAAAA	PPT/  ':   :   ':   ':   : pES 'B   ':   :M   ':   A \  'D  /0 '<   <  0 '<   '<   <`  D -g '<k 7 '</ 7 ~   &A  <   ,   ( = K  55%667&&'%5"&546332#"&546332#532654&##532"&546332#6!	"!*+  +*!!*+  +*!2@KKA}}Fg90U8="""AW		Zd*! ++ !**! ++ !*G;;GU5`B9[6i""!#  R d0      5!"&54632"&546325!P&$,,$$,,$$,,$$,,&PP,%$++$%,,+%$,,$%+PP -g &  < 7 -wg '< 7 t  `10 '=   = ; '?   ?       !7!5!7!5!73!!!!ngAqZquWgnPPPP     7!5!7!5!7!5!73!!!!!!XO!OXQX{YOOpdX2F}F}FF}F}F. 'A   : M 'A   < a 'A   A  W  
  -  '5667!%5!532654&##532"&546332#(H2@KKA}}Fg90U8="""$
PPPG;;GU5`B9[6i""!# ^ 'Ex   'E  E   @ ; H  %'7>7'.''77.553>77'.'#5%667&&'%5bHJ#%01ww-*X)-ww10%#KHK6!	"@2l%!
*S*15}}51*S*
	!%l2l...-kW		Zd> 'EH   H   2  !7#537#5373373!!!!#7#37#&&554667%Ua$co%F%%F%|x$H%F%%1$OI\@^43_@AAAA	#bnUU~OM~S  >   H  !7#537#5373373!!!!#7#37#"&&776&##5326''&6633#"33%Ua$co%F%%F%/$%F%%1$@;U,
&AKKA&
+V;--/3
5(<:
2/-AAAA	'K45/P/55J'P++$=%R7++P >   '  !7#537#5373373!!!!#7#37#3#3%Ua$co%F%%F%|x$H%F%%1$7AAAA	PP    |   3 7  "&54632"&546327#537#53733733#3##7#37#,$,,$$,,$$,,$$,,%Ua$bn%F%%F%Ua$bn%F%%1$+%$,,$%+,%$++$%,AAAA	    / 3  773"&766332#%7#537#53733733#3##7#37#8jbZ))%%Ua$bn%F%%F%Ua$bn%F%%1$xxu""!#AAAA	   5 9 G  !7#537#5373373346632#532654&#"!3##7#37#"&546332#%Ua$co%F%%F%(;lIIl;/T:Z2AHOEFP$q}%F%%1$}$$$$AAB`56cC=^8dJBAKH?<A	*""      + / 3 7  !7#537#53733733733733#3##7##7##7#37#37#37#%Ua$bn%F%%F%%F%%F%Ua$bn%F%%F%%F%%1$$$AAAA	     ; ? C G K O  !7#537#5373373!73373!733733#3##7##7!#7##7!#7#37#!7!37#!7!37#%Ua$bn%F%%F%%F%%F%%F%%F%Ua$bn%F%%F%%F%%F%%F%%1$$0$$0$AAAA	 9   K O S W [ _ c g  !7#537#5373373!73373!73373!733733#3##7##7!#7##7!#7##7!#7#37#!7!37#!7!37#!7!37#i%Ua$bn%F%%F%%F%%F%%F%%F%%F%%F%Ua$bn%F%%F%%F%%F%%F%%F%%F%%1$$:$$:$$:$AAAA	       # '  5!5!7#537#53733733#3##7#37#PH%Ua$bn%F%%F%Ua$bn%F%%1$PPPPAAAA	    !  ##7#537#53733733#3#!37#8%F%Ua$bn%F%%F%Ua$bn*V$d,AAAAKm sC 0 4  ##7#537#53733733#3#!.55466737#v8%F%Ua$bn%F%%F%Ua$bn*s,@"I\@^42]?C$d,AAAAZtBbnUU~OL|TKm> 'H   E  >     %5!%5!3 0'c_PPPPT  >     %5!%5!3TFc_PPPPT  >   35%667&&'%c_A?R6!	!ndZ		K>> &H  H   >      %5!%5!3!3fp c_c_PPPPTT> 'H   'H   H  "   5!3!"ZdKK    5!8dKK   }/   53yfsz-1  s/   3sfsmzk  C   `0=    ]tg  ' 0  5#353353#5#'32654&##532654&##VV<F<DL1#(8UL<F:|?II?|v:CB:w^H(>+
2K/PhC:<KN>55>  Ut  !  3'"&&5546632#&&#"32673<$Bc66cB_tZA8;FF;8AZt>2_AB^2fX59C>>D:4Xf   + q.{ " 2  %'#"&''7&&5467'766327%26654&&#"W77U>SV?X6?0T=SU%;"";%%<##<qWU>T: 9V?XT=S89U@#<&&<##<&&<#  Htf # + 3  5&&'3'&&546753#4&'56654&/^kZ;6KQcT<SdZ1-(IPiX16/,<,1@<iV1>lIPhhR/;nJRl	<0,BJ6+4G	   ZX   ( ,  %"&554632'3'53#5#75!'26554&#"5!R`_SDPZZP8>>89==;,2n^)_nJ>}bi?IPPF>>FD@@DKK   /  "&&55#535#53546632#&&#"3#3#32673@Cc6QQQQ6cC>^9ZE7<FE=7EZ9^
5aA(AdA(B`5/W=6=H?(AdA(?H=6=W/    L   53265#5354633#"3##i5>QI  3\>R=4*RBIPR;X0     &  !  35#535#5332##3#32654&##nPPPPBa66aB9CC9PUPJ3\>=]3UPD99D  K   & *  35>54.546632#4&#"!5!K2#4`BB`4_B7:@#3r4hd59+?409&9S--U<2<95/,2C0+I5P1PP   -  +   !5575575#5!#77 0K0d0K0OO0K0d0K0  #  5     5!5!36673< ]]KKKKx##,7  :     (L0   533333(AZZAR<<R     Y   33Z& Z  6    # F:   %"&&554663!!"!!3!	>i??i>1'@%C%@'1F9c>>c9P'@%P%@'P   P n&     5!5!%5!PHHFFFFFF  P     35!!5!5!5!PJ'RRR&   A  ! ?  354632326553#".#"54632326553#".#"x)?vH:%4% UG;%4% UH:%4% UG;%4% <HF;G''FF:H''FF;G''FF:H''F  #:    3'5!26655!5!54&&#!5!2#x)?1(?%C%?(1?h??h?<HP'@%P%@'P9c>>c9   #:    37"&&554663!!"!!3!x)?R>i??i>1'@%C%@'1<H9c>>c9P'@%P%@'P   #:    37"&&554663!!"3!x)?REg::gE1CIIC1<H6cA,Bb6RHB(BHR   5    3'5!26554&#!5!2#x)?1CIIC1Eg::gE<HRHB(BHR6bB,Ac6   A _5   %5#53533# X_PP "rV    i    7'7'77'33344344  d UD     5!"&546332#"&546332#d$$$$$$$$'KK"" w""   U     5!5!URPPPP  U     35!5!x)?bR<HPPPP   U AS   75%667&&'%5U6!	"AW		Zd   U AS   %%5%R!	"6AdW		  U      35!%5%667&&'%5UR6!	"PPW		Zd   U      35!5%5%UR!	"6PPdW		   A  :   3535#53533#3FXFPPF A i+& d   o  A    754632326553#".#"AH:%4% UG;%4% F;G''FF:H''F   F    %5!5!P  PT   3#&&'PTQp	sTz%

%  # 5  , <  7"&5546323>32#"&'#'2>7'&#"!26554&#";HL=3F3$;HK>3F2$
,'' && %
!J=K=J30- J=K=J30. < T4)"K"))"K") T  < 2&   73#&&'<z\ur2@ ??    < 2&   736673\ur[2 >> @    L   532654633#"#i5>QI  3\>R=4@BIP;X0   (L0   #5!###nFFZ<RR<  7L   55!!!7>}RtvRPgP    I   !#533&673oc		TP{"34!9&   Z  +  "&&554632'354.'30'26554&#",B^2aWDM1NZ*+@@+pb:>=;:>>
4`CPbpB;6bR>6Ng?dsPFAPBEFAPAF  ZL&   332653#"&&'#2ZZ9>?:Zj_/A%<AA<d`l$%         !3!3cZZ&&  J    ) 5  33"&554632'2554#""&554632'2554#"Je?LL??LL?AAA?LL??LL?AA !!&H?A?HH?A?HEBACCABPH?A?HH?A?HDCAC!"A"! X   + 9 G U  #3%26554&#""&5546326632#"&'726554&#""&554632'26554&#"<s1::1,(*+2992+))}7AA78@@8&/ZZ4;3Z3;++;3Z3;++4ZZ>5A5>>5A5>;AA  1I   5#53533#ddPdd1iFiiFi   7    # /  "&54632"&54632!"&54632"&54632$..$$..$..$$..!$..$$..$..$$..\-$$--$$--$$--$$--$$--$$-f-$$--$$-  #  :    35!%"&&554663!!"3!2Eg::gE1CIIC1RR6cA,Bb6RHB(BHR    5    35!%5!26554&#!5!2#1CIIC1Eg::gERRRHB(BHR6bB,Ac6       %"&54632'2654&#",4DD45CC5#--##--D45CC54D(-##--##-  A     # x:X   %"&&554663!!"3!	Eg::gE1CIIC1x6cA,Bb6RHB(BHR   # F:   75!26655!5!54&&#!5!2##1(?%C%?(1?h??h?FP'@%P%@'P9c>>c9   x5X   75!26554&#!5!2#1CIIC1Eg::gExRHB(BHR6bB,Ac6  2  &    3366735![{z\4ZY4&LL   
  N   3467#5%'&&'#

-#!
-'ii-   
 L+l   7'667'##5!#5467'E;a	,PL>dNa0
"   ( #:q   776675#!5!25&&''3
	(J(i#	P	   
 K+l   75327&&'77&&553,	=cPKNd?!/a   
N   %53&&533677+
Z

-
i--'i   - KNj   736676633-Pc<	,K0!f=N   ( #:q   %3663!!"&'j
	)J)#''	P	  - KNl   %&&'#!#"&'P,	aKf"
/N  #q )  73663!25&&''3#76675#!"&'j
	)h(ij
	()#''				   
VN '  %53&&5467#5%'&&'#3677,


-""


-i-v-'ii--'i    I&        33533535!73#'PPC@CbuSHHSHHLLS   
NV   %5%+'
ii  ( #q   %3663!!"&'j
	)^)#''	P	   #q   %#76675#!5!25&&''3i(^(	
j#	P	  ( #q )  %3663!25&&''3#76675#!"&'j
	)(ij
	(0)#''				 by   5!
l  b    !
lJ  b    !
l  bh   !
ll  b   !
l9  b   !
l"  bW   !
l}  b   !
l(  hb   !
lhl  Wb   5!
lW   K   3
U(     3
(     3
( ,   !
6(  w   !
(     !
(     !
(  ,b   !,6( b   3U(  ,h   !
6l  ,bh   !,6l h,   !
6hl  b   !!
66(ll  b    !!
66hlll b   !!
l(ll  b   !!,l ,hb   !,6hl b    !!,66hlll b   !!
66  7 <X         # ' + / 3 7 ; ? C G K O S W [ _ c g k o s w {                          53!5335335335353!5335335335353!5335335335353!5335335335353!5335335335353!5335335335353!5335335335353!5335335335353!5335335335353!5335335335353!53353353353<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<<x<<<<<<<<<< n  X         # ' + / 3 7 ; ? C G K O S W [ _ c g k o s w {                                 #'+/37;?CGKOSW[_cgkosw{  5353'535353'535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353535353'535353<<<<<<<<<<<<<<<<<<\<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\<<<<<<<<<<<<<<<<<<<x<<<<<<<<<<<<<<<<<<<<<<h<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<X<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<X<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<h<<<<<<<<<<<<<<<<<<<<<< )  X = A E I M Q U Y ] a e i m q u y }                          535#535#535#535#535#535#535#535#535#535#5353353353353353%35#535#35#'35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#35#'35#35#535#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< <<<<x<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<<<x<<x<<x<<x<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<,<<<<<<<<<<<<<<<<<<<<<<<<<<<<,<<<<<<<   2b   %"&&546632,XQQXYQQ2QXYQQYXQ  2b    %"&&546632'26654&&#",XQQXYQQYJvDDvJJvDDv2QXYQQYXQ2DvJJvDDvJJvD   2b  $  %"&&546632'2665*#<5",XQQXYQQYJvD-fYJvDDv2QXYQQYXQ2DvJBQJDvJJvD  2b    %"&&546632:3445",XQQXYQQGYB"JvD2QXYQQYXQ6&PDv  2b    # / 5 ; G  47&7&677632&&#"73267#"7&6776654&'7

00
',#=J))J=#%,,%"!!"%,,J),#==#,)J`0

h,%"!%p=#,)J),#=

000
,)J=]#=J)!"%,,%  2b   + 7  %"&&546632'26654&&#"7"&54632'2654&#",XQQXYQQYJvDDvJJvDDvJ6II66II6#..#"//2QXYQQYXQ2DvJJvDDvJJvDI66II66I./"#..#"/   2b   %	,66267  2b    %	7',66267   <      353'366775'&&'#~CbbccDGEG<6665    <X   5!X<X     <X    5!%!!X<X2      7!,,       7!'35#,,2    <X G$X   @     <X    5!%!!X<X2    <X    5!%!X<X2     <X    !!X&X2    <X     5!%!!3X2<X2D  <b   '
66<b     2b   5b2l  2b   %!,l2b  1X   %Xb176  <b    '%!
66<b2    2b    5%%b@2l  2b    %!!,l:2b  2X    %Xb2@266     b   5b,  X G0X   @     b    5%%br,VVV  X G2X   @       76    4<  @ @      G4  @     4             7'3'V6(        77'6,VVV       %!7#,,V6        -56(V  l     !#!#5!5!^ldddd     !5!!#5!^dd   l    !!3!#d4d0ld   l    5!5!dddd  l  	   335!%533^ddXdddd      '5!3%533rd*ddd   l    73!%33drd DdXd      3!3^dd(( l      !#!#5!533333^dddldddXd    	   #5!33533dd*dd(d  l  	   !#!333^dddld(Xd  l   #5!###ddlddl   	  #5!##ddld0l   l 	  !###dddl  l   #5!#ldd     #5!ld0   	  #5!33d2ldX0   l   !#d   l 	  33!#2dXd  l   #5!3!#dldXd l   !5!!:  ^   !5!r:  	  !533#2:&   l   !!r  l 	  #33!2:  l   !5333!:& l    !5!!5!dddd  ^ 	  !5!5!5!rddd  l 	  !!!!r4ddd  K    53!53w>  oi    33a]c      30 l   #5!#:     #5!:   l   !#  l   5!  ^   5!r  l   5!!!r2d2   ?      53!53353353dd2d2d  =      53535353m11  l   5!r   %3     53!53353~~J~  %     7333eoF?F   @   3@D l   5333&    533&     #3#22lD  l   33     3( l   #5333#:&    #533:&   l   33#(  l   #5!333#d2:&2d  l 	  !5!!!r:2d l 	  5!3!!d&d2  l   !5!3!!d:&d l 	  #535!#ld2  l 	  5#53332dX l   #5333#ldX l   !5333##2:&d2  ^   4&&##532:iH##fS|Il;dTg  l   46633#"Se##Gj:|gTd;lI @^   5326653##Hi:dSf@d;lIhgT  @l   "&&5333IeSd:jG#@TghIl;d  `lp   5533#PPP((W(  (W  `lp   53P0(( `lp   530P((   F@    53!53r4@dddd  [^}    33ddd9];   ^   3d0 l   !5!!ldd  ^   !5!rld0  l   !!rd @l   5!@dd  @^   5!r@dd  l   5!5!5!r2d2   @?      53!53353353dd2d2d@dddddddd  =^      53535353dddddddm11  @l   5!r@dd   %@3     53!53353~~J~@dddddd  %^     333dddddXRQN  @^   3d@D     3332d2X0 @l   5!3!d@dXd @^   5!3d@dXD   @l   3!d@d   ^   3d( l   !5!3!!dldXd ^   !5!3dldX   l   3!!d(d  l   #53533!#2dld2&  l 	  !5!5!!rld2 l 	  5!5!3!d2dX  l   !5!3!!dldX l 	  #5!3#:2d  l 	  5333#&d2 l   #5333#:&d l   #5#5333!2:2dX  @l   533333ddd@dXXd @ 	  53333ddd@dXXD  @l 	  3333ddd@Xd l   !5333!ldXd @l   5333@dXd  	  !533#2ldXD  @   533@dXD  l 	  #33!2ld   @l   33@d l   #5!3!#d:& l   5!3!d&  	  #5!33d2:&  ^   5!3d&   l 	  33!#2d&   l   3!d   l    5!3!5!ddddd   ^ 	  '5!5!5!3dddd   l 	  73!!!d ddd l   #533333###dddddldXXdl     #53333dddldX(   l    33#!3^dd(d(  l   #5333#ldXd    #533ldX   l   33#(d  l   !5!3!!d:& ^   !5!3d:&   l   3!!d(  l   !5!5!5!3!!!!ddddddd ^   !5!5!5!3dddd   l   3!!!!d(ddd   ^L0  #  46632#"&5#726554&#"^3^@A\2+O8CQv9==99=??\11[@?\2J>}D@@DD@>F   bb 	     %"54332#''53%!,!!!!266`""""lk99kb2  DH   !!"Hp  B d8   7'7'77'{8:8:e8:8:  -L0 0 >  "&&546632#5#7#"&554632'3'54&&#"3326554&#"EU~EAyTLn;G:0AEEA0:
&I6Zdk]F)'')(((GXTZF;nLR7&/OLxLO/'F9N(thdsK*24o/,-/x/-  76 ' 2  "&55467'&&546632#4&&#"73#''267'R]73-Q6:U.Z,)G^quc?J_"?/
XM}5I
*H$0H'*L5*%:WaP-((!}(-  AL 
   "&55463333UiiUPZP^LPM]rr   Mf < L  "&&'3332654&''&&54675"&&546332#&&##"##6654&''&6Y9_	>*9<32\ETJ7:(i^Om
_9'393.ZGRI<?+nb-,#J-+"'E.!)/'$/
Y:9R?5JWPA$,& /
V=:P @3N[S9##56"&7   - n+  # ?  %"&&5546632'266554&&#"7"&554632#4&#"32653,Ls@@sLMr@@rM<Z22Z<<Z22ZA8EE88DA!!!!ADn<lHHl<<lHHl<2/V99U00U99V/U?44??4!!!!4?  - n+   ' 2 ;  %"&&5546632''3266554&&#"'32##532654&##,Ls@@sLMr@@r@=C<Z22Z<<Z22Z2r6??6666n<lHHl<<lHHl<Z/V99U00U99V/Z^9009  r5  (  #5!#3366773#54667#'&&'sddP"	!N73!r622hf++f)%3	gh	2%)      "&54632'2654&#",CSSCDRRE)22)(11PAAPPAAP34*+44+*4  w   3P7  U    3!3;PP77  Y>   3ZnT   Y>    33ZZZ||  P>   #53533#ZnvPP   F   (  !"&&54632'766554&#"32667Q3K)XHIWOF*-$"!%)$%D	-B'H1FUTGUCl\QY@+U#&&#W%)*/!   P>   5#53#53533#3#ZnP"PPP     N  ) 7  33.53#.'"&554632'26554&#"_uF_r(77()66);DJ6:4&DI695H,://:://:7  < $  "&&5546632!5!5&&#"32673,Gm<<mGIk<f=H87II7;b2D[
AvMNuAAtOy2,,,=1.F'  <r&   73#'<dorvv  Q  0  	  37%!'Q|R[2  
  N&    !#53353oP*PPP   I0  ' + / C W [ _  52654&#"#4632"&5463"32653'3'5!"&5332654&#52"&54632#4&#"35!3C=12==q1==1C=Co]1=C2==q1==12=C]nCSC2<<22==22<C2=o]+CC=2C<22=]=22<<2CCC] l ) 7  ".546766326654&'&&76'"&54632,CtX12*34]<<]42+11XtC!!  
0WrBAr+0K,=_66_=,K0*sABrW0#|###  ll  # 1  ".54>32'26654&&#"7"&554632,CtX11XtCCtX11XtC<b99b<<a::a<!!  
0WrBBrW00WrBBrW0_;d==d;;d==d;F#### ll  #  ".54>32'26654&&#",CtX11XtCCtX11XtC<b99b<<a::a
0WrBBrW00WrBBrW0_;d==d;;d==d;   cg   "&54632,!!  ####  fW   7&&6676767&d//00'+../:'0u|uU/u|u0'9./.+'00/   < &  
  5!73#'U9doPPvv   C    .   ".#"#54632326553r&A2(&A1-2-2  0 >  "&&546632#5#7#"&554632'3'54&&#"3!26554&#"U~EAyTLn;G:0AEEA0:
&I6Zdk]/)'')(((dGXZF'ZLR7&/OLxLO/'F9:thdsK24o/,-/x/-  ' 2 V a  "&55467'&&546632#4&&#"73#'%267'"&55467'&&546632#4&&#"#'%267'R]73-Q6:U.Z,)G^quc?J"?/&R]73-Q6:U.Z,)Uc?J"?/
XM}5I
*H$0H'*L5*%:WaP-((!}(-PXM}5I
*H$0H'*L5*%:*WaP-((!}(-   ' 2 V a    "&55467'&&546632#4&&#"73#'%267'"&55467'&&546632#4&&#"#'%267'"&55467'&&546632#4&&#"#'%267'R]73-Q6:U.Z,)G^quc?Ji"?/&R]73-Q6:U.Z,)Uc?J"?/&R]73-Q6:U.Z,)Uc?J"?/
XM}5I
*H$0H'*L5*%:WaP-((!}(-PXM}5I
*H$0H'*L5*%:*WaP-((!}(-PXM}5I
*H$0H'*L5*%:*WaP-((!}(-    5 9  "&554633#"3267!!7&&546632#4&&#"75!R]]R*,/+"?&j-Q6:U.Z,)U
XM}DRF)'}(--(OPDJ
*H$0H'*L5*%:*PP     3!!Z]UCP   #q   %3!&&''3#7667!Z[ji#N
  > ' +  5326''&63"&776&##53233#"#!37s/2
G?@F
2/ss;U,
&Ann@'
,U;ZnP++ANMA++P'J55/P/54K'T E>    5!!5!!3<'vZnPPTT > &     r    3!!!3RZ:ZUCPC        3!3!35667&&'wZZZS'

'CUCCCdh  r    3!!!!!3RZ::ZUCPPC  1  	   3!35667&&'ZTZS'

'CUCCdh    3!!!!Z]]UCPP  #q    %3!'3#7!5!7667&&''!Zkjik;#N  h    35667&&'ZS'

'CUCdh  tf . 6 >  5&&'3'&&5467535%667&&'&&'56654&/^kZ;6KQcT< L%Na' 	!&5(IPiX16/,<,1@<iV1>lIPhdZ

	nJRl	<0,BJ6+4G	   _5   %5#5353!533##5!XXXn_PP  _5   %5#5353!53!533##5!#5!XXXXnXn_PP  -g    %5#53533#%5%667&&'%5XA6!	"-PPW		Zd  d0     # '  5!5!%5!"&54632"&546325!!!!$,,$$,,$$,,$$,,!PPPPPP,$%++%$,,+%$,,$%+PP       #  5!5!%5!5!%53"&546332#!!!&!j/"""PPPPPPPP-xxu""!#       5!5!PPPP   Z&     5!5!%5!hhhFFzFFFF   #q   77!5!7667&&''!5!'3k~?kj#PP   #q   77!5!7667&&''!5!'3kj*kj#PP   #q    '7!5!7667&&''!5!'337667&&''3pkkVkjj#PP   #q    7'!5!'7!5!7333rj%??dji.2i.2#PPPP7=''7=       !7!5!7!5!73!!!!nbgmqZq+g<nPPPP   #q   %7667&&''3!!j;#P  #q   %7667&&''3!&&''3#7667!jji^#
aY> '  Q  -g '4  < 7 1    %5%6675&&'%55%bbZXd?ZZ   #q    %3!'3#7!7!7667&&''!jjkjik_j_?#&(P* @S &    #q    %3!!!3jkj#&(P&(   #q    %3!!!!!3jjP??jkj#&(PPPP&( m AS '   '      #q   %3!!i{#''P  #q   %3!!i
#''K  #q   53#5!#3|ZZjir''   #q   %3!'3#7!ifji#''  #q   %3!73#'!iij`#'' -g '4  < 7 C     '  %3%5!!5!53"&546332#*i!Yj/"""#''PPPPKxxu""!#  @D ; H  7'7>7'.''77.553>77'.'#%5%HJ#%01ww-*X)-ww10%#KHKR!	"6@2l%!
*S*15}}51*S*
	!%l2l...-kdW		   @ : G T  %'7667'.''77.553>77'.'#%5%5%667&&'%5IHJ;01ww-*X)-ww10%#KHKR!	"66!	"@2l7
*S*15}}51*S*
	!%l2l...-kdW		ZW		Zd E    53'SZZC'

'Umdrhp  w   	   3!53'xZSZZC'

'UCmdrhp ~       3!3!53'-ZZSZZC'

'UCCmdrhp       5667&&'553'

'CSwSC&&nZVkgdodrk~z tf . 6 >  5&&'%5%'&&546753#4&'56654&/=p5!	!,]7JRcT<SdZ1-(IPiX160+<,1@<dW	kJPhhR/;mKRl	<0,BJ6+4G	 tf 9 A I  5&&'%5%'&&5467535%667&&'&&'56654&/=p5!	!,]7JRcT<#P%[R6!	" 9(IPiX160+<,1@<dW	lJPgdW		
mKRl	<0,AJ6+4G	  C     ( ,  %3!!%5!7#537#53733733#3##7#37#*ii<3%Ua$bn%F%%F%Ua$bn%F%%1$#''PPPAAAA	   -&g    75#53533#%%5%XgR!	"6-PPdW		   -g   %  %5#53533#%%5%5%667&&'%5XbR!	"66!	"-PPdW		ZW		Zd 1    %%5%2%51bbdZX  #q    %3!53#5!'!5!ikZZk:=#''O   #q   %3!!!!ik>=>~k#''POQP C #q    %3!'3#7!'!7'!*ikkjikk}AB=#''OQO  #q    %3!'3#7!'!7'!ikkjikZk%AB>#''OQO  #q    %3!73#'!'!'7!ikjijjak??_=#''PPO 4 (l    5%5%%667&&'%48N(dd

			G AS '      #q    %3!!!3iFji#''K''  #q    %3!!!!!3ik.?@mkji#''POQP''  AS '   '      #q @  %3332>3232>32326553#".#"#".#"i"2%%4$$3%%2"UG;%2!$3&%3$##''''''''((:I''''''  AS 5 B O  %".#"#5463232>32326553#".#"%5%5%667&&'%5u%2"UH:%1"!2%%2"UG;%2!!1R!	"66!	"''((;G''''''((:H''''dW		ZW		Zd  #q _ k  %".##53232>3232>3232>32326553#".#"#".#"#".#"3%2"&1""2%&1""2%%4$$3%%2"UG;%2!$3&%3$"1&&1""1zi''K''''''''''''''((:H''''''''''''''  *>   75%3(+_nqdZ		T  >   75%35%667&&'%+_=;R6!	" nqdZ		dW		B     '".#"#54663232655!!d)8)$''U'F.*9)#' &/F+,& <<,A$+,(P!%   70 B P  %"&554632'3'54&&#"#".#"#5463232>32#5#7'26554&#"vAEEA0:
&I62I70/9J3%?6.+UH:%?6.+%5,,3D_ALn;G:)'')(((7OLxLO/'F9N(-JXYJ-''FF;G'',JWWJ,;nLR7&/?24o/,-/x/-   #q @  77.#"#".#"#"&55332>3232>32;3#$2&%4$!1&:HU"2%%3$$4%&1"
j#''''''H:(('''''''  W  5  '".#"#5463232>32326553#".#"_%2"UH:%1"!2%%2"UG;%2!!1''((;G''''''((:H''''   #q b  7'#".#"#".#"#".#"#"&55332>3232>3232>3232>7'3"2%%2""1&%2"$2&%4$!1&:HU"2%&2$$4%&1""2%&1"$j#&$#''''''''''''H:((''''''''''''%%
 9     3!!'&&'5!9Tw
|$^PPP  w   3P7 `w ;    w   3P7  7    3!3JPP77 S    w   3P7  }	    "&54632#"&54632########"##""##"   s	   "&54632,!&&!!&&"##"      '3)sdn      73jao      73!73Fn\sn\s &   73
U&   w   73#'wScRPNN  w   '373cRPeNN      "&5332653,HXG0()1GXPA'00'AP   `D    "&54632'2654&#",6BB66BB6!!!!`?33??33?5!""!     ".#"#54632326553r&A2(&A1-2-2      5!@KK   9   7654##5322 Pi&/(?A'# 4  H    #'3#'3Ws\!Ws\   p   #7P}p   (   5326553#`K:/AKP+4  +s   "&54632,!&&!!&&"##"      "&54632'2654&#",6BB66BB7! !!7--77--73      73_ii   5    532654&#73#F72#98&B67_=$"1  5 
   "&546733337C&/K"<5(:!	-<  " h   5!"FF  x   3x)?<H  }	 2   s	 3    4    5    6   w 8   w 9    :   `D ;    <    =   5  E   5 
 F    }1    "&54632#"&54632########1"##""##"   0s   "&54632,!&&!!&&0####   *   '3)sdn*   *   73jao*  *    73!73Fn\sn\s*  w*   73#'wScRP*NN  w*   '373cRPe*NN   %   "&5332653,HXG0()1GX%PA'00'AP       "&54632'2654&#",6BB66BB6!!!!?33??33?5!""!  /   ".#"#54632326553r&A2(&A1/-2-2   H   5!@HKK       7654##532- KP/:# ?A)"4  H*    #'3#'3Ws\!Ws\*   *   #7A}s  sH   5326553#sK90AKP+4   +s   "&54632,!&&!!&&"##"     73_ii   5    532654&#73#F72#98&B67_=$"1  5 
   "&546733337C&/K"<5(:!	-<  }1 V   0s W   * X   * Y   * Z   w* [   w* \   % ]    ^   / _   H `       73jao  :w   738^@:  }     73"&54632#"&54632NPXR########x"##""##"  z    "&5332653'73,L^F7--7F]s`xH:'':Hx  z    "&5332653''3,L^F7--7F]ix`sH:'':Hx      "&5332653'7654&##532,L^F7--7F]|-	7A+3	#H:'':Hx=<' 2     (  "&5332653'".#"#5463232553,HXA4*+5AX%A4* %A4H:((:H(0(0   xq  
  7373#'sdxTePQsNN   x!  
  '373#'d}WTePQsNN   x&    7654&##53273#'-	27.6	#TePQ=
<(#2sNN  x  !  ".#"#546323255373#'n%A4* %A4TePQ,(0(0NN      73"&53332653#i`n5@LF& 1!&FLAxxxF< && <F       "&53332653#''3@LF& 1!&FLA4d`_F< && <Fxxx      7654##532"&53332653#/
Ia 6@LF& 1!&FLAp8<(dF< && <F    +  "&53332653#7".#"#54632326553@LF& 1!&FLA5*A1) )A/<<  <<&-&-  xg  
  7373#'ifnTePQxxxNN   x  
  '373#'xds\TePQxxxNN   x&    7654##53273#'0BU &$TePQp/:""dNN   x  "  ".#"#5463232655373#'y*A1) )A/tteOQ&-&-nnII   ZX    46776655#7#3Z,%nn( xx},Yl-%Ks4z^  iBz    332&&53#&&'#33]
K\
PG0A%GQ NaK   2&k  ) 2  "&5463354663232#'356654&#"354&#"n##
0Q35Q.
##Y&7--7%77--7P##3M*,L2#N#("(11("(	-77-   X   X    X   3$pjn    X   	XXll   X   	3p$ll      n                     ; F Q \ j u            KVaOZe !,7EP[fq|(3>IT_j !MXv(GR]h	*5@KV-gr}		=	d	o	z				
0
;
F
w



4?JU`kv4?Je"-8CNYdo#.9DO]hs~zBMXJ(u&1<GRu}GR]uKmx#.<GR]hs~
[ 6p)4? >b5@KValw +6ALw%`$K "*GR   < a    !$!W!_!j!r!!!"$","^"f"""""##'#2#U#####$$0$D$L$^$f$n$$$$$$%%%7%M%l%%%&&&J&{&&&&&''P'X''''''''(((&(B(J(R(m(u(}((((((()()4)@)L)X)d)p)|))))***J***++U+o+w+++,,,+,_,,,,---?-}--------...%.U.z.../&/>/r//00@0I0R0[0d0m0v0000001 1)1?1o112 212?222333C3c33344G4P4f4445555'5G5f555566!6,676D6L6Y6e6m6y66666667
77*7B7R7e7}77778878e88889/9;9K9\9h9t9999::L:X:e:q:}:::::;5;E;;<<u<==P=>>v??J?}???@@3@?@d@t@@@@@@@@@@AAAAABB^BBBCCBCKCaCmCuCCCD'DZDDDDDEEHE[EwEEEEFFF=FLFhFFFGG+GGGfGGGH+HHHI&INItI|IIIJJ3J[JJJJK#KLKKL LL9L`LLLLLLLMMM M-M:MGMTMbMpM~MMMMMMMMNNN'N=NNOsQRRS+S_SSTOT_TwTTTTTTUUU.UIUWUcUpU~UUUUUUUVVVV'V4VFVXVjV|VVVVWWW1WEWpWWWWWXXX'X7XLXcXvXXXXXXYYY-YAYNY`YpYYYYYYYZ
Z%Z2ZCZRZdZsZZZZZZZ[[)[<[R[k[[[[[\\\&\:\G\Z\j\z\\\\\\]]],]>]P]`]p]}]]]]]]^^*^=^S^l^^^^^^^___1_C_X_h_}_____```5`G`Y`q`````aaFaYarabb,bbcDccccccdd?d\dddee#eef@fvfffffgUghiii7ixiiiijj+jBjmjjkk3k\kkkll,lQllllm"m.m:m^mmmmmnn/nInfnnnoAoopp;pvpqJqqqrr?r[rrrrss(sPs`st'ttuu=uuv@vvvvwww%w3wYwpw~wwwwwwxx8xEx_xsxxxxxxyy'y6y>yFyNyVy^yfynyvy~yyyyyyyyz
zz-zFzlzzzzzz{
{{5{R{Z{b{j{r{z{{{{{{{{{||.|]||||}"}C}d}}}~ ~'~[~~#1EE    6_	B_<         9          X ZX 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X 2X X X ]X XX XX XX XX XX XX \X 
X \X 
X dX dX dX dX dX dX dX dX dX dX dX dX dX dX dX dX dX dX _X XX XX XX XX XX XX XX ]X 
X ]X iX iX iX iX iX iX iX iX iX iX iX iX -X -X \X \X sX gX sX sX sX X LX ZX ZX ZX ZX ZX ZX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX #X #X XX (X \X ZX PX \X \X \X \X HX HX HX HX HX HX \X ZX 7X 7X 7X 7X 7X ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX 2X X X X X X (X #X #X #X #X #X #X #X #X #X UX UX UX UX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX AX #X #X \X UX UX UX UX UX UX UX FX ?X ZX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX XX UX ZX <X XX XX XX XX XX XX XX \X  XX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX _X _X aX X X X X 
X X BX \X \X  X \X \X ^X \X UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX UX XX #X #X UX #X \X WX XX oX oX oX X ZX ZX ZX ZX ZX ZX \X X 7X 7X 7X 7X 7X ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX ZX 7X #X #X #X #X #X 2X 7X 7X 7X 7X 7X 7X 7X 7X 7X ZX ZX ZX ZX X X 2X ^X ]X nX nX nX X dX dX X 5X ZX ZX \X \X X LX ]X XX ^X \X XX 7X 2X 2X 6X (X KX ^X @X @X ^X ^XX AXX 5X HX ZX TX iX iX -X  X <X 8X  X #X ZX AX ZX ^X X X X X UX UX X AX ^X ^X aX aX X LX ^X UX ^X \X SX 7X 7X 7X 6X 2X NX ^X @X @X ^X bX  X AX X @X ZX ZX TX UX UX UX  X >X <X  X <X ZX 2X ]X nX 2X dX UX ]X XX iX \X 2X LX ZX PX XX ^X \X 7X 7X #X 6X (X 6X 2X 
XXXXXXX iX #X \X ZX \X <X FX PX DX \X XX 7X aX 2X ]X 7X BX UX X ^X XX XX 7X ZX 7X (X 6X 7X 7X 7X 7X ZX ZX ZX UX 7X ZX PX \X ^X ZX PX ZX HX FX PX UX DX PX PX DX X X X X X X X X X X X X X X X X X X X X ZX X X X X X X X <X X X X nX X X #X #X X KX K    xX X sX UX UX X X nX X iX X X X PX  X X <X X UX KX UX X X X X X X X X4XXX\XXXXXXCXXXX>XXXpXX\XXXDXX,XRXXXXXXXXXaXWXXXXXXXXXXXX9XXXsXXXXX>XXX"XX }X sX X X  X  X      X ]X UX +X HX ZX X  X X KX -X #X X (X X ZX #X PX PX AX #X #X #X X AX X iX dX UX UX UX UX UX UX AX AX AX FX PX #X <X <X  X (X 7X X ZX ZX X XX X 7X #X X X AX #X #X X 2X 
X 
X (X 
X 
X -X (X -XX 
X X 
 (  (XXXXXXXXXXXXXXXXXX,XXX,XXXXXX,XXX <X  X  XXXXXXXXX <X  X  X X X  X  X  X  X  XX  XXXX  XXX  XX  XX X X X X X X X XXX XXXX X XXX XXX XXXX X XXXXX X XXXX X KX X XXX XXXX X X X %X X XXX X X XXX XXXXXXXXXX XX XXXX FX X XXX XXXX X X X %X X X XXX X XXX XXXXXXXXXXX XXXXX X XXXXX X XXX XXX XXX XXX XXX X ^XX X BX -X 7X AX MX -X -X X X X UX X X PX FX PX X <X <X QX 
X XXXX X X <X X XXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXaXXXX*XXXmXXXXXXXCXXXXwX~XXXXCXXXXXXCXXX4XGXXXXXXX*XXXXXWXX9X X X X 7X X    }                 w   w                  H                         xX }X X X X X wX wX X X X X X    }               w   w                  H     s            X }X X X X X wX wX X X X X X X }               x   x   x   x               x   x   x   xX Z i 2                 9                Z   X   KX  ^ 2@    	               JB      ,    &                    
.       / 9 ~137Y#(68u~#:CO\_     " $ & 0 3 : D p y z     !!!"!.!!" ""	""""""#"%"("+"7"<"I"a"e"###%#t#%%%%%%%%%%%&''q''+X      0 : 427Y #%68t~$;DQ^       $ & 0 2 9 D p t z     !!!"!.!!" """"""""#"%"'"+"7"<"H"`"d"###%#t#% %%%%%%%%%%&''n''+X                            rg        0.& (  `  ?>  A  ?    b  s                JE      #+c    
                    H    sw  TN  D<(  ##          XZ\^`bdjp    n      j    px                  r  |    |                                                                                      &                        ?fFgLME;V:H<=A    ! % 7 8 ? B N P R X Y _ y { |        PIQ[K         	1348@EXY^_hNO@IlbWS./LCT-mc879B   
      2 & ) / I C E F " ^ j ` b w h u      z>                 "/ -KFHI`2b                #  $  4  '  0  5  (  <  :  >  =  A  @  M K  D  L G  O Q S
 U T V W Z \ [ ] s+ a r* x0 }5 7 ~6 9 < ; : C B A W T G V S U [ a  i k j? l$ M 	  ;  t, 9    v. = D f1/PJQURM458<=:32>;69tvvr|nopqtuwxyz{s ] Z \                         1  3  6  *  ,  -  .  +  J  H  i! k# c e f g d m% o' p( q) n& J L N P Q R O d c e g`a\^_]D_lefbcSM^QK]kiNToLRnqPJt\ruhsOwpUvmYZ?CXI>WH=BAFEVG<@Dyxz{~}|`gd[aj (,48)-5902*.6:+/7;13SURT         	       	     	     	  <   	  ,"  	  N  	  *h  	  6  	    	    	   	 
 C o p y r i g h t   2 0 2 0   T h e   J e t B r a i n s   M o n o   P r o j e c t   A u t h o r s   ( h t t p s : / / g i t h u b . c o m / J e t B r a i n s / J e t B r a i n s M o n o ) J e t B r a i n s   M o n o R e g u l a r 2 . 2 1 1 ; J B ; J e t B r a i n s M o n o - R e g u l a r J e t B r a i n s   M o n o   R e g u l a r V e r s i o n   2 . 2 1 1 J e t B r a i n s M o n o - R e g u l a r h t t p s : / / s c r i p t s . s i l . o r g / O F L W e i g h t I t a l i c R o m a n       e 2                      $  	
 b  c   % &   d '  ( e    !"# ) *$ %&'( +)* , +   , -./0 -1 .2 /3456  0 1789: f 2 ; <=>?@ gA BCDEFGHIJK L   3  4 5MNO 6P  QRST 7UVWX 8 Y  hZ [\]^_`abcdef 9 :ghij ; < k lmnop =q r D istuvwxy kz{|}~ l j n m  E F   o G  H p r s q I J  K L  t v w u M N O  P Q x R y { | z  }  S  T U V    W X ~    Y Z [ \   ]    	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxy z{|}~                      "       ?   ^ ` > @    B            
               !      a  A         	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCD EFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ # 	       _    	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ab   C          cdefghijklmnopqrstuvwxyz{|}~Abreveuni1EAEuni1EB6uni1EB0uni1EB2uni1EB4uni01CDuni1EA4uni1EACuni1EA6uni1EA8uni1EAAuni1EA0uni1EA2AmacronAogonekAEacuteCcircumflex
CdotaccentDcaronDcroatEbreveEcaronuni1EBEuni1EC6uni1EC0uni1EC2uni1EC4
Edotaccentuni1EB8uni1EBAEmacronEogonekuni1EBCuni01F4GcaronGcircumflexuni0122
GdotaccentHbarHcircumflexIbreveuni1ECAuni1EC8ImacronIogonekItildeJcircumflexuni0136LacuteLcaronuni013BLdotNacuteNcaronuni0145EngObreveuni1ED0uni1ED8uni1ED2uni1ED4uni1ED6uni1ECCuni1ECEOhornuni1EDAuni1EE2uni1EDCuni1EDEuni1EE0OhungarumlautOmacronuni01EAOslashacuteRacuteRcaronuni0156SacuteScircumflexuni0218uni1E9Euni018FTbarTcaronuni0162uni021AUbreveuni1EE4uni1EE6Uhornuni1EE8uni1EF0uni1EEAuni1EECuni1EEEUhungarumlautUmacronUogonekUringUtildeWacuteWcircumflex	WdieresisWgraveYcircumflexuni1EF4Ygraveuni1EF6uni0232uni1EF8Zacute
Zdotaccentabreveuni1EAFuni1EB7uni1EB1uni1EB3uni1EB5uni01CEuni1EA5uni1EADuni1EA7uni1EA9uni1EABuni1EA1uni1EA3amacronaogonekaeacuteccircumflex
cdotaccentdcaronebreveecaronuni1EBFuni1EC7uni1EC1uni1EC3uni1EC5
edotaccentuni1EB9uni1EBBemacroneogonekuni1EBDuni0259uni01F5gcarongcircumflexuni0123
gdotaccenthbarhcircumflexibreve	i.loclTRKuni1ECBuni1EC9imacroniogonekitildeuni0237jcircumflexuni0137kgreenlandiclacutelcaronuni013Cldotnacutenapostrophencaronuni0146engobreveuni1ED1uni1ED9uni1ED3uni1ED5uni1ED7uni1ECDuni1ECFohornuni1EDBuni1EE3uni1EDDuni1EDFuni1EE1ohungarumlautomacronuni01EBoslashacuteracutercaronuni0157sacutescircumflexuni0219longstbartcaronuni0163uni021Bubreveuni1EE5uni1EE7uhornuni1EE9uni1EF1uni1EEBuni1EEDuni1EEFuhungarumlautumacronuogonekuringutildewacutewcircumflex	wdieresiswgraveycircumflexuni1EF5ygraveuni1EF7uni0233uni1EF9zacute
zdotaccentuni0410uni0411uni0412uni0413uni0403uni0490uni0414uni0415uni0401uni0416uni0417uni0418uni0419uni041Auni040Cuni041Buni041Cuni041Duni041Euni041Funi0420uni0421uni0422uni0423uni040Euni0424uni0425uni0427uni0426uni0428uni0429uni040Funi042Cuni042Auni042Buni0409uni040Auni0405uni0404uni042Duni0406uni0407uni0408uni040Buni042Euni042Funi0402uni04AEuni04E8uni0430uni0431uni0432uni0433uni0453uni0491uni0434uni0435uni0451uni0436uni0437uni0438uni0439uni043Auni045Cuni043Buni043Cuni043Duni043Euni043Funi0440uni0441uni0442uni0443uni045Euni0444uni0445uni0447uni0446uni0448uni0449uni045Funi044Cuni044Auni044Buni0459uni045Auni0455uni0454uni044Duni0456uni0457uni0458uni045Buni044Euni044Funi0452uni04AFuni04E9AlphaBetaGammauni0394EpsilonZetaEtaThetaIotaKappaLambdaMuNuXiOmicronPiRhoSigmaTauUpsilonPhiChiPsiuni03A9
AlphatonosEpsilontonosEtatonos	IotatonosOmicrontonosUpsilontonos
OmegatonosIotadieresisUpsilondieresisuni03CFalphabetagammadeltaepsilonzetaetathetaiotakappalambdauni03BCnuxiomicronrhouni03C2sigmatauupsilonphichipsiomega	iotatonosiotadieresisiotadieresistonosupsilontonosupsilondieresisupsilondieresistonosomicrontonos
omegatonos
alphatonosepsilontonosetatonosuni03D7uni2115uni2080uni2081uni2082uni2083uni2084uni2085uni2086uni2087uni2088uni2089uni2070uni00B9uni00B2uni00B3uni2074uni2075uni2076uni2077uni2078uni2079onedotenleaderperiodcentered.loclCAT.caseperiodcentered.loclCATuni2770uni276Euni2771uni276Funi00ADuni2010hyphen_hyphen.ligahyphen_hyphen_hyphen.ligahyphen_hyphen_greater.ligahyphen_bar.ligahyphen_greater.ligahyphen_greater_greater.ligahyphen_less.ligahyphen_less_less.ligahyphen_asciitilde.ligabraceleft_bar.ligabracketleft_bar.liga%bracketleft_bar_bar_bracketright.ligabracketleft_less.ligabracketright_numbersign.ligaperiod_period.ligaperiod_period_period.ligaperiod_period_less.ligaperiod_question.ligaperiod_equal.ligacolon_colon.ligacolon_colon_colon.ligacolon_colon_equal.ligacolon_question.ligacolon_question_greater.ligacolon_equal.ligacolon_greater.ligacolon_less.ligasemicolon_semicolon.ligaexclam_exclam.ligaexclam_equal.ligaexclam_equal_equal.ligaquestion_period.ligaquestion_colon.ligaquestion_question.ligaquestion_equal.ligaasterisk_asterisk_asterisk.ligaasterisk_greater.ligaasterisk_slash.liganumbersign_parenleft.liganumbersign_braceleft.liganumbersign_bracketleft.liganumbersign_colon.liganumbersign_exclam.liganumbersign_question.liganumbersign_numbersign.liga%numbersign_numbersign_numbersign.liga0numbersign_numbersign_numbersign_numbersign.liganumbersign_equal.liganumbersign_underscore.liga$numbersign_underscore_parenleft.ligaslash_asterisk.ligaslash_equal.ligaslash_equal_equal.ligaslash_greater.ligaslash_slash.ligaslash_slash_equal.ligaslash_slash_slash.ligaunderscore_bar_underscore.ligaunderscore_underscore.ligauni27E8uni27E9	anoteleiauni037Euni00A0CRuniFEFFuni20BFdongEurouni20BDuni20AEuni2219uni2210uni2223uni2215elementequivalenceexistentialuni2249uni220C
notelement	notsubsetuni2285
logicaland	logicaloruni00B5uni2225uni207Auni2237reflexsubsetreflexsupersetuni2218similarpropersubsetsuchthatpropersuperset	universalarrowupuni2197
arrowrightuni2198	arrowdownuni2199	arrowleftuni2196	arrowboth	arrowupdnuni21E7uni2304uni27F5uni27F6uni27F7uni2581uni2582uni2583dnblockuni2585uni2586uni2587blockupblockuni2594uni258Funi258Euni258Dlfblockuni258Buni258Auni2589rtblockuni2595uni2596uni2597uni2598uni2599uni259Auni259Buni259Cuni259Duni259Euni259Fltshadeshadedkshadeuni25CFuni25EFuni25D4uni25D5uni25CCuni25CEuni25C6uni25C7	filledboxuni25A1uni25AAuni25ABuni25E7uni25E8uni25E9uni25EAuni25EBtriagupuni25B6triagdnuni25C0uni25B3uni25B7uni25BDuni25C1triagrttriaglfuni25BBuni25C5uni25B4uni25B8uni25BEuni25C2uni25B5uni25B9uni25BFuni25C3uni2566uni2557uni2554uni2550uni2569uni255Duni255Auni2551uni256Cuni2563uni2560uni2565uni2556uni2553uni2530uni2512uni2527uni250Euni251Funi2541uni252Funi2511uni2529uni250Duni2521uni2547uni2564uni2555uni2552uni254Duni254Funi257Buni2533uni2513uni250Funi2501uni2578uni257Euni2509uni250Buni257Auni2505uni2507uni2579uni253Buni251Buni257Funi2517uni2503uni254Buni252Buni2523uni2545uni252Duni2535uni253Duni2532uni253Auni254Auni2543uni256Euni256Duni256Funi2570uni2573uni2572uni2571uni254Cuni254Euni2577uni252Cuni2510uni250Cuni2500uni2574uni257Cuni2508uni250Auni2576uni2504uni2506uni2575uni257Duni2534uni2518uni2514uni2502uni253Cuni2524uni251Cuni2546uni252Euni2536uni253Euni2531uni2539uni2549uni2544uni2568uni255Cuni2559uni2540uni2538uni2526uni251Auni251Euni2516uni2548uni2537uni252Auni2519uni2522uni2515uni2567uni255Buni2558uni256Buni2562uni255Funi2542uni2528uni2520uni253Funi2525uni251Duni256Auni2561uni255Euni2374uni26A0uni26A1uni2715minuteseconduni2113uni2116	estimateduni2303houseuni2325uni2318uni23FBuni23FCuni2B58uni23FDuni23FEuni2305uni02F3uni02F7at_underscore.ligaampersand_ampersand.liga"ampersand_ampersand_ampersand.ligaampersand_equal.ligabar_hyphen.ligabar_hyphen_greater.ligabar_braceright.ligabar_bracketright.ligabar_bar.ligabar_bar_hyphen.ligabar_bar_bar_greater.ligabar_bar_equal.ligabar_bar_greater.ligabar_equal.ligabar_equal_greater.ligabar_greater.ligadollar_greater.ligaplus_plus.ligaplus_plus_plus.ligaplus_greater.ligaequal_colon_equal.ligaequal_exclam_equal.ligaequal_equal.ligaequal_equal_equal.ligaequal_equal_greater.ligaequal_greater.ligaequal_greater_greater.ligaequal_less_less.ligaequal_slash_equal.ligagreater_hyphen.ligagreater_hyphen_greater.ligagreater_bracketright.ligagreater_colon.ligagreater_equal.ligagreater_equal_greater.ligagreater_greater.ligagreater_greater_hyphen.ligagreater_greater_equal.ligagreater_greater_greater.ligaless_hyphen.ligaless_hyphen_hyphen.ligaless_hyphen_bar.ligaless_hyphen_greater.ligaless_hyphen_less.ligaless_colon.ligaless_exclam_hyphen_hyphen.ligaless_asterisk.ligaless_asterisk_greater.ligaless_bar.ligaless_bar_bar.ligaless_bar_bar_bar.ligaless_bar_greater.ligaless_dollar.ligaless_dollar_greater.liga"less_numbersign_hyphen_hyphen.ligaless_plus.ligaless_plus_greater.ligaless_equal.ligaless_equal_bar.ligaless_equal_equal.ligaless_equal_equal_greater.ligaless_equal_greater.ligaless_equal_less.ligaless_greater.ligaless_less.ligaless_less_hyphen.ligaless_less_equal.ligaless_less_less.ligaless_asciitilde.ligaless_asciitilde_greater.ligaless_asciitilde_asciitilde.ligaless_slash.ligaless_slash_greater.ligaasciitilde_hyphen.ligaasciitilde_at.ligaasciitilde_greater.ligaasciitilde_asciitilde.liga"asciitilde_asciitilde_greater.ligaasciicircum_equal.ligauni0374uni0375uni02BCuni02BAuni02C9uni02B9uni0308uni0307	gravecomb	acutecombuni030Buni030C.altuni0302uni030Cuni0306uni030A	tildecombuni0304hookabovecombuni030Funi0312uni031Bdotbelowcombuni0325uni0326uni0327uni0328uni0336uni0338uni0308.caseuni0307.casegravecomb.caseacutecomb.caseuni030B.caseuni0302.caseuni030C.caseuni0306.caseuni030A.casetildecomb.caseuni0304.casehookabovecomb.caseuni030F.caseuni0312.caseuni031B.casedotbelowcomb.caseuni0326.caseuni0327.caseuni0328.casedieresis.casedotaccent.case
grave.case
acute.casehungarumlaut.casecircumflex.case
caron.case
breve.case	ring.case
tilde.casemacron.casetonos
tonos.casedieresistonosuni03060301uni03060300uni03060309uni03060303uni03020301uni03020300uni03020309uni03020303uni03060301.caseuni03060300.caseuni03060309.caseuni03060303.caseuni03020301.caseuni03020300.caseuni03020309.caseuni03020303.caseuniE0A0uniE0A1uniE0A2uniE0B0uniE0B1uniE0B2uniE0B3SPC                ;     \  ^ w  y y  {                  / 4= @W Y] _k nn pp uv {| ~                                    26 8H Vh w       
 $ 2 DFLT latn          mark                ( vl  26  8F Vh w '  7      \  ^ w Z y y t {  u                / 4=@W$Y]<_kAnnNppOuvP{|R~TWZ[\_`aceghikloqwyz{}~   7  $  $  
     $  $  $  $  $  $  $  $  $  $   B B B B B  <  <        <  <  <  <  <  <  <  <  <  < < B B B B  $  $  $  $  $  $  $  $  <  <  <  <  <  <  <  < & t& J 
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F    	  		  		  		  		  		  	
F    
F    
F    
F    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

F    
F  
@
F  
@
F  
@
F  
@
F  
@
F  
@
F  
@
F    
F    
F    
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L	    	    
F  
L
F  
L	  		  		  		  		  		  	
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F

L
F

L
F

L
F

L
F

L
F

L
F

L
F

L
F

L
F

L
F

L
F

L
F

L	

L	

L	

L	

L	

L	

L
F

L
F

L
F

L
F

L
F

L
F

L
F    
F    
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F	
L
F    
F  
L
F  
L
F  
L
F  
L
F  
L
F    
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F  
L
F    
F    
F    
F    
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
4  	
.    
.    
:  
@
:  
@
:  
@
:  
@
:  
@
:  
@
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L
.  
L	    	    	    	    	    	    	    	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  


    

    

    
.    	  		  		  		  		  
L	  	
4  
L
4  
L
4  
L
4  
L
4  
L
4  
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L	
(
L	
(
L	
(
L	
(
L	
(
L	
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L
.
(
L	  		  		  		  		  		  		  		  		  		  	    	    	    	    	    	
.
"
L
.
"
L
.
"
L
.
"
L
.
"
L
.
"
L
.
"
L
.
"
L
.  	
.  	
.  	
.  	
.  	
.  	
.
"
L
.
"
L
.
"
L
.
"
L
.
"
L
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
.    
F  
L
F    	  

  

F  
L
F  
L
F  
L
F    
F

L
F    	  	
F  
L
F    
F  
L
F  
L
F  
L	    
F  
L
4  		    	    
.  
L
.  
L
.    
.    
.
(
L	  	
.    
.    	  		  
	  


    
F  
L
F    
  

F    
F    
F

L
F  
L
F  
L
F  
L
F  
L
F

L
F    
F  
L
F  
L
F    
F  
L
  

F    
F  
L
F

L
F  
L
F  
L
F  
L
F  
L
.  
L
4    
.    
.
(
L
.
"
L
.    
.
"
L
.
"
L
.
"
L
.
(
L
.  
L
4    
:  
@
F  
L   "  )&     @   "& @&     h   +   6 1 h 1   J& .& .   6& 6   ;& ;   & @    @ & L& ,& 1& 0& 0   , ,      
  DFLT latn  `   4 AZE  \CAT  @CRT  \KAZ  \MOL  NROM  \TAT  \TRK  h                                       calt ,ccmpDccmpNfracZlocl`loclflocll        	         " $ ' * , . 2 5 9 ; > B E H K M P S U W Z ^ ` b f i k m p s u x | ~                                                	 "$&(+-02468:<>@BDFHJLNPRTVXZ\^`b   dgj   dgjj   p   m   l   kq6P .n+.PjpZ	h			J	\		
 
p38

.<<J(((6|",DB9Tx,D,D:
9990+.+.F+.X<N6hB,DT 6h6h6h& <N9R38db0X|DR`38 R38 l!!!|38!""3838"0"38"##(#z##$ $d&$r$$$%V&&%d%%&J&h&&' '+.+.'((+.(:(()+.)*)+.)**,**+ +.+<+,D+,6,D,D,R,,,-$->---..h/r.v../d/r/r///0J0X0f03801`91r19123823&383F36h3486h4J46h45D6h5V556N6h6v667b=|7p778t8899999::6::;4;R;;<j=|<<<=j=|===>N>h>>?8?R??@2@L@@A.ALAABB*BBC
C$C|CDD$D|DDEEfEEEFDF^FFG4GNGGHH2HHI I>IIJXJXJK0K0KL^LrLLLL       . @  ; ; F"      ; FF    Fl F          ; E           
   [       . @  F> F> F>      F. F.F.    F  F          F F          E N      " 4 H \  E E EE      E EEE    EE E        E E E        E EE          Et O      & : P f |  E\ E\ E\E\E\      EH EHEHEHEH    EEE E4      
  E E  E E      D E EE        D DDD          D P      DH      & : P f |  @r @r 66D      @^ 66DD    DhDhDh D        DRDR 6 Dj      D< 6 6DT        @z 6j6jD>            s  PQ       . @  6( 6(  D      6 6 4    C  $          5        O       
   O       . @  ? ? 5      ? 55    CR 5          ? 5           
 r  P      & 6 F V f v   ?R ?R =      ?B ==      ?2 =;j      ?" =<      ? =9      ? =>    B =          > =           
 t  P       . @  >4 >4 4      >$ 44    B2 4v          > 4d           
 q  N       . @  4* 4* A      4 AA    A A          3 A           
   Q        0 @ R  < < <      < <<      < <@^    AH <          < <          < V      " 4 H \  <p <p <p<p      <^ <^<^<^    @@ <L        @ <8 <8         <$ <$<$    !      < X        0 @ R  ; ; ?    ?~ ; ?~      ; ?n?n    @X ?^      #    ; ?L    #      '       $ 6 H \ p  ;z ;z ;z?    ? ;h ;h?      ;V ;V>>    ?? >      %  ? ;0 >    %    ; ;>    &      '        :F      " 4 H \  : : >t>t      : >b>b>b    ?J?J >P      (  ?6 >< ><    )    : >(>(    (      &p       $ 4 D T d v  :R :R 8    8 :B 8      :2 88      :" 8:"      : 8%    > 8      +    9 8~    +              $ 4 D T d v  8F 8F 9    9 86 9    $ 8& 9      8 99      8 9x8    = 9h      -    7 9V    -       
   EH      " 4 H \  7 7 77      7 777    == 7      /  =x 7p 7p    0    7\ 7\7\    1      7@ F      72I       . @  5 5 5      5 55    = 5      3    5 5    4      5f,      " 4 H \  5P 5P 5P5P      5> 5>5>5>    << 5,      6  < 5 5    7    5 55    8      4-      4       . @  " " 9l      " 9\9\    < 9L      :    "b 9:    :       ~ y        0 @ R  ". ". ".      " ""      " "6    ; !      <    ! !    =      ! <      " 4 H \  ! ! !!      ! !!!    ;>;> !      ?  ;* ! !    @    !p !p!p    A      !T =      " 4 H \  !> !> !>5      !, !,55    :: 5      C  : ! 5    C       5    D       
 x  :       T      & : P f |  5B 5B 8l//      5. 8X/ / /     :":":" .      F  :: . .    G  9 8 ..    F    4 8..    F        
  ?V      " 4 H \  4 4 4.f      4 4.T.T    9x9x .B      I  9d 4\ ..    I    4H 4H.    J      (       & 6 N ^ n ~   4 4 -      3 --      3 - 4d        3 -3      3 -+      3 -4,    8 -v      L    3 -d    L      (
       " 4 H \  3^ 3^ -0-0      3L ---    8B8B -      N  8. , ,    O    3 ,,    N      '       & : P f |  2 2 8 ,,      2 7,,,    777 ,      Q  77 ,n ,n    R  7 7 ,X,X    Q    2p 7,B,B    Q          FV       . @  2. 2. 2      2 22    7 2      T    1 2t    T       
          . @  1 1 5^      1 5N5N    6 5>      V    1 5,    V       	      $ 4 D T d v  1X 1X 1X    + 1H 1H    5F 18 18      1( 1(1(      1 15&    6 1      X    0 0    Y      0T      " 4 H \  0 0 00      0 000    55 0      [  5 0 0    \    0z 0z0z    ]      0^W      " 4 H \  0H 0H 4V0      06 4D00    5,5, 0      _  5 4 0    _    / 4
0t    _             " 4 H \  / / )0<      / )0*0*    44 0      a  4 )^ 0    a    /x )J/    a          V      & : P f |  /4 /4 &&&      /  &l&l&l&l    444 &X      c  33 &B &B    d  3 &, &,&,    e    . &&&    c              $ 6 J ^  . . %%      .~ %%.    3t3t %      g  3` % %    h    .D %%    g                2 B T  . . %Z      - %J%J%J      - %8.d    2 %(      j    - %    j       
           0 @ R  '` '` $    -~ 'P $      '@ $$    2f $      l    ' $    l       k      " 4 H \  & & --      & -~-~-~    11 -l      n  1 -X -X    o    & -D-D    n       m    |  $ 6 J ^  &f &f &f-      &T &T,,    1x1x ,      q  1d &. ,    q    & &,    r       j      & 6 F V f v   -h % ,    % % ,t    ,d % ,d    #( % ,T      % ,D,D    )P % ,4    0 ,$      t    %l ,    t      j l      & 6 F V f v   + + +      + ++      + +/N      + +%    /. + +    + + +    0 +x      v    +f +f    w      +L8      " 4 H \  +6 +6 +6+6      +$ +$+$+$    // +      y  / * *    z    * **    {      *;      " 2 B R d  * * .L      * .<.<      * .,*      * .*    / .      }    *d -    }      (        . @  *2 *2 -V      *" -F-F    . -6          *  -$                 & 6 F V f v   ) ) .n    & ) .^    (. ) .N    %F ) .>    ) ) ..      )v ..    - .          )T -           
   Q      " 2 B R d    ( ,    ( ( ,      (~ ,,      (n ,|(n    -f ,l          (L ,Z          N       " 4 F Z    ( (,&,&    ( ( (,    , ,        , ' +        ' '+                 $ 6 H \ p  ' ' ++      ' +++      'r ++'    ,h,h +n        ,T +Z +Z        '8 +F+F          8       " 4 H \  ' ' N'z      & <'h'h    ++ 'V        +  'B        & '.                    " 4 H \  + + +      +  + +     +X+X *        +D  *        * t*           
   [        0 @ R  ) ) )    ) ) )      ( ))    * )          ( )          |        . @  ( ( (      ( ((    *^ (          (n (n          (T E      (FO      " 4 H \  (0 (0 ))      ( )))    )) (        ) ( (        ' ((                  " 4 H \  ( ( '(      ( '((    )h)h (n        )T 'v (Z        (F 'b(F           
   ?      & 6 F V f v   %P ( $l    ' ' $\    $L ' $L     ' $<      ' $,'      ' $$    ( $          ' #                   0 @ R  '\ '\ '\      'L 'L'L      '< '<#    (& ',          ' '          ' -      & 8 J \ p   & & &&    " & &&      & &&&      & &&#    '' &        ' & &        &v &v&v          &Z.      " 4 H \  &D &D %&D      &2 %&2&2    '' &         ' % &        % %%          B         0 @ R  % %P %    %@ %@ %      %0 %%    & %          % %                  . @  $ $ !      $ !!    &( !          $ !           
   <       . @  $p $p        $`       %            $>             
   <        0 @ R  $ $ $      # ##      # #$T    %> #          # #          # ?       . @   `  `  `       P  P P    $  @           .  .            F       Q  =      " 4 H \  # # ##      #
 #
#
#
    $d$d "        $P " "        " ""          " @        0 @ R  " " !<      " !,!,      "~ !Z    # !          "\            f ~      " 4 H \  "( "(        "      #p#p         #\           !  z              <A      " 4 H \  ! ! !"      ! !!!    "" !        " !b !        !N !N!           
 }  <      !R      & : P f |               "D"D"D         ".". r       " \ \        F FFr                 $ 6 H \ p    8      &           !!         !~                      n        . @  z z       j     !           H t           
         $ 6 J ^           ~       l           X         D                 $ 6 J ^    JJ      t tt6       $         
 N         : :                    0 @ R           zz       j     Z           H           
   V        0 @ R    H      v 8      f ((               D            
         " 2 B R d                                                                " 2 B T                                                   & 8 J ^ r    ,    r r rr      ` ```     N        p : :        & &&          
       8       . @  P P P      @ @@     0                      H      M        0 @ R    B       22       "    ~                        
   <A       . @  d d 8      T ((               2            
   A       . @                                        
   :A       . @  \ \ \      L LL    : <          * *                   0 @ R                      H                            
         " 4 H \   |  |  | |       j  j j j    VV  X        B  D  D         0  0 0                             . @   D  D        4                        :       
 z  :       . @               X                       G      3      " 4 H \    r       `              :          &           
   H      " 4 H \  v v Hv      d 6dd    ZZ R        F  >        * *                 " 4 H \                                                    & : N d z  p p ~~      \ jj    PP         << B       & , ,                             $ 6 H \ p    :      (                              r r                 D      " 4 H \  . .             t        ` `        LL                " 4 H \                       n t         `                 " 4 H \    *                      \        H H          
         " 4 H \  
 
 
	d       	R	R    vv 	@     
  b  	,   
     	                " 2 B R d          v       f f      V               4                  " 4 H \      Z        H    ll        X "                   
   V      ~        0 @ R    4       $$       H                         !      " 2 B R d        h                    @ |         j j         P[      " 4 H \    :n       (\\     J         6        "           "        " 2 B R d  8 8 f    V ( V      F       66    . &                     n      " 4 H \                                f           
 o  V      " 4 H \  d d VV      R DDD    :: 2       &          

          
         
      " 4 H \  
 
 
      
 ~          !   X    !    
r D   !          V      " 4 H \  
0 
0 >|      
 ,jj     X     #     D   #    	 0   #                " 4 H \      
        

     	     %  r x 	   %      d	   %                " 4 H \   `  ` 	       N 	z	z     	h     '    	T   '      	@   '            V      $ 6 H \ p  ~ ~       l       Z     PP      )  < x x   *      dd   )       
 #          0 @ R    &              :          ,    r    ,      p p      " 4 H \               PP      .  < x    .    d d   /       | *      6       . @  " " V       FF     6     1      $   1       
 (         . @       D         4 4    Z  $     3          3  V       
 &  V       . @   D  D  J       4  : :    
  *     5          5           
 '         . @   D  D 	       4 		    
p 	v     7      	d   7         
 +        " 4 H \    <       *zz    		 h     9  	  T   9      @   9                 . @           x       	p       ;    V  ~   ;       
          . @   D  D        4     	 t     =      b   =         
         " 4 H \    <        *          ?  x     ?    \     ?                 . @                         A      ~   A       
          . @   D  D (       4           C         C         
         " 4 H \  < < <      * *            E    |   E      h   E          E       . @                         G    ~  ~   G       
   E       . @   D  D        4     ,      I         I  E       
   E      " 4 H \      BH        066     $     K   
    K           K        %  H       . @   D  D         4       ,       M          M         
 $  H       . @   D  D  J       4  : :      *     O          O  H         
   H       . @     D      p  4 4    B  $     Q    N     Q  N       
   FN       . @     D        4 4      $     S         S  P       
   FP       . @           

    ^      U    j    U       
   FL       . @  0 0  D         4 4      $     W         W  A       
   AF        0 @ R    4       $$           n      Y    z    Y       
   F[       . @  @ @  D      0  4 4      $     [         [  ?       
   ?F       . @     D        4 4      $     ]         ]  <       
   <F       . @  \ \  D      L  4 4      $     _    *     _         
   F      " 4 H \       ` f         N T T        B     a     (  .   a           a  [  L          FL[       . F   J  J  P       :  @ @       0     c            c  Q  F       
 u  FQ        \ n     &  >   e        ,   f     AC  EH   26  8@   t t     e    b     f      n         X ) VWXYZ[\]^_`abcdefghijklmnopqrsu       26 8B DF IS tt  w~ !     
        $   h          i  Vs  uu         T 'VWXYZ[\]^_`abcdefghijklmnopqrsu  26  8B DF IS tt w~           0 R t  
   { 5| 4} >~ <  
   w 5x 4y >z <  
    Y X a _  
    Y X a _  8:[]                     =D    ;C     
 $     P     n  	     6     o   R                  C       ,  
     8 H7 H  9 H             $ wght   ital    *      ^                               pGSUB %z      TOS/2VCbo  P   `cmapk~N1    8cvt 2  4   ,fpgmb1{  `  gasp     ,   glyfD     head"c     6hhea  @   $hmtx\\  d   hloca1-J     6maxp"      namet  $  post    [prepfB  (l       
 0 > DFLT latn                      liga                        z   z   1                         PfEd  ! wRj Z                          ,                ,  
       "     ! + - 9 < > D M P S X _ d g i w   ! + - 5 < > B L P S W _ d f i w                                  " " " " * * * . 0 0 0 2 2 2 4 4           	 
                                                                       	 
                                                                                                                                                                                       <          !   !      +   +      -   -      5   5      6   6      7   7      8   8      9   9      <   <   	   >   >   
   B   B      C   C      D   D      L   L      M   M      P   P      S   S      W   W      X   X      _   _      d   d      f   f      g   g      i   i      w   w    R  ! 3 5@2	 L      g _ N8''&#+%54&+"326'4'&+"7326!"&'&7>2;
l

l

z	g	""		"&"Sj

j
####       LQ  @ L     v+"/&4?'&4?62L:     X  @ L    v+"'&4?62762X     jR  @   v 
 +!2#!"&546SB#00#"11R0#"11"B#0     C  @    W _ O3$#+54&+3!54&+"&S0b 0S     C  @ I   v+!#C         @ J   v#+5#"&h?}}?h          @ I   v+#    D  U LKPX@ M    NKPX@ M    NK!PX@      N@	     vYYY+	"'&4762)

]b

]


]



]
     tD  U	 LKPX@ M    NKPX@ M    NK!PX@      N@	     vYYY+	"/&47	&4?62jb](]


ia

])(]b   Q a q O@L8PL  ~  g  g  _    Nnlfd^]VUKHEB=:5+!"&'&?674&56?>76&6?>76&76?>74&>?>?>63!2!"3!2676'!26?6&'!"!26?6&!"
@%+P



	).(4CS	:SG)$0<,%"<	>
B	


@(B&'&
$

$
       $ @" L   v+%"/"/&4?'&4?62762L,,LL,,LpLL,,LL.   ) ,@)        W _ O#:#65+#!".?>3!2'!"'&746;2!2V&V%_05r#J33J/4H?("(Z4)3JJ3J    j  ! 2@/ L     i Y a Q#+4.>"/#".>,:d{Ph@<ll<Eg*E>jn:BfM{d   Z   / 1@.(  L  g    c _ N&5&5&3+%!"&'5467!2'!"&'546!2#!"&'546!2YdGGHHGG    Z  j N@KeYLA ;
 4(L     ~ ~M N\[SQIH+*" +4&"26%'"/+"&5'&'"'&'&47>7&/.'546?67&'&47>3267676;2762;RxRVtVh
(PM	|OF(
f
h%PM	|OH	(
f
^;TTvTTx|2P<L
g	<@2| -P<L
g	;C2    Y  ! 1 E J@G+*#"LK 

g  g   g  	_ 			N@=85&3;+!5!34&/.#!"&'5#35463!254&+"7326#!"&'463!2SHHH  
k
kd 6  6  



   6      @      _ N54+7!!%!"&7467!26Y4%$64%6%4@Z%46$%46  # 3 *@'  L   i_ N54+%764/764/&"'&"2?2!"&7467!2QQQQ^4%$64%6%4qQQQQFZ%46$%46       dD@     v53+ D%!"&75463!24%$64%6%4vk%46$k%44        @      v#53+#!"&546;2!2J3Y3JJ33Jw3Jw3JJ33JJ3J    jYR   # 9@6L  g  g  W _   O##&56+!"&'467!23&/&#"&'5!3 6JS~4~ |&<    w   J@GL   ~ M _    N    +!3/"/'62'&6;2wG
DkGC	
HZ
	DlFD
   _  . ; D@A(  L  g  g   i a N&&&&##	+%54&+4&+";#";2654&+";26".>2;
6


55


G
k

k
ernz~RY


Y

Y

Y

Y

utttt jxR   & ?@< ~  g   g   W   _  O3%3&!	+!)!32#!#!"&7463!5463!2T;S6%44%4%$64%T4%$64%%4%44%%4%44       z?-_<     ia    iajxR             Rj  vx                  e                    /Y  Y  Y    Y  v  Yv     l   ,B\p:D
2\@       r        9    `                5          5        :        A        F        K        V      
 + [          	   j   	  
  	    	  
  	  
%  	  /  	  
E  	 
 VO  	  &Copyright (C) 2022 by original authors @ fontello.comiconsRegulariconsiconsVersion 1.0iconsGenerated by svg2ttf from Fontello project.http://fontello.com C o p y r i g h t   ( C )   2 0 2 2   b y   o r i g i n a l   a u t h o r s   @   f o n t e l l o . c o m i c o n s R e g u l a r i c o n s i c o n s V e r s i o n   1 . 0 i c o n s G e n e r a t e d   b y   s v g 2 t t f   f r o m   F o n t e l l o   p r o j e c t . h t t p : / / f o n t e l l o . c o m           
                       	
 attention-1angle-right
angle-down	lite-xlbglite-xl1lite-xl2lite-xl4lite-xl3	left-open
right-openbookcancel-1folder-open-1search-1menu-1cogfloppywindow-maximizewindow-closewindow-minimizefolder-1doc-1
chart-lineinfo-circled-1window-restore                              .. ,  UXEY  K QKSZX4(Y`f UX%a  cc#b!! Y C#D  C`B-, `f-,#!#!-, d BCC ``BCB%CCTx #CCadPxC`B!e!CCB C#BC`B# PXeYC`B-,+CX#!#!CC# PXeY d P&Z(CEcEEX!%YR[X!#!X PPX!@Y 8PX!8YY CEcEad(PX!CEcE 0PX!0Y PX f a 
PX`  PX!
` 6PX!6``YYY%Cc RX K
PX!CKPX!Ka cCc bYYdaY+YY# PXeYY dC#BY-, E %ad CPX#B#B!!Y`-,#!#!+ dbB #BEXCEcC`Ec*! C  +0%&QX`PaRYX#Y!Y @SX+!@Y# PXeY-,	C+  C`B-,	#B#  #Babfc`*-	,  E Cc b  PX@`Yfc`D`-
,	 CEB*!  C`B-, C#D  C`B-,  E +# C%` E#a d  PX! 0PX @YY# PXeY%#aDD`-,  E +# C%` E#a d$PX @Y# PXeY%#aDD`-,  #B EPX!#!Y*!-,EdaD-,`  CJ PX #BYCJ RX #BY-, bfc  c#aC` ` #B#-,KTXdDY$e#x-,KQXKSXdDY!Y$e#x-, CUXCaB+Y C%B%B%B# %PX C`%B #a*!#a #a*! C`%B%a*!YCGCG`b  PX@`Yfc Cc b  PX@`Yfc`  #DC >C`B-,  ETX#B E#B#`B `   BBB` #Ba++"Y-, +-,+-,+-,+-,+-,+-,+-,+-,+-,	+-+,# bfc`KTX# .]!!Y-,,# bfc`KTX# .q!!Y--,# bfc&`KTX# .r!!Y- , + ETX#B E#B#`B `a  BB`++"Y-!,  +-", +-#, +-$, +-%, +-&, +-', +-(, +-), +-*,	 +-., <`-/, `` C#`C%a`.*!-0,/+/*-1,  G  Cc b  PX@`Yfc`#a8# UX G  Cc b  PX@`Yfc`#a8!Y-2,  ETXEB1*EX0Y"Y-3, + ETXEB1*EX0Y"Y-4, 5`-5, EBEc b  PX@`Yfc+Cc b  PX@`Yfc+      D>#84*!-6, < G Cc b  PX@`Yfc` Ca8-7,.<-8, < G Cc b  PX@`Yfc` CaCc8-9, % . G #B%IG#G#a Xb!Y#B8*-:, #B%%G#G#a BC+e.#  <8-;, #B%% .G#G#a #B BC+ `PX @QX  &YBB# 
C #G#G#a#F`Cb  PX@`Yfc` + a C`d#CadPXCaC`Y%b  PX@`Yfca#  &#Fa8#
CF%
CG#G#a` Cb  PX@`Yfc`# +#C`+%a%b  PX@`Yfc&a %`d#%`dPX!#!Y#  &#Fa8Y-<, #B   & .G#G#a#<8-=, #B 
#B   F#G+#a8->, #B%%G#G#a TX. <#!%%G#G#a %%G#G#a%%I%a  cc# Xb!Yc b  PX@`Yfc`#.#  <8#!Y-?, #B 
C .G#G#a ` `fb  PX@`Yfc#  <8-@,# .F%FCXPRYX <Y.0+-A,# .F%FCXRPYX <Y.0+-B,# .F%FCXPRYX <Y# .F%FCXRPYX <Y.0+-C,:+# .F%FCXPRYX <Y.0+-D,;+  <#B8# .F%FCXPRYX <Y.0+C.0+-E, %&   F#Ga#B.G#G#aC+# < .#80+-F,
%B %% .G#G#a #B BC+ `PX @QX  &YBB# GCb  PX@`Yfc` + a C`d#CadPXCaC`Y%b  PX@`Yfca%Fa8# <#8!  F#G+#a8!Y0+-G, :+.0+-H, ;+!#  <#B#80+C.0+-I,  G #B .6*-J,  G #B .6*-K, 7*-L,9*-M, E# . F#a80+-N,
#BM+-O,  F+-P, F+-Q, F+-R,F+-S,  G+-T, G+-U, G+-V,G+-W,   C+-X,  C+-Y,  C+-Z, C+-[,  C+-\, C+-], C+-^,C+-_,  E+-`, E+-a, E+-b,E+-c,  H+-d, H+-e, H+-f,H+-g,   D+-h,  D+-i,  D+-j, D+-k,  D+-l, D+-m, D+-n,D+-o, <+.0+-p, <+@+-q, <+A+-r,  <+B+-s,<+@+-t,<+A+-u, <+B+-v, =+.0+-w, =+@+-x, =+A+-y, =+B+-z,=+@+-{,=+A+-|,=+B+-}, >+.0+-~, >+@+-, >+A+-, >+B+-,>+@+-,>+A+-,>+B+-, ?+.0+-, ?+@+-, ?+A+-, ?+B+-,?+@+-,?+A+-,?+B+-, EPXEX#!!YYB+e$PxEX0Y- K RXY  cp B  * B
* B
* B@  * 	B @  *   D$QX@X  dD(QX X   DY'QX @cTX   DYYYYY* Dd DD -- mod-version:3
local core = require "core"
local common = require "core.common"
local config = require "core.config"
local command = require "core.command"
local style = require "core.style"
local keymap = require "core.keymap"
local translate = require "core.doc.translate"
local RootView = require "core.rootview"
local DocView = require "core.docview"
local Doc = require "core.doc"

config.plugins.autocomplete = common.merge({
  -- Amount of characters that need to be written for autocomplete
  min_len = 3,
  -- The max amount of visible items
  max_height = 6,
  -- The max amount of scrollable items
  max_suggestions = 100,
  -- Maximum amount of symbols to cache per document
  max_symbols = 4000,
  -- Font size of the description box
  desc_font_size = 12,
  -- The config specification used by gui generators
  config_spec = {
    name = "Autocomplete",
    {
      label = "Minimum Length",
      description = "Amount of characters that need to be written for autocomplete to popup.",
      path = "min_len",
      type = "number",
      default = 3,
      min = 1,
      max = 5
    },
    {
      label = "Maximum Height",
      description = "The maximum amount of visible items.",
      path = "max_height",
      type = "number",
      default = 6,
      min = 1,
      max = 20
    },
    {
      label = "Maximum Suggestions",
      description = "The maximum amount of scrollable items.",
      path = "max_suggestions",
      type = "number",
      default = 100,
      min = 10,
      max = 10000
    },
    {
      label = "Maximum Symbols",
      description = "Maximum amount of symbols to cache per document.",
      path = "max_symbols",
      type = "number",
      default = 4000,
      min = 1000,
      max = 10000
    },
    {
      label = "Description Font Size",
      description = "Font size of the description box.",
      path = "desc_font_size",
      type = "number",
      default = 12,
      min = 8
    }
  }
}, config.plugins.autocomplete)

local autocomplete = {}

autocomplete.map = {}
autocomplete.map_manually = {}
autocomplete.on_close = nil

-- Flag that indicates if the autocomplete box was manually triggered
-- with the autocomplete.complete() function to prevent the suggestions
-- from getting cluttered with arbitrary document symbols by using the
-- autocomplete.map_manually table.
local triggered_manually = false

local mt = { __tostring = function(t) return t.text end }

function autocomplete.add(t, manually_triggered)
  local items = {}
  for text, info in pairs(t.items) do
    if type(info) == "table" then
      table.insert(
        items,
        setmetatable(
          {
            text = text,
            info = info.info,
            desc = info.desc,          -- Description shown on item selected
            onhover = info.onhover,    -- A callback called once when item is hovered
            onselect = info.onselect,  -- A callback called when item is selected
            data = info.data           -- Optional data that can be used on cb
          },
          mt
        )
      )
    else
      info = (type(info) == "string") and info
      table.insert(items, setmetatable({ text = text, info = info }, mt))
    end
  end

  if not manually_triggered then
    autocomplete.map[t.name] =  { files = t.files or ".*", items = items }
  else
    autocomplete.map_manually[t.name] =  { files = t.files or ".*", items = items }
  end
end

--
-- Thread that scans open document symbols and cache them
--
local max_symbols = config.plugins.autocomplete.max_symbols

core.add_thread(function()
  local cache = setmetatable({}, { __mode = "k" })

  local function get_syntax_symbols(symbols, doc)
    if doc.syntax then
      for sym in pairs(doc.syntax.symbols) do
        symbols[sym] = true
      end
    end
  end

  local function get_symbols(doc)
    local s = {}
    get_syntax_symbols(s, doc)
    if doc.disable_symbols then return s end
    local i = 1
    local symbols_count = 0
    while i <= #doc.lines do
      for sym in doc.lines[i]:gmatch(config.symbol_pattern) do
        if not s[sym] then
          symbols_count = symbols_count + 1
          if symbols_count > max_symbols then
            s = nil
            doc.disable_symbols = true
            local filename_message
            if doc.filename then
              filename_message = "document " .. doc.filename
            else
              filename_message = "unnamed document"
            end
            core.status_view:show_message("!", style.accent,
              "Too many symbols in "..filename_message..
              ": stopping auto-complete for this document according to "..
              "config.plugins.autocomplete.max_symbols."
            )
            collectgarbage('collect')
            return {}
          end
          s[sym] = true
        end
      end
      i = i + 1
      if i % 100 == 0 then coroutine.yield() end
    end
    return s
  end

  local function cache_is_valid(doc)
    local c = cache[doc]
    return c and c.last_change_id == doc:get_change_id()
  end

  while true do
    local symbols = {}

    -- lift all symbols from all docs
    for _, doc in ipairs(core.docs) do
      -- update the cache if the doc has changed since the last iteration
      if not cache_is_valid(doc) then
        cache[doc] = {
          last_change_id = doc:get_change_id(),
          symbols = get_symbols(doc)
        }
      end
      -- update symbol set with doc's symbol set
      for sym in pairs(cache[doc].symbols) do
        symbols[sym] = true
      end
      coroutine.yield()
    end

    -- update symbols list
    autocomplete.add { name = "open-docs", items = symbols }

    -- wait for next scan
    local valid = true
    while valid do
      coroutine.yield(1)
      for _, doc in ipairs(core.docs) do
        if not cache_is_valid(doc) then
          valid = false
          break
        end
      end
    end

  end
end)


local partial = ""
local suggestions_idx = 1
local suggestions = {}
local last_line, last_col


local function reset_suggestions()
  suggestions_idx = 1
  suggestions = {}

  triggered_manually = false

  local doc = core.active_view.doc
  if autocomplete.on_close then
    autocomplete.on_close(doc, suggestions[suggestions_idx])
    autocomplete.on_close = nil
  end
end

local function update_suggestions()
  local doc = core.active_view.doc
  local filename = doc and doc.filename or ""

  local map = autocomplete.map

  if triggered_manually then
    map = autocomplete.map_manually
  end

  -- get all relevant suggestions for given filename
  local items = {}
  for _, v in pairs(map) do
    if common.match_pattern(filename, v.files) then
      for _, item in pairs(v.items) do
        table.insert(items, item)
      end
    end
  end

  -- fuzzy match, remove duplicates and store
  items = common.fuzzy_match(items, partial)
  local j = 1
  for i = 1, config.plugins.autocomplete.max_suggestions do
    suggestions[i] = items[j]
    while items[j] and items[i].text == items[j].text do
      items[i].info = items[i].info or items[j].info
      j = j + 1
    end
  end
  suggestions_idx = 1
end

local function get_partial_symbol()
  local doc = core.active_view.doc
  local line2, col2 = doc:get_selection()
  local line1, col1 = doc:position_offset(line2, col2, translate.start_of_word)
  return doc:get_text(line1, col1, line2, col2)
end

local function get_active_view()
  if core.active_view:is(DocView) then
    return core.active_view
  end
end

local function get_suggestions_rect(av)
  if #suggestions == 0 then
    return 0, 0, 0, 0
  end

  local line, col = av.doc:get_selection()
  local x, y = av:get_line_screen_position(line, col - #partial)
  y = y + av:get_line_height() + style.padding.y
  local font = av:get_font()
  local th = font:get_height()

  local max_width = 0
  for _, s in ipairs(suggestions) do
    local w = font:get_width(s.text)
    if s.info then
      w = w + style.font:get_width(s.info) + style.padding.x
    end
    max_width = math.max(max_width, w)
  end

  local ah = config.plugins.autocomplete.max_height

  local max_items = #suggestions
  if max_items > ah then
    max_items = ah
  end

  -- additional line to display total items
  max_items = max_items + 1

  if max_width < 150 then
    max_width = 150
  end

  -- if portion not visiable to right, reposition to DocView right margin
  if (x - av.position.x) + max_width > av.size.x then
    x = (av.size.x + av.position.x) - max_width - (style.padding.x * 2)
  end

  return
    x - style.padding.x,
    y - style.padding.y,
    max_width + style.padding.x * 2,
    max_items * (th + style.padding.y) + style.padding.y
end

local function wrap_line(line, max_chars)
  if #line > max_chars then
    local lines = {}
    local line_len = #line
    local new_line = ""
    local prev_char = ""
    local position = 0
    local indent = line:match("^%s+")
    for char in line:gmatch(".") do
      position = position + 1
      if #new_line < max_chars then
        new_line = new_line .. char
        prev_char = char
        if position >= line_len then
          table.insert(lines, new_line)
        end
      else
        if
          not prev_char:match("%s")
          and
          not string.sub(line, position+1, 1):match("%s")
          and
          position < line_len
        then
          new_line = new_line .. "-"
        end
        table.insert(lines, new_line)
        if indent then
          new_line = indent .. char
        else
          new_line = char
        end
      end
    end
    return lines
  end
  return line
end

local previous_scale = SCALE
local desc_font = style.code_font:copy(
  config.plugins.autocomplete.desc_font_size * SCALE
)
local function draw_description_box(text, av, sx, sy, sw, sh)
  if previous_scale ~= SCALE then
    desc_font = style.code_font:copy(
      config.plugins.autocomplete.desc_font_size * SCALE
    )
    previous_scale = SCALE
  end

  local font = desc_font
  local lh = font:get_height()
  local y = sy + style.padding.y
  local x = sx + sw + style.padding.x / 4
  local width = 0
  local char_width = font:get_width(" ")
  local draw_left = false;

  local max_chars = 0
  if sx - av.position.x < av.size.x - (sx - av.position.x) - sw then
    max_chars = (((av.size.x+av.position.x) - x) / char_width) - 5
  else
    draw_left = true;
    max_chars = (
      (sx - av.position.x - (style.padding.x / 4) - style.scrollbar_size)
      / char_width
    ) - 5
  end

  local lines = {}
  for line in string.gmatch(text.."\n", "(.-)\n") do
    local wrapper_lines = wrap_line(line, max_chars)
    if type(wrapper_lines) == "table" then
      for _, wrapped_line in pairs(wrapper_lines) do
        width = math.max(width, font:get_width(wrapped_line))
        table.insert(lines, wrapped_line)
      end
    else
      width = math.max(width, font:get_width(line))
      table.insert(lines, line)
    end
  end

  if draw_left then
    x = sx - (style.padding.x / 4) - width - (style.padding.x * 2)
  end

  local height = #lines * font:get_height()

  -- draw background rect
  renderer.draw_rect(
    x,
    sy,
    width + style.padding.x * 2,
    height + style.padding.y * 2,
    style.background3
  )

  -- draw text
  for _, line in pairs(lines) do
    common.draw_text(
      font, style.text, line, "left",
      x + style.padding.x, y, width, lh
    )
    y = y + lh
  end
end

local function draw_suggestions_box(av)
  if #suggestions <= 0 then
    return
  end

  local ah = config.plugins.autocomplete.max_height

  -- draw background rect
  local rx, ry, rw, rh = get_suggestions_rect(av)
  renderer.draw_rect(rx, ry, rw, rh, style.background3)

  -- draw text
  local font = av:get_font()
  local lh = font:get_height() + style.padding.y
  local y = ry + style.padding.y / 2
  local show_count = #suggestions <= ah and #suggestions or ah
  local start_index = suggestions_idx > ah and (suggestions_idx-(ah-1)) or 1

  for i=start_index, start_index+show_count-1, 1 do
    if not suggestions[i] then
      break
    end
    local s = suggestions[i]
    local color = (i == suggestions_idx) and style.accent or style.text
    common.draw_text(font, color, s.text, "left", rx + style.padding.x, y, rw, lh)
    if s.info then
      color = (i == suggestions_idx) and style.text or style.dim
      common.draw_text(style.font, color, s.info, "right", rx, y, rw - style.padding.x, lh)
    end
    y = y + lh
    if suggestions_idx == i then
      if s.onhover then
        s.onhover(suggestions_idx, s)
        s.onhover = nil
      end
      if s.desc and #s.desc > 0 then
        draw_description_box(s.desc, av, rx, ry, rw, rh)
      end
    end
  end

  renderer.draw_rect(rx, y, rw, 2, style.caret)
  renderer.draw_rect(rx, y+2, rw, lh, style.background)
  common.draw_text(
    style.font,
    style.accent,
    "Items",
    "left",
    rx + style.padding.x, y, rw, lh
  )
  common.draw_text(
    style.font,
    style.accent,
    tostring(suggestions_idx) .. "/" .. tostring(#suggestions),
    "right",
    rx, y, rw - style.padding.x, lh
  )
end

local function show_autocomplete()
  local av = get_active_view()
  if av then
    -- update partial symbol and suggestions
    partial = get_partial_symbol()

    if #partial >= config.plugins.autocomplete.min_len or triggered_manually then
      update_suggestions()

      if not triggered_manually then
        last_line, last_col = av.doc:get_selection()
      else
        local line, col = av.doc:get_selection()
        local char = av.doc:get_char(line, col-1, line, col-1)

        if char:match("%s") or (char:match("%p") and col ~= last_col) then
          reset_suggestions()
        end
      end
    else
      reset_suggestions()
    end

    -- scroll if rect is out of bounds of view
    local _, y, _, h = get_suggestions_rect(av)
    local limit = av.position.y + av.size.y
    if y + h > limit then
      av.scroll.to.y = av.scroll.y + y + h - limit
    end
  end
end

--
-- Patch event logic into RootView and Doc
--
local on_text_input = RootView.on_text_input
local on_text_remove = Doc.remove
local update = RootView.update
local draw = RootView.draw

RootView.on_text_input = function(...)
  on_text_input(...)
  show_autocomplete()
end

Doc.remove = function(self, line1, col1, line2, col2)
  on_text_remove(self, line1, col1, line2, col2)

  if triggered_manually and line1 == line2 then
    if last_col >= col1 then
      reset_suggestions()
    else
      show_autocomplete()
    end
  end
end

RootView.update = function(...)
  update(...)

  local av = get_active_view()
  if av then
    -- reset suggestions if caret was moved
    local line, col = av.doc:get_selection()

    if not triggered_manually then
      if line ~= last_line or col ~= last_col then
        reset_suggestions()
      end
    else
      if line ~= last_line or col < last_col then
        reset_suggestions()
      end
    end
  end
end

RootView.draw = function(...)
  draw(...)

  local av = get_active_view()
  if av then
    -- draw suggestions box after everything else
    core.root_view:defer_draw(draw_suggestions_box, av)
  end
end

--
-- Public functions
--
function autocomplete.open(on_close)
  triggered_manually = true

  if on_close then
    autocomplete.on_close = on_close
  end

  local av = get_active_view()
  if av then
    partial = get_partial_symbol()
    last_line, last_col = av.doc:get_selection()
    update_suggestions()
  end
end

function autocomplete.close()
  reset_suggestions()
end

function autocomplete.is_open()
  return #suggestions > 0
end

function autocomplete.complete(completions, on_close)
  reset_suggestions()

  autocomplete.map_manually = {}
  autocomplete.add(completions, true)

  autocomplete.open(on_close)
end

function autocomplete.can_complete()
  if #partial >= config.plugins.autocomplete.min_len then
    return true
  end
  return false
end


--
-- Commands
--
local function predicate()
  local active_docview = get_active_view()
  return active_docview and #suggestions > 0, active_docview
end

command.add(predicate, {
  ["autocomplete:complete"] = function(dv)
    local doc = dv.doc
    local line, col = doc:get_selection()
    local item = suggestions[suggestions_idx]
    local text = item.text
    local inserted = false
    if item.onselect then
      inserted = item.onselect(suggestions_idx, item)
    end
    if not inserted then
      local current_partial = get_partial_symbol()
      doc:insert(line, col, text)
      doc:remove(line, col, line, col - #current_partial)
      doc:set_selection(line, col + #text - #current_partial)
    end
    reset_suggestions()
  end,

  ["autocomplete:previous"] = function()
    suggestions_idx = (suggestions_idx - 2) % #suggestions + 1
  end,

  ["autocomplete:next"] = function()
    suggestions_idx = (suggestions_idx % #suggestions) + 1
  end,

  ["autocomplete:cycle"] = function()
    local newidx = suggestions_idx + 1
    suggestions_idx = newidx > #suggestions and 1 or newidx
  end,

  ["autocomplete:cancel"] = function()
    reset_suggestions()
  end,
})

--
-- Keymaps
--
keymap.add {
  ["tab"]    = "autocomplete:complete",
  ["up"]     = "autocomplete:previous",
  ["down"]   = "autocomplete:next",
  ["escape"] = "autocomplete:cancel",
}


return autocomplete
-- mod-version:3
local core = require "core"
local config = require "core.config"
local style = require "core.style"
local Doc = require "core.doc"
local Node = require "core.node"
local common = require "core.common"
local dirwatch = require "core.dirwatch"

config.plugins.autoreload = common.merge({
  always_show_nagview = false,
  config_spec = {
    name = "Autoreload",
    {
      label = "Always Show Nagview",
      description = "Alerts you if an opened file changes externally even if you haven't modified it.",
      path = "always_show_nagview",
      type = "toggle",
      default = false
    }
  }
}, config.plugins.autoreload)

local watch = dirwatch.new()
local times = setmetatable({}, { __mode = "k" })
local visible = setmetatable({}, { __mode = "k" })

local function get_project_doc_watch(doc)
  for i, v in ipairs(core.project_directories) do
    if doc.abs_filename:find(v.name, 1, true) == 1 then return v.watch end
  end
  return watch
end

local function update_time(doc)
  times[doc] = system.get_file_info(doc.filename).modified
end

local function reload_doc(doc)
  doc:reload()
  update_time(doc)
  core.redraw = true
  core.log_quiet("Auto-reloaded doc \"%s\"", doc.filename)
end

local function check_prompt_reload(doc)
  if doc and doc.deferred_reload then
    core.nag_view:show("File Changed", doc.filename .. " has changed. Reload this file?", {
      { font = style.font, text = "Yes", default_yes = true },
      { font = style.font, text = "No" , default_no = true }
    }, function(item)
      if item.text == "Yes" then reload_doc(doc) end
      doc.deferred_reload = false
    end)
  end
end

local function doc_changes_visiblity(doc, visibility)
  if doc and visible[doc] ~= visibility and doc.abs_filename then
    visible[doc] = visibility
    if visibility then check_prompt_reload(doc) end
    get_project_doc_watch(doc):watch(doc.abs_filename, visibility)
  end
end

local on_check = dirwatch.check
function dirwatch:check(change_callback, ...)
  on_check(self, function(dir)
    for _, doc in ipairs(core.docs) do
      if doc.abs_filename and (dir == common.dirname(doc.abs_filename) or dir == doc.abs_filename) then
        local info = system.get_file_info(doc.filename or "")
        if info and times[doc] ~= info.modified then
          if not doc:is_dirty() and not config.plugins.autoreload.always_show_nagview then
            reload_doc(doc)
          else
            doc.deferred_reload = true
            if doc == core.active_view.doc then check_prompt_reload(doc) end
          end
        end
      end
    end
    change_callback(dir)
  end, ...)
end

local core_set_active_view = core.set_active_view
function core.set_active_view(view)
  core_set_active_view(view)
  doc_changes_visiblity(view.doc, true)
end

local node_set_active_view = Node.set_active_view
function Node:set_active_view(view)
  if self.active_view then doc_changes_visiblity(self.active_view.doc, false) end
  node_set_active_view(self, view)
  doc_changes_visiblity(self.active_view.doc, true)
end

core.add_thread(function()
  while true do
    -- because we already hook this function above; we only
    -- need to check the file.
    watch:check(function() end)
    coroutine.yield(0.05)
  end
end)

-- patch `Doc.save|load` to store modified time
local load = Doc.load
local save = Doc.save

Doc.load = function(self, ...)
  local res = load(self, ...)
  update_time(self)
  return res
end

Doc.save = function(self, ...)
  local res = save(self, ...)
  -- if starting with an unsaved document with a filename.
  if not times[self] then get_project_doc_watch(self):watch(self.abs_filename, true) end
  update_time(self)
  return res
end
-- mod-version:3
local core = require "core"
local command = require "core.command"
local keymap = require "core.keymap"
local ContextMenu = require "core.contextmenu"
local RootView = require "core.rootview"

local menu = ContextMenu()
local on_view_mouse_pressed = RootView.on_view_mouse_pressed
local on_mouse_moved = RootView.on_mouse_moved
local root_view_update = RootView.update
local root_view_draw = RootView.draw

function RootView:on_mouse_moved(...)
  if menu:on_mouse_moved(...) then return end
  on_mouse_moved(self, ...)
end

function RootView.on_view_mouse_pressed(button, x, y, clicks)
  -- We give the priority to the menu to process mouse pressed events.
  local handled = menu:on_mouse_pressed(button, x, y, clicks)
  return handled or on_view_mouse_pressed(button, x, y, clicks)
end

function RootView:update(...)
  root_view_update(self, ...)
  menu:update()
end

function RootView:draw(...)
  root_view_draw(self, ...)
  menu:draw()
end

command.add("core.docview!", {
  ["context:show"] = function(dv)
    menu:show(dv.position.x, dv.position.y)
  end
})

keymap.add {
  ["menu"] = "context:show"
}

command.add(function() return menu.show_context_menu == true end, {
  ["context:focus-previous"] = function()
    menu:focus_previous()
  end,
  ["context:focus-next"] = function()
    menu:focus_next()
  end,
  ["context:hide"] = function()
    menu:hide()
  end,
  ["context:on-selected"] = function()
    menu:call_selected_item()
  end,
})
keymap.add { ["return"] = "context:on-selected" }
keymap.add { ["up"] = "context:focus-previous" }
keymap.add { ["down"] = "context:focus-next" }
keymap.add { ["escape"] = "context:hide" }

if require("plugins.scale") then
  menu:register("core.docview", {
    { text = "Cut",         command = "doc:cut" },
    { text = "Copy",        command = "doc:copy" },
    { text = "Paste",       command = "doc:paste" },
    { text = "Font +",      command = "scale:increase" },
    { text = "Font -",      command = "scale:decrease" },
    { text = "Font Reset",  command = "scale:reset"    },
    ContextMenu.DIVIDER,
    { text = "Find",        command = "find-replace:find"    },
    { text = "Replace",     command = "find-replace:replace" }
  })
end

return menu
-- mod-version:3
local core = require "core"
local command = require "core.command"
local common = require "core.common"
local config = require "core.config"
local core_syntax = require "core.syntax"
local DocView = require "core.docview"
local Doc = require "core.doc"

local cache = setmetatable({}, { __mode = "k" })
local comments_cache = {}
local auto_detect_max_lines = 150


local function indent_occurrences_more_than_once(stat, idx)
  if stat[idx-1] and stat[idx-1] == stat[idx] then
    return true
  elseif stat[idx+1] and stat[idx+1] == stat[idx] then
    return true
  end
  return false
end


local function optimal_indent_from_stat(stat)
  if #stat == 0 then return nil, 0 end
  table.sort(stat, function(a, b) return a > b end)
  local best_indent = 0
  local best_score = 0
  local count = #stat
  for x=1, count do
    local indent = stat[x]
    local score = 0
    for y=1, count do
      if y ~= x and stat[y] % indent == 0 then
        score = score + 1
      elseif
        indent > stat[y]
        and
        indent_occurrences_more_than_once(stat, y)
      then
        score = 0
        break
      end
    end
    if score > best_score then
      best_indent = indent
      best_score = score
    end
    if score > 0 then
      break
    end
  end
  return best_score > 0 and best_indent or nil, best_score
end


local function escape_comment_tokens(token)
  local special_chars = "*-%[].()+?^$"
  local escaped = ""
  for x=1, token:len() do
    local found = false
    for y=1, special_chars:len() do
      if token:sub(x, x) == special_chars:sub(y, y) then
        escaped = escaped .. "%" .. token:sub(x, x)
        found = true
        break
      end
    end
    if not found then
      escaped = escaped .. token:sub(x, x)
    end
  end
  return escaped
end


local function get_comment_patterns(syntax, _loop)
  _loop = _loop or 1
  if _loop > 5 then return end
  if comments_cache[syntax] then
    if #comments_cache[syntax] > 0 then
      return comments_cache[syntax]
    else
      return nil
    end
  end
  local comments = {}
  for idx=1, #syntax.patterns do
    local pattern = syntax.patterns[idx]
    local startp = ""
    if
      type(pattern.type) == "string"
      and
      (pattern.type == "comment" or pattern.type == "string")
    then
      local not_is_string = pattern.type ~= "string"
      if pattern.pattern then
        startp = type(pattern.pattern) == "table"
          and pattern.pattern[1] or pattern.pattern
        if not_is_string and startp:sub(1, 1) ~= "^" then
          startp = "^%s*" .. startp
        elseif not_is_string then
          startp = "^%s*" .. startp:sub(2, startp:len())
        end
        if type(pattern.pattern) == "table" then
          table.insert(comments, {"p", startp, pattern.pattern[2]})
        elseif not_is_string then
          table.insert(comments, {"p", startp})
        end
      elseif pattern.regex then
        startp = type(pattern.regex) == "table"
          and pattern.regex[1] or pattern.regex
        if not_is_string and startp:sub(1, 1) ~= "^" then
          startp = "^\\s*" .. startp
        elseif not_is_string then
          startp = "^\\s*" .. startp:sub(2, startp:len())
        end
        if type(pattern.regex) == "table" then
          table.insert(comments, {
            "r", regex.compile(startp), regex.compile(pattern.regex[2])
          })
        elseif not_is_string then
          table.insert(comments, {"r", regex.compile(startp)})
        end
      end
    elseif pattern.syntax then
      local subsyntax = type(pattern.syntax) == 'table' and pattern.syntax
        or core_syntax.get("file"..pattern.syntax, "")
      local sub_comments = get_comment_patterns(subsyntax, _loop + 1)
      if sub_comments then
        for s=1, #sub_comments do
          table.insert(comments, sub_comments[s])
        end
      end
    end
  end
  if #comments == 0 then
    local single_line_comment = syntax.comment
      and escape_comment_tokens(syntax.comment) or nil
    local block_comment = nil
    if syntax.block_comment then
      block_comment = {
        escape_comment_tokens(syntax.block_comment[1]),
        escape_comment_tokens(syntax.block_comment[2])
      }
    end
    if single_line_comment then
      table.insert(comments, {"p", "^%s*" .. single_line_comment})
    end
    if block_comment then
      table.insert(comments, {"p", "^%s*" .. block_comment[1], block_comment[2]})
    end
  end
  comments_cache[syntax] = comments
  if #comments > 0 then
    return comments
  end
  return nil
end


local function get_non_empty_lines(syntax, lines)
  return coroutine.wrap(function()
    local comments = get_comment_patterns(syntax)

    local i = 0
    local end_regex = nil
    local end_pattern = nil
    local inside_comment = false
    for _, line in ipairs(lines) do
      if line:gsub("^%s+", "") ~= "" then
        local is_comment = false
        if comments then
          if not inside_comment then
            for c=1, #comments do
              local comment = comments[c]
              if comment[1] == "p" then
                if comment[3] then
                  local start, ending = line:find(comment[2])
                  if start then
                    if not line:find(comment[3], ending+1) then
                      is_comment = true
                      inside_comment = true
                      end_pattern = comment[3]
                    end
                    break
                  end
                elseif line:find(comment[2]) then
                  is_comment = true
                  break
                end
              else
                if comment[3] then
                  local start, ending = regex.find_offsets(
                    comment[2], line, 1, regex.ANCHORED
                  )
                  if start then
                    if not regex.find_offsets(
                        comment[3], line, ending+1, regex.ANCHORED
                      )
                    then
                      is_comment = true
                      inside_comment = true
                      end_regex = comment[3]
                    end
                    break
                  end
                elseif regex.find_offsets(comment[2], line, 1, regex.ANCHORED) then
                  is_comment = true
                  break
                end
              end
            end
          elseif end_pattern and line:find(end_pattern) then
            is_comment = true
            inside_comment = false
            end_pattern = nil
          elseif end_regex and regex.find_offsets(end_regex, line) then
            is_comment = true
            inside_comment = false
            end_regex = nil
          end
        end
        if
          not is_comment
          and
          not inside_comment
        then
          i = i + 1
          coroutine.yield(i, line)
        end
      end
    end
  end)
end


local function detect_indent_stat(doc)
  local stat = {}
  local tab_count = 0
  local runs = 1
  local max_lines = auto_detect_max_lines
  for i, text in get_non_empty_lines(doc.syntax, doc.lines) do
    local spaces = text:match("^ +")
    if spaces then table.insert(stat, spaces:len()) end
    local tabs = text:match("^\t+")
    if tabs then tab_count = tab_count + 1 end
    -- if nothing found for first lines try at least 4 more times
    if i == max_lines and runs < 5 and #stat == 0 and tab_count == 0 then
      max_lines = max_lines + auto_detect_max_lines
      runs = runs + 1
    -- Stop parsing when files is very long. Not needed for euristic determination.
    elseif i > max_lines then break end
  end
  local indent, score = optimal_indent_from_stat(stat)
  if tab_count > score then
    return "hard", config.indent_size, tab_count
  else
    return "soft", indent or config.indent_size, score or 0
  end
end


local function update_cache(doc)
  local type, size, score = detect_indent_stat(doc)
  local score_threshold = 2
  if score < score_threshold then
    -- use default values
    type = config.tab_type
    size = config.indent_size
  end
  cache[doc] = { type = type, size = size, confirmed = (score >= score_threshold) }
  doc.indent_info = cache[doc]
end


local new = Doc.new
function Doc:new(...)
  new(self, ...)
  update_cache(self)
end

local clean = Doc.clean
function Doc:clean(...)
  clean(self, ...)
  local _, _, confirmed = self:get_indent_info()
  if not confirmed then
    update_cache(self)
  end
end


local function set_indent_type(doc, type)
  local _, indent_size = doc:get_indent_info()
  cache[doc] = {
    type = type,
    size = indent_size,
    confirmed = true
  }
  doc.indent_info = cache[doc]
end

local function set_indent_type_command(dv)
  core.command_view:enter("Specify indent style for this file", {
    submit = function(value)
      local doc = dv.doc
      value = value:lower()
      set_indent_type(doc, value == "tabs" and "hard" or "soft")
    end,
    suggest = function(text)
      return common.fuzzy_match({"tabs", "spaces"}, text)
    end,
    validate = function(text)
      local t = text:lower()
      return t == "tabs" or t == "spaces"
    end
  })
end


local function set_indent_size(doc, size)
  local indent_type = doc:get_indent_info()
  cache[doc] = {
    type = indent_type,
    size = size,
    confirmed = true
  }
  doc.indent_info = cache[doc]
end

local function set_indent_size_command(dv)
  core.command_view:enter("Specify indent size for current file", {
    submit = function(value)
      value = math.floor(tonumber(value))
      local doc = dv.doc
      set_indent_size(doc, value)
    end,
    validate = function(value)
      value = tonumber(value)
      return value ~= nil and value >= 1
    end
  })
end


command.add("core.docview", {
  ["indent:set-file-indent-type"] = set_indent_type_command,
  ["indent:set-file-indent-size"] = set_indent_size_command
})

command.add(
  function()
    return core.active_view:is(DocView)
      and cache[core.active_view.doc]
      and cache[core.active_view.doc].type == "soft"
  end, {
  ["indent:switch-file-to-tabs-indentation"] = function()
    set_indent_type(core.active_view.doc, "hard")
  end
})

command.add(
  function()
    return core.active_view:is(DocView)
      and cache[core.active_view.doc]
      and cache[core.active_view.doc].type == "hard"
  end, {
  ["indent:switch-file-to-spaces-indentation"] = function()
    set_indent_type(core.active_view.doc, "soft")
  end
})
-- mod-version:3

local style = require "core.style"
local DocView = require "core.docview"
local common = require "core.common"
local config = require "core.config"
local Highlighter = require "core.doc.highlighter"

config.plugins.drawwhitespace = common.merge({
  enabled = true,
  show_leading = true,
  show_trailing = true,
  show_middle = true,

  show_middle_min = 1,

  color = style.syntax.whitespace or style.syntax.comment,
  leading_color = nil,
  middle_color = nil,
  trailing_color = nil,

  substitutions = {
    {
      char = " ",
      sub = "",
      -- You can put any of the previous options here too.
      -- For example:
      -- show_middle_min = 2,
      -- show_leading = false,
    },
    {
      char = "\t",
      sub = "",
    },
  },

  config_spec = {
    name = "Draw Whitespace",
    {
      label = "Enabled",
      description = "Disable or enable the drawing of white spaces.",
      path = "enabled",
      type = "toggle",
      default = true
    },
    {
      label = "Show Leading",
      description = "Draw whitespaces starting at the beginning of a line.",
      path = "show_leading",
      type = "toggle",
      default = true,
    },
    {
      label = "Show Middle",
      description = "Draw whitespaces on the middle of a line.",
      path = "show_middle",
      type = "toggle",
      default = true,
    },
    {
      label = "Show Trailing",
      description = "Draw whitespaces on the end of a line.",
      path = "show_trailing",
      type = "toggle",
      default = true,
    },
    {
      label = "Show Trailing as Error",
      description = "Uses an error square to spot them easily, requires 'Show Trailing' enabled.",
      path = "show_trailing_error",
      type = "toggle",
      default = false,
      on_apply = function(enabled)
        local found = nil
        local substitutions = config.plugins.drawwhitespace.substitutions
        for i, sub in ipairs(substitutions) do
          if sub.trailing_error then
            found = i
          end
        end
        if found == nil and enabled then
          table.insert(substitutions, {
            char = " ",
            sub = "",
            show_leading = false,
            show_middle = false,
            show_trailing = true,
            trailing_color = style.error,
            trailing_error = true
          })
        elseif found ~= nil and not enabled then
          table.remove(substitutions, found)
        end
      end
    }
  }
}, config.plugins.drawwhitespace)


local ws_cache
local cached_settings
local function reset_cache()
  ws_cache = setmetatable({}, { __mode = "k" })
  local settings = config.plugins.drawwhitespace
  cached_settings = {
    show_leading = settings.show_leading,
    show_trailing = settings.show_trailing,
    show_middle = settings.show_middle,
    show_middle_min = settings.show_middle_min,
    color = settings.color,
    leading_color = settings.leading_color,
    middle_color = settings.middle_color,
    trailing_color = settings.trailing_color,
    substitutions = settings.substitutions,
  }
end
reset_cache()

local function reset_cache_if_needed()
  local settings = config.plugins.drawwhitespace
  if
    not ws_cache or
    cached_settings.show_leading       ~= settings.show_leading
    or cached_settings.show_trailing   ~= settings.show_trailing
    or cached_settings.show_middle     ~= settings.show_middle
    or cached_settings.show_middle_min ~= settings.show_middle_min
    or cached_settings.color           ~= settings.color
    or cached_settings.leading_color   ~= settings.leading_color
    or cached_settings.middle_color    ~= settings.middle_color
    or cached_settings.trailing_color  ~= settings.trailing_color
    -- we assume that the entire table changes
    or cached_settings.substitutions   ~= settings.substitutions
  then
    reset_cache()
  end
end

-- Move cache to make space for new lines
local prev_insert_notify = Highlighter.insert_notify
function Highlighter:insert_notify(line, n, ...)
  prev_insert_notify(self, line, n, ...)
  if not ws_cache[self] then
    ws_cache[self] = {}
  end
  local to = math.min(line + n, #self.doc.lines)
  for i=#self.doc.lines+n,to,-1 do
    ws_cache[self][i] = ws_cache[self][i - n]
  end
  for i=line,to do
    ws_cache[self][i] = nil
  end
end

-- Close the cache gap created by removed lines
local prev_remove_notify = Highlighter.remove_notify
function Highlighter:remove_notify(line, n, ...)
  prev_remove_notify(self, line, n, ...)
  if not ws_cache[self] then
    ws_cache[self] = {}
  end
  local to = math.max(line + n, #self.doc.lines)
  for i=line,to do
    ws_cache[self][i] = ws_cache[self][i + n]
  end
end

-- Remove changed lines from the cache
local prev_update_notify = Highlighter.update_notify
function Highlighter:update_notify(line, n, ...)
  prev_update_notify(self, line, n, ...)
  if not ws_cache[self] then
    ws_cache[self] = {}
  end
  for i=line,line+n do
    ws_cache[self][i] = nil
  end
end


local function get_option(substitution, option)
  if substitution[option] == nil then
    return config.plugins.drawwhitespace[option]
  end
  return substitution[option]
end

local draw_line_text = DocView.draw_line_text
function DocView:draw_line_text(idx, x, y)
  if
    not config.plugins.drawwhitespace.enabled
    or
    getmetatable(self) ~= DocView
  then
    return draw_line_text(self, idx, x, y)
  end

  local font = (self:get_font() or style.syntax_fonts["whitespace"] or style.syntax_fonts["comment"])
  local font_size = font:get_size()
  local _, indent_size = self.doc:get_indent_info()

  reset_cache_if_needed()
  if
    not ws_cache[self.doc.highlighter]
    or ws_cache[self.doc.highlighter].font ~= font
    or ws_cache[self.doc.highlighter].font_size ~= font_size
    or ws_cache[self.doc.highlighter].indent_size ~= indent_size
  then
    ws_cache[self.doc.highlighter] =
      setmetatable(
        { font = font, font_size = font_size, indent_size = indent_size },
        { __mode = "k" }
      )
  end

  if not ws_cache[self.doc.highlighter][idx] then -- need to cache line
    local cache = {}

    local tx
    local text = self.doc.lines[idx]

    for _, substitution in pairs(config.plugins.drawwhitespace.substitutions) do
      local char = substitution.char
      local sub = substitution.sub
      local offset = 1

      local show_leading = get_option(substitution, "show_leading")
      local show_middle = get_option(substitution, "show_middle")
      local show_trailing = get_option(substitution, "show_trailing")

      local show_middle_min = get_option(substitution, "show_middle_min")

      local base_color = get_option(substitution, "color")
      local leading_color = get_option(substitution, "leading_color") or base_color
      local middle_color = get_option(substitution, "middle_color") or base_color
      local trailing_color = get_option(substitution, "trailing_color") or base_color

      local pattern = char.."+"
      while true do
        local s, e = text:find(pattern, offset)
        if not s then break end

        tx = self:get_col_x_offset(idx, s)

        local color = base_color
        local draw = false

        if e >= #text - 1 then
          draw = show_trailing
          color = trailing_color
        elseif s == 1 then
          draw = show_leading
          color = leading_color
        else
          draw = show_middle and (e - s + 1 >= show_middle_min)
          color = middle_color
        end

        if draw then
          local last_cache_idx = #cache
          -- We need to draw tabs one at a time because they might have a
          -- different size than the substituting character.
          -- This also applies to any other char if we use non-monospace fonts
          -- but we ignore this case for now.
          if char == "\t" then
            for i = s,e do
              tx = self:get_col_x_offset(idx, i)
              cache[last_cache_idx + 1] = sub
              cache[last_cache_idx + 2] = tx
              cache[last_cache_idx + 3] = font:get_width(sub)
              cache[last_cache_idx + 4] = color
              last_cache_idx = last_cache_idx + 4
            end
          else
            cache[last_cache_idx + 1] = string.rep(sub, e - s + 1)
            cache[last_cache_idx + 2] = tx
            cache[last_cache_idx + 3] = font:get_width(cache[last_cache_idx + 1])
            cache[last_cache_idx + 4] = color
          end
        end
        offset = e + 1
      end
    end
    ws_cache[self.doc.highlighter][idx] = cache
  end

  -- draw from cache
  local x1, _, x2, _ = self:get_content_bounds()
  x1 = x1 + x
  x2 = x2 + x
  local ty = y + self:get_line_text_y_offset()
  local cache = ws_cache[self.doc.highlighter][idx]
  for i=1,#cache,4 do
    local tx = cache[i + 1] + x
    local tw = cache[i + 2]
    if tx <= x2 then
      local sub = cache[i]
      local color = cache[i + 3]
      if tx + tw >= x1 then
        tx = renderer.draw_text(font, sub, tx, ty, color)
      end
    end
  end

  return draw_line_text(self, idx, x, y)
end
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "C",
  files = { "%.c$" },
  comment = "//",
  block_comment = { "/*", "*/" },
  patterns = {
    { pattern = "//.*",                  type = "comment" },
    { pattern = { "/%*", "%*/" },        type = "comment" },
    { pattern = { '"', '"', '\\' },      type = "string"  },
    { pattern = { "'", "'", '\\' },      type = "string"  },
    { pattern = "0x%x+",                 type = "number"  },
    { pattern = "%d+[%d%.eE]*f?",        type = "number"  },
    { pattern = "%.?%d+f?",              type = "number"  },
    { pattern = "[%+%-=/%*%^%%<>!~|&]",  type = "operator" },
    { pattern = "##",                    type = "operator" },
    { pattern = "struct%s()[%a_][%w_]*", type = {"keyword", "keyword2"} },
    { pattern = "union%s()[%a_][%w_]*",  type = {"keyword", "keyword2"} },
    -- static declarations
    { pattern = "static()%s+()inline",
      type = { "keyword", "normal", "keyword" }
    },
    { pattern = "static()%s+()const",
      type = { "keyword", "normal", "keyword" }
    },
    { pattern = "static()%s+()[%a_][%w_]*",
      type = { "keyword", "normal", "literal" }
    },
    -- match function type declarations
    { pattern = "[%a_][%w_]*()%*+()%s+()[%a_][%w_]*%f[%(]",
      type = { "literal", "operator", "normal", "function" }
    },
    { pattern = "[%a_][%w_]*()%s+()%*+()[%a_][%w_]*%f[%(]",
      type = { "literal", "normal", "operator", "function" }
    },
    { pattern = "[%a_][%w_]*()%s+()[%a_][%w_]*%f[%(]",
      type = { "literal", "normal", "function" }
    },
    -- match variable type declarations
    { pattern = "[%a_][%w_]*()%*+()%s+()[%a_][%w_]*",
      type = { "literal", "operator", "normal", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()%*+()[%a_][%w_]*",
      type = { "literal", "normal", "operator", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()[%a_][%w_]*()%s*()[;,%[%)]",
      type = { "literal", "normal", "normal", "normal", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()[%a_][%w_]*()%s*()=",
      type = { "literal", "normal", "normal", "normal", "operator" }
    },
    { pattern = "[%a_][%w_]*()&()%s+()[%a_][%w_]*",
      type = { "literal", "operator", "normal", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()&()[%a_][%w_]*",
      type = { "literal", "normal", "operator", "normal" }
    },
    -- Uppercase constants of at least 2 chars in len
    { pattern = "_?%u[%u_][%u%d_]*%f[%s%+%*%-%.%)%]}%?%^%%=/<>~|&;:,!]",
      type = "number"
    },
    -- Magic constants
    { pattern = "__[%u%l]+__",           type = "number"   },
    -- all other functions
    { pattern = "[%a_][%w_]*%f[(]",      type = "function" },
    -- Macros
    { pattern = "^%s*#%s*define%s+()[%a_][%a%d_]*",
      type = { "keyword", "symbol" }
    },
    { pattern = "#%s*include%s()<.->",   type = {"keyword", "string"} },
    { pattern = "%f[#]#%s*[%a_][%w_]*",  type = "keyword"   },
    -- Everything else to make the tokenizer work properly
    { pattern = "[%a_][%w_]*",           type = "symbol" },
  },
  symbols = {
    ["if"]       = "keyword",
    ["then"]     = "keyword",
    ["else"]     = "keyword",
    ["elseif"]   = "keyword",
    ["do"]       = "keyword",
    ["while"]    = "keyword",
    ["for"]      = "keyword",
    ["break"]    = "keyword",
    ["continue"] = "keyword",
    ["return"]   = "keyword",
    ["goto"]     = "keyword",
    ["typedef"]  = "keyword",
    ["enum"]     = "keyword",
    ["extern"]   = "keyword",
    ["static"]   = "keyword",
    ["volatile"] = "keyword",
    ["const"]    = "keyword",
    ["inline"]   = "keyword",
    ["switch"]   = "keyword",
    ["case"]     = "keyword",
    ["default"]  = "keyword",
    ["auto"]     = "keyword",
    ["struct"]   = "keyword",
    ["union"]    = "keyword",
    ["void"]     = "keyword2",
    ["int"]      = "keyword2",
    ["short"]    = "keyword2",
    ["long"]     = "keyword2",
    ["float"]    = "keyword2",
    ["double"]   = "keyword2",
    ["char"]     = "keyword2",
    ["unsigned"] = "keyword2",
    ["bool"]     = "keyword2",
    ["true"]     = "literal",
    ["false"]    = "literal",
    ["NULL"]     = "literal",
    ["#include"] = "keyword",
    ["#if"] = "keyword",
    ["#ifdef"] = "keyword",
    ["#ifndef"] = "keyword",
    ["#elif"]    = "keyword",
    ["#else"] = "keyword",
    ["#elseif"] = "keyword",
    ["#endif"] = "keyword",
    ["#define"] = "keyword",
    ["#warning"] = "keyword",
    ["#error"] = "keyword",
    ["#pragma"] = "keyword",
  },
}

-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "C++",
  files = {
    "%.h$", "%.inl$", "%.cpp$", "%.cc$", "%.C$", "%.cxx$",
    "%.c++$", "%.hh$", "%.H$", "%.hxx$", "%.hpp$", "%.h++$"
  },
  comment = "//",
  block_comment = { "/*", "*/" },
  patterns = {
    { pattern = "//.*",                     type = "comment"  },
    { pattern = { "/%*", "%*/" },           type = "comment"  },
    { pattern = { '"', '"', '\\' },         type = "string"   },
    { pattern = { "'", "'", '\\' },         type = "string"   },
    { pattern = "0x%x+",                    type = "number"   },
    { pattern = "%d+[%d%.'eE]*f?",          type = "number"   },
    { pattern = "%.?%d+f?",                 type = "number"   },
    { pattern = "[%+%-=/%*%^%%<>!~|:&]",    type = "operator" },
    { pattern = "##",                       type = "operator" },
    { pattern = "struct%s()[%a_][%w_]*",    type = {"keyword", "keyword2"} },
    { pattern = "class%s()[%a_][%w_]*",     type = {"keyword", "keyword2"} },
    { pattern = "union%s()[%a_][%w_]*",     type = {"keyword", "keyword2"} },
    { pattern = "namespace%s()[%a_][%w_]*", type = {"keyword", "keyword2"} },
    -- static declarations
    { pattern = "static()%s+()inline",
      type = { "keyword", "normal", "keyword" }
    },
    { pattern = "static()%s+()const",
      type = { "keyword", "normal", "keyword" }
    },
    { pattern = "static()%s+()[%a_][%w_]*",
      type = { "keyword", "normal", "literal" }
    },
    -- match method type declarations
    { pattern = "[%a_][%w_]*()%s*()%**()%s*()[%a_][%w_]*()%s*()::",
      type = {
        "literal", "normal", "operator", "normal",
        "literal", "normal", "operator"
      }
    },
    -- match function type declarations
    { pattern = "[%a_][%w_]*()%*+()%s+()[%a_][%w_]*%f[%(]",
      type = { "literal", "operator", "normal", "function" }
    },
    { pattern = "[%a_][%w_]*()%s+()%*+()[%a_][%w_]*%f[%(]",
      type = { "literal", "normal", "operator", "function" }
    },
    { pattern = "[%a_][%w_]*()%s+()[%a_][%w_]*%f[%(]",
      type = { "literal", "normal", "function" }
    },
    -- match variable type declarations
    { pattern = "[%a_][%w_]*()%*+()%s+()[%a_][%w_]*",
      type = { "literal", "operator", "normal", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()%*+()[%a_][%w_]*",
      type = { "literal", "normal", "operator", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()[%a_][%w_]*()%s*()[;,%[%)]",
      type = { "literal", "normal", "normal", "normal", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()[%a_][%w_]*()%s*()=",
      type = { "literal", "normal", "normal", "normal", "operator" }
    },
    { pattern = "[%a_][%w_]*()&()%s+()[%a_][%w_]*",
      type = { "literal", "operator", "normal", "normal" }
    },
    { pattern = "[%a_][%w_]*()%s+()&()[%a_][%w_]*",
      type = { "literal", "normal", "operator", "normal" }
    },
    -- Match scope operator element access
    { pattern = "[%a_][%w_]*()%s*()::",
      type = { "literal", "normal", "operator" }
    },
    -- Uppercase constants of at least 2 chars in len
    { pattern = "_?%u[%u_][%u%d_]*%f[%s%+%*%-%.%)%]}%?%^%%=/<>~|&;:,!]",
      type = "number"
    },
    -- Magic constants
    { pattern = "__[%u%l]+__",              type = "number"   },
    -- all other functions
    { pattern = "[%a_][%w_]*%f[(]",         type = "function" },
    -- Macros
    { pattern = "^%s*#%s*define%s+()[%a_][%a%d_]*",
      type = { "keyword", "symbol" }
    },
    { pattern = "#%s*include%s+()<.->",
      type = { "keyword", "string" }
    },
    { pattern = "%f[#]#%s*[%a_][%w_]*",     type = "keyword"   },
    -- Everything else to make the tokenizer work properly
    { pattern = "[%a_][%w_]*",              type = "symbol"   },
  },
  symbols = {
    ["alignof"]  = "keyword",
    ["alignas"]  = "keyword",
    ["and"]      = "keyword",
    ["and_eq"]   = "keyword",
    ["not"]      = "keyword",
    ["not_eq"]   = "keyword",
    ["or"]       = "keyword",
    ["or_eq"]    = "keyword",
    ["xor"]      = "keyword",
    ["xor_eq"]   = "keyword",
    ["private"]  = "keyword",
    ["protected"] = "keyword",
    ["public"]   = "keyword",
    ["register"] = "keyword",
    ["nullptr"]  = "keyword",
    ["operator"] = "keyword",
    ["asm"]      = "keyword",
    ["bitand"]   = "keyword",
    ["bitor"]    = "keyword",
    ["catch"]    = "keyword",
    ["throw"]    = "keyword",
    ["try"]      = "keyword",
    ["class"]    = "keyword",
    ["compl"]    = "keyword",
    ["explicit"] = "keyword",
    ["export"]   = "keyword",
    ["concept"]  = "keyword",
    ["consteval"] = "keyword",
    ["constexpr"] = "keyword",
    ["constinit"] = "keyword",
    ["const_cast"] = "keyword",
    ["dynamic_cast"] = "keyword",
    ["reinterpret_cast"]   = "keyword",
    ["static_cast"]   = "keyword",
    ["static_assert"] = "keyword",
    ["template"]  = "keyword",
    ["this"]      = "keyword",
    ["thread_local"] = "keyword",
    ["requires"]  = "keyword",
    ["co_wait"]   = "keyword",
    ["co_return"] = "keyword",
    ["co_yield"]  = "keyword",
    ["decltype"] = "keyword",
    ["delete"]   = "keyword",
    ["friend"]   = "keyword",
    ["typeid"]   = "keyword",
    ["typename"] = "keyword",
    ["mutable"]  = "keyword",
    ["override"] = "keyword",
    ["virtual"]  = "keyword",
    ["using"]    = "keyword",
    ["namespace"] = "keyword",
    ["new"]      = "keyword",
    ["noexcept"] = "keyword",
    ["if"]       = "keyword",
    ["then"]     = "keyword",
    ["else"]     = "keyword",
    ["elseif"]   = "keyword",
    ["do"]       = "keyword",
    ["while"]    = "keyword",
    ["for"]      = "keyword",
    ["break"]    = "keyword",
    ["continue"] = "keyword",
    ["return"]   = "keyword",
    ["goto"]     = "keyword",
    ["struct"]   = "keyword",
    ["union"]    = "keyword",
    ["typedef"]  = "keyword",
    ["enum"]     = "keyword",
    ["extern"]   = "keyword",
    ["static"]   = "keyword",
    ["volatile"] = "keyword",
    ["const"]    = "keyword",
    ["inline"]   = "keyword",
    ["switch"]   = "keyword",
    ["case"]     = "keyword",
    ["default"]  = "keyword",
    ["auto"]     = "keyword",
    ["void"]     = "keyword2",
    ["int"]      = "keyword2",
    ["short"]    = "keyword2",
    ["long"]     = "keyword2",
    ["float"]    = "keyword2",
    ["double"]   = "keyword2",
    ["char"]     = "keyword2",
    ["unsigned"] = "keyword2",
    ["bool"]     = "keyword2",
    ["true"]     = "literal",
    ["false"]    = "literal",
    ["NULL"]     = "literal",
    ["wchar_t"]  = "keyword2",
    ["char8_t"]  = "keyword2",
    ["char16_t"] = "keyword2",
    ["char32_t"] = "keyword2",
    ["#include"] = "keyword",
    ["#if"]      = "keyword",
    ["#ifdef"]   = "keyword",
    ["#ifndef"]  = "keyword",
    ["#elif"]    = "keyword",
    ["#else"]    = "keyword",
    ["#elseif"]  = "keyword",
    ["#endif"]   = "keyword",
    ["#define"]  = "keyword",
    ["#warning"] = "keyword",
    ["#error"]   = "keyword",
    ["#pragma"]  = "keyword",
  },
}
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "CSS",
  files = { "%.css$" },
  block_comment = { "/*", "*/" },
  patterns = {
    { pattern = "\\.",                type = "normal"   },
    { pattern = "//.*",               type = "comment"  },
    { pattern = { "/%*", "%*/" },     type = "comment"  },
    { pattern = { '"', '"', '\\' },   type = "string"   },
    { pattern = { "'", "'", '\\' },   type = "string"   },
    { pattern = "[%a][%w-]*%s*%f[:]", type = "keyword"  },
    { pattern = "#%x%x%x%x%x%x%f[%W]",type = "string"   },
    { pattern = "#%x%x%x%f[%W]",      type = "string"   },
    { pattern = "-?%d+[%d%.]*p[xt]",  type = "number"   },
    { pattern = "-?%d+[%d%.]*deg",    type = "number"   },
    { pattern = "-?%d+[%d%.]*",       type = "number"   },
    { pattern = "[%a_][%w_]*",        type = "symbol"   },
    { pattern = "#[%a][%w_-]*",       type = "keyword2" },
    { pattern = "@[%a][%w_-]*",       type = "keyword2" },
    { pattern = "%.[%a][%w_-]*",      type = "keyword2" },
    { pattern = "[{}:]",              type = "operator" },
  },
  symbols = {},
}
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "HTML",
  files = { "%.html?$" },
  block_comment = { "<!--", "-->" },
  patterns = {
    {
      pattern = {
        "<%s*[sS][cC][rR][iI][pP][tT]%f[%s>].->",
        "<%s*/%s*[sS][cC][rR][iI][pP][tT]%s*>"
      },
      syntax = ".js",
      type = "function"
    },
    {
      pattern = {
        "<%s*[sS][tT][yY][lL][eE]%f[%s>].->",
        "<%s*/%s*[sS][tT][yY][lL][eE]%s*>"
      },
      syntax = ".css",
      type = "function"
    },
    { pattern = { "<!%-%-", "%-%->" },     type = "comment"  },
    { pattern = { '%f[^>][^<]', '%f[<]' }, type = "normal"   },
    { pattern = { '"', '"', '\\' },        type = "string"   },
    { pattern = { "'", "'", '\\' },        type = "string"   },
    { pattern = "0x[%da-fA-F]+",           type = "number"   },
    { pattern = "-?%d+[%d%.]*f?",          type = "number"   },
    { pattern = "-?%.?%d+f?",              type = "number"   },
    { pattern = "%f[^<]![%a_][%w_]*",      type = "keyword2" },
    { pattern = "%f[^<][%a_][%w_]*",       type = "function" },
    { pattern = "%f[^<]/[%a_][%w_]*",      type = "function" },
    { pattern = "[%a_][%w_]*",             type = "keyword"  },
    { pattern = "[/<>=]",                  type = "operator" },
  },
  symbols = {},
}
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "JavaScript",
  files = { "%.js$", "%.json$", "%.cson$", "%.mjs$", "%.cjs$" },
  comment = "//",
  block_comment = { "/*", "*/" },
  patterns = {
    { pattern = "//.*",                 type = "comment"  },
    { pattern = { "/%*", "%*/" },       type = "comment"  },
    { pattern = { '/[^= ]', '/', '\\' },type = "string"   },
    { pattern = { '"', '"', '\\' },     type = "string"   },
    { pattern = { "'", "'", '\\' },     type = "string"   },
    { pattern = { "`", "`", '\\' },     type = "string"   },
    { pattern = "0x[%da-fA-F_]+n?",     type = "number"   },
    { pattern = "-?%d+[%d%.eE_n]*",     type = "number"   },
    { pattern = "-?%.?%d+",             type = "number"   },
    { pattern = "[%+%-=/%*%^%%<>!~|&]", type = "operator" },
    { pattern = "[%a_][%w_]*%f[(]",     type = "function" },
    { pattern = "[%a_][%w_]*",          type = "symbol"   },
  },
  symbols = {
    ["async"]      = "keyword",
    ["await"]      = "keyword",
    ["break"]      = "keyword",
    ["case"]       = "keyword",
    ["catch"]      = "keyword",
    ["class"]      = "keyword",
    ["const"]      = "keyword",
    ["continue"]   = "keyword",
    ["debugger"]   = "keyword",
    ["default"]    = "keyword",
    ["delete"]     = "keyword",
    ["do"]         = "keyword",
    ["else"]       = "keyword",
    ["export"]     = "keyword",
    ["extends"]    = "keyword",
    ["finally"]    = "keyword",
    ["for"]        = "keyword",
    ["function"]   = "keyword",
    ["get"]        = "keyword",
    ["if"]         = "keyword",
    ["import"]     = "keyword",
    ["in"]         = "keyword",
    ["of"]         = "keyword",
    ["instanceof"] = "keyword",
    ["let"]        = "keyword",
    ["new"]        = "keyword",
    ["return"]     = "keyword",
    ["set"]        = "keyword",
    ["static"]     = "keyword",
    ["super"]      = "keyword",
    ["switch"]     = "keyword",
    ["throw"]      = "keyword",
    ["try"]        = "keyword",
    ["typeof"]     = "keyword",
    ["var"]        = "keyword",
    ["void"]       = "keyword",
    ["while"]      = "keyword",
    ["with"]       = "keyword",
    ["yield"]      = "keyword",
    ["true"]       = "literal",
    ["false"]      = "literal",
    ["null"]       = "literal",
    ["undefined"]  = "literal",
    ["arguments"]  = "keyword2",
    ["Infinity"]   = "keyword2",
    ["NaN"]        = "keyword2",
    ["this"]       = "keyword2",
  },
}
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "Lua",
  files = "%.lua$",
  headers = "^#!.*[ /]lua",
  comment = "--",
  block_comment = { "--[[", "]]" },
  patterns = {
    { pattern = { '"', '"', '\\' },          type = "string" },
    { pattern = { "'", "'", '\\' },          type = "string" },
    { pattern = { "%[%[", "%]%]" },          type = "string" },
    { pattern = { "%-%-%[%[", "%]%]"},       type = "comment" },
    { pattern = "%-%-.*",                    type = "comment" },
    { pattern = "0x%x+%.%x*[pP][-+]?%d+",    type = "number" },
    { pattern = "0x%x+%.%x*",                type = "number" },
    { pattern = "0x%.%x+[pP][-+]?%d+",       type = "number" },
    { pattern = "0x%.%x+",                   type = "number" },
    { pattern = "0x%x+[pP][-+]?%d+",         type = "number" },
    { pattern = "0x%x+",                     type = "number" },
    { pattern = "%d%.%d*[eE][-+]?%d+",       type = "number" },
    { pattern = "%d%.%d*",                   type = "number" },
    { pattern = "%.?%d*[eE][-+]?%d+",        type = "number" },
    { pattern = "%.?%d+",                    type = "number" },
    { pattern = "<%a+>",                     type = "keyword2" },
    { pattern = "%.%.%.?",                   type = "operator" },
    { pattern = "[<>~=]=",                   type = "operator" },
    { pattern = "[%+%-=/%*%^%%#<>]",         type = "operator" },
    { pattern = "[%a_][%w_]*()%s*%f[(\"'{]", type = {"function", "normal"} },
    { pattern = "[%a_][%w_]*",               type = "symbol" },
    { pattern = "::[%a_][%w_]*::",           type = "function" },
  },
  symbols = {
    ["if"]       = "keyword",
    ["then"]     = "keyword",
    ["else"]     = "keyword",
    ["elseif"]   = "keyword",
    ["end"]      = "keyword",
    ["do"]       = "keyword",
    ["function"] = "keyword",
    ["repeat"]   = "keyword",
    ["until"]    = "keyword",
    ["while"]    = "keyword",
    ["for"]      = "keyword",
    ["break"]    = "keyword",
    ["return"]   = "keyword",
    ["local"]    = "keyword",
    ["in"]       = "keyword",
    ["not"]      = "keyword",
    ["and"]      = "keyword",
    ["or"]       = "keyword",
    ["goto"]     = "keyword",
    ["self"]     = "keyword2",
    ["true"]     = "literal",
    ["false"]    = "literal",
    ["nil"]      = "literal",
  },
}

-- mod-version:3
local syntax = require "core.syntax"
local style = require "core.style"
local core = require "core"

local initial_color = style.syntax["keyword2"]

-- Add 3 type of font styles for use on markdown files
for _, attr in pairs({"bold", "italic", "bold_italic"}) do
  local attributes = {}
  if attr ~= "bold_italic" then
    attributes[attr] = true
  else
    attributes["bold"] = true
    attributes["italic"] = true
  end
  style.syntax_fonts["markdown_"..attr] = style.code_font:copy(
    style.code_font:get_size(),
    attributes
  )
  -- also add a color for it
  style.syntax["markdown_"..attr] = style.syntax["keyword2"]
end

local in_squares_match = "^%[%]"
local in_parenthesis_match = "^%(%)"

syntax.add {
  name = "Markdown",
  files = { "%.md$", "%.markdown$" },
  block_comment = { "<!--", "-->" },
  space_handling = false, -- turn off this feature to handle it our selfs
  patterns = {
  ---- Place patterns that require spaces at start to optimize matching speed
  ---- and apply the %s+ optimization immediately afterwards
    -- bullets
    { pattern = "^%s*%*%s",                 type = "number" },
    { pattern = "^%s*%-%s",                 type = "number" },
    { pattern = "^%s*%+%s",                 type = "number" },
    -- numbered bullet
    { pattern = "^%s*[0-9]+[%.%)]%s",       type = "number" },
    -- blockquote
    { pattern = "^%s*>+%s",                 type = "string" },
    -- alternative bold italic formats
    { pattern = { "%s___", "___" },         type = "markdown_bold_italic" },
    { pattern = { "%s__", "__" },           type = "markdown_bold" },
    { pattern = { "%s_[%S]", "_" },         type = "markdown_italic" },
    -- reference links
    {
      pattern = "^%s*%[%^()["..in_squares_match.."]+()%]: ",
      type = { "function", "number", "function" }
    },
    {
      pattern = "^%s*%[%^?()["..in_squares_match.."]+()%]:%s+.*",
      type = { "function", "number", "function" }
    },
    -- optimization
    { pattern = "%s+",                      type = "normal" },

  ---- HTML rules imported and adapted from language_html
  ---- to not conflict with markdown rules
    -- Inline JS and CSS
    {
      pattern = {
      "<%s*[sS][cC][rR][iI][pP][tT]%s+[tT][yY][pP][eE]%s*=%s*" ..
        "['\"]%a+/[jJ][aA][vV][aA][sS][cC][rR][iI][pP][tT]['\"]%s*>",
      "<%s*/[sS][cC][rR][iI][pP][tT]>"
      },
      syntax = ".js",
      type = "function"
    },
    {
      pattern = {
      "<%s*[sS][cC][rR][iI][pP][tT]%s*>",
      "<%s*/%s*[sS][cC][rR][iI][pP][tT]>"
      },
      syntax = ".js",
      type = "function"
    },
    {
      pattern = {
      "<%s*[sS][tT][yY][lL][eE][^>]*>",
      "<%s*/%s*[sS][tT][yY][lL][eE]%s*>"
      },
      syntax = ".css",
      type = "function"
    },
    -- Comments
    { pattern = { "<!%-%-", "%-%->" },   type = "comment" },
    -- Tags
    { pattern = "%f[^<]![%a_][%w_]*",    type = "keyword2" },
    { pattern = "%f[^<][%a_][%w_]*",     type = "function" },
    { pattern = "%f[^<]/[%a_][%w_]*",    type = "function" },
    -- Attributes
    {
      pattern = "[a-z%-]+%s*()=%s*()\".-\"",
      type = { "keyword", "operator", "string" }
    },
    {
      pattern = "[a-z%-]+%s*()=%s*()'.-'",
      type = { "keyword", "operator", "string" }
    },
    {
      pattern = "[a-z%-]+%s*()=%s*()%-?%d[%d%.]*",
      type = { "keyword", "operator", "number" }
    },
    -- Entities
    { pattern = "&#?[a-zA-Z0-9]+;",         type = "keyword2" },

  ---- Markdown rules
    -- math
    { pattern = { "%$%$", "%$%$", "\\"  },  type = "string", syntax = ".tex"},
    { regex   = { "\\$", [[\$|(?=\\*\n)]], "\\" },  type = "string", syntax = ".tex"},
    -- code blocks
    { pattern = { "```caddyfile", "```" },  type = "string", syntax = "Caddyfile" },
    { pattern = { "```c++", "```" },        type = "string", syntax = ".cpp" },
    { pattern = { "```cpp", "```" },        type = "string", syntax = ".cpp" },
    { pattern = { "```python", "```" },     type = "string", syntax = ".py" },
    { pattern = { "```ruby", "```" },       type = "string", syntax = ".rb" },
    { pattern = { "```perl", "```" },       type = "string", syntax = ".pl" },
    { pattern = { "```php", "```" },        type = "string", syntax = ".php" },
    { pattern = { "```javascript", "```" }, type = "string", syntax = ".js" },
    { pattern = { "```json", "```" },       type = "string", syntax = ".js" },
    { pattern = { "```html", "```" },       type = "string", syntax = ".html" },
    { pattern = { "```ini", "```" },        type = "string", syntax = ".ini" },
    { pattern = { "```xml", "```" },        type = "string", syntax = ".xml" },
    { pattern = { "```css", "```" },        type = "string", syntax = ".css" },
    { pattern = { "```lua", "```" },        type = "string", syntax = ".lua" },
    { pattern = { "```bash", "```" },       type = "string", syntax = ".sh" },
    { pattern = { "```sh", "```" },         type = "string", syntax = ".sh" },
    { pattern = { "```java", "```" },       type = "string", syntax = ".java" },
    { pattern = { "```c#", "```" },         type = "string", syntax = ".cs" },
    { pattern = { "```cmake", "```" },      type = "string", syntax = ".cmake" },
    { pattern = { "```d", "```" },          type = "string", syntax = ".d" },
    { pattern = { "```glsl", "```" },       type = "string", syntax = ".glsl" },
    { pattern = { "```c", "```" },          type = "string", syntax = ".c" },
    { pattern = { "```julia", "```" },      type = "string", syntax = ".jl" },
    { pattern = { "```rust", "```" },       type = "string", syntax = ".rs" },
    { pattern = { "```dart", "```" },       type = "string", syntax = ".dart" },
    { pattern = { "```v", "```" },          type = "string", syntax = ".v" },
    { pattern = { "```toml", "```" },       type = "string", syntax = ".toml" },
    { pattern = { "```yaml", "```" },       type = "string", syntax = ".yaml" },
    { pattern = { "```nim", "```" },        type = "string", syntax = ".nim" },
    { pattern = { "```typescript", "```" }, type = "string", syntax = ".ts" },
    { pattern = { "```rescript", "```" },   type = "string", syntax = ".res" },
    { pattern = { "```moon", "```" },       type = "string", syntax = ".moon" },
    { pattern = { "```go", "```" },         type = "string", syntax = ".go" },
    { pattern = { "```lobster", "```" },    type = "string", syntax = ".lobster" },
    { pattern = { "```liquid", "```" },     type = "string", syntax = ".liquid" },
    { pattern = { "```", "```" },           type = "string" },
    { pattern = { "``", "``" },             type = "string" },
    { pattern = { "%f[\\`]%`[%S]", "`" },   type = "string" },
    -- lines
    { pattern = "^%-%-%-+\n" ,              type = "comment" },
    { pattern = "^%*%*%*+\n",               type = "comment" },
    { pattern = "^___+\n",                  type = "comment" },
    { pattern = "^===+\n",                  type = "comment" },
    -- strike
    { pattern = { "~~", "~~" },             type = "keyword2" },
    -- highlight
    { pattern = { "==", "==" },             type = "literal" },
    -- bold and italic
    { pattern = { "%*%*%*%S", "%*%*%*" },   type = "markdown_bold_italic" },
    { pattern = { "%*%*%S", "%*%*" },       type = "markdown_bold" },
    -- handle edge case where asterisk can be at end of line and not close
    {
      pattern = { "%f[\\%*]%*[%S]", "%*%f[^%*]" },
      type = "markdown_italic"
    },
    -- alternative bold italic formats
    { pattern = "^___[%s%p%w]+___" ,        type = "markdown_bold_italic" },
    { pattern = "^__[%s%p%w]+__" ,          type = "markdown_bold" },
    { pattern = "^_[%s%p%w]+_" ,            type = "markdown_italic" },
    -- heading with custom id
    {
      pattern = "^#+%s[%w%s%p]+(){()#[%w%-]+()}",
      type = { "keyword", "function", "string", "function" }
    },
    -- headings
    { pattern = "^#+%s.+\n",                type = "keyword" },
    -- superscript and subscript
    {
      pattern = "%^()%d+()%^",
      type = { "function", "number", "function" }
    },
    {
      pattern = "%~()%d+()%~",
      type = { "function", "number", "function" }
    },
    -- definitions
    { pattern = "^:%s.+",                   type = "function" },
    -- emoji
    { pattern = ":[a-zA-Z0-9_%-]+:",        type = "literal" },
    -- images and link
    {
      pattern = "!?%[!?%[()["..in_squares_match.."]+()%]%(()["..in_parenthesis_match.."]+()%)%]%(()["..in_parenthesis_match.."]+()%)",
      type = { "function", "string", "function", "number", "function", "number", "function" }
    },
    {
      pattern = "!?%[!?%[?()["..in_squares_match.."]+()%]?%]%(()["..in_parenthesis_match.."]+()%)",
      type = { "function", "string", "function", "number", "function" }
    },
    -- reference links
    {
      pattern = "%[()["..in_squares_match.."]+()%] *()%[()["..in_squares_match.."]+()%]",
      type = { "function", "string", "function", "function", "number", "function" }
    },
    {
      pattern = "!?%[%^?()["..in_squares_match.."]+()%]",
      type = { "function", "number", "function" }
    },
    -- url's and email
    {
      pattern = "<[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+%.[a-zA-Z0-9-.]+>",
      type = "function"
    },
    { pattern = "<https?://%S+>",           type = "function" },
    { pattern = "https?://%S+",             type = "function" },
    -- optimize consecutive dashes used in tables
    { pattern = "%-+",                      type = "normal" },
  },
  symbols = { },
}

-- Adjust the color on theme changes
core.add_thread(function()
  while true do
    if initial_color ~= style.syntax["keyword2"] then
      for _, attr in pairs({"bold", "italic", "bold_italic"}) do
        style.syntax["markdown_"..attr] = style.syntax["keyword2"]
      end
      initial_color = style.syntax["keyword2"]
    end
    coroutine.yield(1)
  end
end)
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "Python",
  files = { "%.py$", "%.pyw$", "%.rpy$" },
  headers = "^#!.*[ /]python",
  comment = "#",
  block_comment = { '"""', '"""' },
  patterns = {
    { pattern = "#.*",                         type = "comment"  },
    { pattern = { '^%s*"""', '"""' },          type = "comment"  },
    { pattern = '[uUrR]%f["]',                 type = "keyword"  },
    { pattern = "class%s+()[%a_][%w_]*",       type = {"keyword", "keyword2"} },
    { pattern = { '[ruU]?"""', '"""'; '\\' },  type = "string"   },
    { pattern = { "[ruU]?'''", "'''", '\\' },  type = "string"   },
    { pattern = { '[ruU]?"', '"', '\\' },      type = "string"   },
    { pattern = { "[ruU]?'", "'", '\\' },      type = "string"   },
    { pattern = "0x[%da-fA-F]+",               type = "number"   },
    { pattern = "-?%d+[%d%.eE]*",              type = "number"   },
    { pattern = "-?%.?%d+",                    type = "number"   },
    { pattern = "[%+%-=/%*%^%%<>!~|&]",        type = "operator" },
    { pattern = "[%a_][%w_]*%f[(]",            type = "function" },
    { pattern = "[%a_][%w_]*",                 type = "symbol"   },
  },
  symbols = {
    ["class"]    = "keyword",
    ["finally"]  = "keyword",
    ["is"]       = "keyword",
    ["return"]   = "keyword",
    ["continue"] = "keyword",
    ["for"]      = "keyword",
    ["lambda"]   = "keyword",
    ["try"]      = "keyword",
    ["def"]      = "keyword",
    ["async"]    = "keyword",
    ["await"]    = "keyword",
    ["from"]     = "keyword",
    ["nonlocal"] = "keyword",
    ["while"]    = "keyword",
    ["and"]      = "keyword",
    ["global"]   = "keyword",
    ["not"]      = "keyword",
    ["with"]     = "keyword",
    ["as"]       = "keyword",
    ["elif"]     = "keyword",
    ["if"]       = "keyword",
    ["or"]       = "keyword",
    ["else"]     = "keyword",
    ["match"]    = "keyword",
    ["case"]     = "keyword",
    ["import"]   = "keyword",
    ["pass"]     = "keyword",
    ["break"]    = "keyword",
    ["except"]   = "keyword",
    ["in"]       = "keyword",
    ["del"]      = "keyword",
    ["raise"]    = "keyword",
    ["yield"]    = "keyword",
    ["assert"]   = "keyword",
    ["self"]     = "keyword2",
    ["None"]     = "literal",
    ["True"]     = "literal",
    ["False"]    = "literal",
  }
}
-- mod-version:3
local syntax = require "core.syntax"

syntax.add {
  name = "XML",
  files = { "%.xml$" },
  headers = "<%?xml",
  block_comment = { "<!--", "-->" },
  patterns = {
    { pattern = { "<!%-%-", "%-%->" },     type = "comment"  },
    { pattern = { '%f[^>][^<]', '%f[<]' }, type = "normal"   },
    { pattern = { '"', '"', '\\' },        type = "string"   },
    { pattern = { "'", "'", '\\' },        type = "string"   },
    { pattern = "0x[%da-fA-F]+",           type = "number"   },
    { pattern = "-?%d+[%d%.]*f?",          type = "number"   },
    { pattern = "-?%.?%d+f?",              type = "number"   },
    { pattern = "%f[^<]![%a_][%w_]*",      type = "keyword2" },
    { pattern = "%f[^<][%a_][%w_]*",       type = "function" },
    { pattern = "%f[^<]/[%a_][%w_]*",      type = "function" },
    { pattern = "[%a_][%w_]*",             type = "keyword"  },
    { pattern = "[/<>=]",                  type = "operator" },
  },
  symbols = {},
}
-- mod-version:3
local common = require "core.common"
local command = require "core.command"
local config = require "core.config"
local style = require "core.style"
local DocView = require "core.docview"
local CommandView = require "core.commandview"

config.plugins.lineguide = common.merge({
  enabled = false,
  width = 2,
  rulers = {
    -- 80,
    -- 100,
    -- 120,
    config.line_limit
  },
  -- The config specification used by gui generators
  config_spec = {
    name = "Line Guide",
    {
      label = "Enabled",
      description = "Disable or enable drawing of the line guide.",
      path = "enabled",
      type = "toggle",
      default = true
    },
    {
      label = "Width",
      description = "Width in pixels of the line guide.",
      path = "width",
      type = "number",
      default = 2,
      min = 1
    },
    {
      label = "Ruler Positions",
      description = "The different column numbers for the line guides to draw.",
      path = "rulers",
      type = "list_strings",
      default = { tostring(config.line_limit) or "80" },
      get_value = function(rulers)
        if type(rulers) == "table" then
          local new_rulers = {}
          for _, ruler in ipairs(rulers) do
            table.insert(new_rulers, tostring(ruler))
          end
          return new_rulers
        else
          return { tostring(config.line_limit) }
        end
      end,
      set_value = function(rulers)
        local new_rulers = {}
        for _, ruler in ipairs(rulers) do
          local number = tonumber(ruler)
          if number then
            table.insert(new_rulers, number)
          end
        end
        if #new_rulers == 0 then
          table.insert(new_rulers, config.line_limit)
        end
        return new_rulers
      end
    }
  }
}, config.plugins.lineguide)

local function get_ruler(v)
  local result = nil
  if type(v) == 'number' then
    result = { columns = v }
  elseif type(v) == 'table' then
    result = v
  end
  return result
end

local draw_overlay = DocView.draw_overlay
function DocView:draw_overlay(...)
  draw_overlay(self, ...)

  if
    type(config.plugins.lineguide) == "table"
    and
    config.plugins.lineguide.enabled
    and
    self:is(DocView)
  then
    local line_x = self:get_line_screen_position(1)
    local character_width = self:get_font():get_width("n")
    local ruler_width = config.plugins.lineguide.width
    local ruler_color = style.guide or style.selection

    for k,v in ipairs(config.plugins.lineguide.rulers) do
      local ruler = get_ruler(v)

      if ruler then
        local x = line_x + (character_width * ruler.columns)
        local y = self.position.y
        local w = ruler_width
        local h = self.size.y

        renderer.draw_rect(x, y, w, h, ruler.color or ruler_color)
      end
    end
  end
end

command.add(nil, {
  ["lineguide:toggle"] = function()
    config.plugins.lineguide.enabled = not config.plugins.lineguide.enabled
  end
})
-- mod-version:3 --priority:10
local core = require "core"
local common = require "core.common"
local DocView = require "core.docview"
local Doc = require "core.doc"
local style = require "core.style"
local config = require "core.config"
local command = require "core.command"
local keymap = require "core.keymap"
local translate = require "core.doc.translate"


config.plugins.linewrapping = common.merge({
	-- The type of wrapping to perform. Can be "letter" or "word".
  mode = "letter",
	-- If nil, uses the DocView's size, otherwise, uses this exact width. Can be a function.
  width_override = nil,
	-- Whether or not to draw a guide
  guide = true,
  -- Whether or not we should indent ourselves like the first line of a wrapped block.
  indent = true,
  -- Whether or not to enable wrapping by default when opening files.
  enable_by_default = false,
  -- Requires tokenization
  require_tokenization = false,
  -- The config specification used by gui generators
  config_spec = {
    name = "Line Wrapping",
    {
      label = "Mode",
      description = "The type of wrapping to perform.",
      path = "mode",
      type = "selection",
      default = "letter",
      values = {
        {"Letters", "letter"},
        {"Words", "word"}
      }
    },
    {
      label = "Guide",
      description = "Whether or not to draw a guide.",
      path = "guide",
      type = "toggle",
      default = true
    },
    {
      label = "Indent",
      description = "Whether or not to follow the indentation of wrapped line.",
      path = "indent",
      type = "toggle",
      default = true
    },
    {
      label = "Enable by Default",
      description = "Whether or not to enable wrapping by default when opening files.",
      path = "enable_by_default",
      type = "toggle",
      default = false
    },
    {
      label = "Require Tokenization",
      description = "Use tokenization when applying wrapping.",
      path = "require_tokenization",
      type = "toggle",
      default = false
    }
  }
}, config.plugins.linewrapping)

local LineWrapping = {}

-- Optimzation function. The tokenizer is relatively slow (at present), and
-- so if we don't need to run it, should be run sparingly.
local function spew_tokens(doc, line) if line < math.huge then return math.huge, "normal", doc.lines[line] end end
local function get_tokens(doc, line)
  if config.plugins.linewrapping.require_tokenization then
    return doc.highlighter:each_token(line)
  end
  return spew_tokens, doc, line
end

-- Computes the breaks for a given line, width and mode. Returns a list of columns
-- at which the line should be broken.
function LineWrapping.compute_line_breaks(doc, default_font, line, width, mode)
  local xoffset, last_i, i, last_space, last_width, begin_width = 0, 1, 1, nil, 0, 0
  local splits = { 1 }
  for idx, type, text in get_tokens(doc, line) do
    local font = style.syntax_fonts[type] or default_font
    if idx == 1 or idx == math.huge and config.plugins.linewrapping.indent then
      local _, indent_end = text:find("^%s+")
      if indent_end then begin_width = font:get_width(text:sub(1, indent_end)) end
    end
    local w = font:get_width(text)
    if xoffset + w > width then
      for char in common.utf8_chars(text) do
        w = font:get_width(char)
        xoffset = xoffset + w
        if xoffset > width then
          if mode == "word" and last_space then
            table.insert(splits, last_space + 1)
            xoffset = w + begin_width + (xoffset - last_width)
          else
            table.insert(splits, i)
            xoffset = w + begin_width
          end
          last_space = nil
        elseif char == ' ' then
          last_space = i
          last_width = xoffset
        end
        i = i + #char
      end
    else
      xoffset = xoffset + w
      i = i + #text
    end
  end
  return splits, begin_width
end

-- breaks are held in a single table that contains n*2 elements, where n is the amount of line breaks.
-- each element represents line and column of the break. line_offset will check from the specified line
-- if the first line has not changed breaks, it will stop there.
function LineWrapping.reconstruct_breaks(docview, default_font, width, line_offset)
  if width ~= math.huge then
    local doc = docview.doc
    -- two elements per wrapped line; first maps to original line number, second to column number.
    docview.wrapped_lines = { }
    -- one element per actual line; maps to the first index of in wrapped_lines for this line
    docview.wrapped_line_to_idx = { }
    -- one element per actual line; gives the indent width for the acutal line
    docview.wrapped_line_offsets = { }
    docview.wrapped_settings = { ["width"] = width, ["font"] = default_font }
    for i = line_offset or 1, #doc.lines do
      local breaks, offset = LineWrapping.compute_line_breaks(doc, default_font, i, width, config.plugins.linewrapping.mode)
      table.insert(docview.wrapped_line_offsets, offset)
      for k, col in ipairs(breaks) do
        table.insert(docview.wrapped_lines, i)
        table.insert(docview.wrapped_lines, col)
      end
    end
    -- list of indices for wrapped_lines, that are based on original line number
    -- holds the index to the first in the wrapped_lines list.
    local last_wrap = nil
    for i = 1, #docview.wrapped_lines, 2 do
      if not last_wrap or last_wrap ~= docview.wrapped_lines[i] then
        table.insert(docview.wrapped_line_to_idx, (i + 1) / 2)
        last_wrap = docview.wrapped_lines[i]
      end
    end
  else
    docview.wrapped_lines = nil
    docview.wrapped_line_to_idx = nil
    docview.wrapped_line_offsets = nil
    docview.wrapped_settings = nil
  end
end

-- When we have an insertion or deletion, we have four sections of text.
-- 1. The unaffected section, located prior to the cursor. This is completely ignored.
-- 2. The beginning of the affected line prior to the insertion or deletion. Begins on column 1 of the selection.
-- 3. The removed/pasted lines.
-- 4. Every line after the modification, begins one line after the selection in the initial document.
function LineWrapping.update_breaks(docview, old_line1, old_line2, net_lines)
  -- Step 1: Determine the index for the line for #2.
  local old_idx1 = docview.wrapped_line_to_idx[old_line1] or 1
  -- Step 2: Determine the index of the line for #4.
  local old_idx2 = (docview.wrapped_line_to_idx[old_line2 + 1] or ((#docview.wrapped_lines / 2) + 1)) - 1
  -- Step 3: Remove all old breaks for the old lines from the table, and all old widths from wrapped_line_offsets.
  local offset = (old_idx1  - 1) * 2 + 1
  for i = old_idx1, old_idx2 do
    table.remove(docview.wrapped_lines, offset)
    table.remove(docview.wrapped_lines, offset)
  end
  for i = old_line1, old_line2 do
    table.remove(docview.wrapped_line_offsets, old_line1)
  end
  -- Step 4: Shift the line number of wrapped_lines past #4 by the amount of inserted/deleted lines.
  if net_lines ~= 0 then
    for i = offset, #docview.wrapped_lines, 2 do
      docview.wrapped_lines[i] = docview.wrapped_lines[i] + net_lines
    end
  end
  -- Step 5: Compute the breaks and offsets for the lines for #2 and #3. Insert them into the table.
  local new_line1 = old_line1
  local new_line2 = old_line2 + net_lines
  for line = new_line1, new_line2 do
    local breaks, begin_width = LineWrapping.compute_line_breaks(docview.doc, docview.wrapped_settings.font, line, docview.wrapped_settings.width, config.plugins.linewrapping.mode)
    table.insert(docview.wrapped_line_offsets, line, begin_width)
    for i,b in ipairs(breaks) do
      table.insert(docview.wrapped_lines, offset, b)
      table.insert(docview.wrapped_lines, offset, line)
      offset = offset + 2
    end
  end
  -- Step 6: Recompute the wrapped_line_to_idx cache from #2.
  local line = old_line1
  offset = (old_idx1  - 1) * 2 + 1
  while offset < #docview.wrapped_lines do
    if docview.wrapped_lines[offset + 1] == 1 then
      docview.wrapped_line_to_idx[line] = ((offset - 1) / 2) + 1
      line = line + 1
    end
    offset = offset + 2
  end
  while line <= #docview.wrapped_line_to_idx do
    table.remove(docview.wrapped_line_to_idx)
  end
end

-- Draws a guide if applicable to show where wrapping is occurring.
function LineWrapping.draw_guide(docview)
  if config.plugins.linewrapping.guide and docview.wrapped_settings.width ~= math.huge then
    local x, y = docview:get_content_offset()
    local gw = docview:get_gutter_width()
    renderer.draw_rect(x + gw + docview.wrapped_settings.width, y, 1, core.root_view.size.y, style.selection)
  end
end

function LineWrapping.update_docview_breaks(docview)
  local x,y,w,h = docview.v_scrollbar:get_thumb_rect()
  local width = (type(config.plugins.linewrapping.width_override) == "function" and config.plugins.linewrapping.width_override(docview))
    or config.plugins.linewrapping.width_override or (docview.size.x - docview:get_gutter_width() - w)
  if (not docview.wrapped_settings or docview.wrapped_settings.width == nil or width ~= docview.wrapped_settings.width) then
    docview.scroll.to.x = 0
    LineWrapping.reconstruct_breaks(docview, docview:get_font(), width)
  end
end

local function get_idx_line_col(docview, idx)
  local doc = docview.doc
  if not docview.wrapped_settings then
    if idx > #doc.lines then return #doc.lines, #doc.lines[#doc.lines] + 1 end
    return idx, 1
  end
  if idx < 1 then return 1, 1 end
  local offset = (idx - 1) * 2 + 1
  if offset > #docview.wrapped_lines then return #doc.lines, #doc.lines[#doc.lines] + 1 end
  return docview.wrapped_lines[offset], docview.wrapped_lines[offset + 1]
end

local function get_idx_line_length(docview, idx)
  local doc = docview.doc
  if not docview.wrapped_settings then
    if idx > #doc.lines then return #doc.lines[#doc.lines] + 1 end
    return #doc.lines[idx]
  end
  local offset = (idx - 1) * 2 + 1
  local start = docview.wrapped_lines[offset + 1]
  if docview.wrapped_lines[offset + 2] and docview.wrapped_lines[offset + 2] == docview.wrapped_lines[offset] then
    return docview.wrapped_lines[offset + 3] - docview.wrapped_lines[offset + 1]
  else
    return #doc.lines[docview.wrapped_lines[offset]] - docview.wrapped_lines[offset + 1] + 1
  end
end

local function get_total_wrapped_lines(docview)
  if not docview.wrapped_settings then return docview.doc and #docview.doc.lines end
  return #docview.wrapped_lines / 2
end

-- If line end, gives the end of an index line, rather than the first character of the next line.
local function get_line_idx_col_count(docview, line, col, line_end, ndoc)
  local doc = docview.doc
  if not docview.wrapped_settings then return common.clamp(line, 1, #doc.lines), col, 1, 1 end
  if line > #doc.lines then return get_line_idx_col_count(docview, #doc.lines, #doc.lines[#doc.lines] + 1) end
  line = math.max(line, 1)
  local idx = docview.wrapped_line_to_idx[line] or 1
  local ncol, scol = 1, 1
  if col then
    local i = idx + 1
    while line == docview.wrapped_lines[(i - 1) * 2 + 1] and col >= docview.wrapped_lines[(i - 1) * 2 + 2] do
      local nscol = docview.wrapped_lines[(i - 1) * 2 + 2]
      if line_end and col == nscol then
        break
      end
      scol = nscol
      i = i + 1
      idx = idx + 1
    end
    ncol = (col - scol) + 1
  end
  local count = (docview.wrapped_line_to_idx[line + 1] or (get_total_wrapped_lines(docview) + 1)) - (docview.wrapped_line_to_idx[line] or get_total_wrapped_lines(docview))
  return idx, ncol, count, scol
end

local function get_line_col_from_index_and_x(docview, idx, x)
  local doc = docview.doc
  local line, col = get_idx_line_col(docview, idx)
  if idx < 1 then return 1, 1 end
  local xoffset, last_i, i = (col ~= 1 and docview.wrapped_line_offsets[line] or 0), col, 1
  if x < xoffset then return line, col end
  local default_font = docview:get_font()
  for _, type, text in doc.highlighter:each_token(line) do
    local font, w = style.syntax_fonts[type] or default_font, 0
    for char in common.utf8_chars(text) do
      if i >= col then
        if xoffset >= x then
          return line, (xoffset - x > (w / 2) and last_i or i)
        end
        w = font:get_width(char)
        xoffset = xoffset + w
      end
      last_i = i
      i = i + #char
    end
  end
  return line, #doc.lines[line]
end


local open_files = {}

local old_doc_insert = Doc.raw_insert
function Doc:raw_insert(line, col, text, undo_stack, time)
  local old_lines = #self.lines
  old_doc_insert(self, line, col, text, undo_stack, time)
  if open_files[self] then
    for i,docview in ipairs(open_files[self]) do
      if docview.wrapped_settings then
        local lines = #self.lines - old_lines
        LineWrapping.update_breaks(docview, line, line, lines)
      end
    end
  end
end

local old_doc_remove = Doc.raw_remove
function Doc:raw_remove(line1, col1, line2, col2, undo_stack, time)
  local old_lines = #self.lines
  old_doc_remove(self, line1, col1, line2, col2, undo_stack, time)
  if open_files[self] then
    for i,docview in ipairs(open_files[self]) do
      if docview.wrapped_settings then
        local lines = #self.lines - old_lines
        LineWrapping.update_breaks(docview, line1, line2, lines)
      end
    end
  end
end

local old_doc_update = DocView.update
function DocView:update()
  old_doc_update(self)
  if self.wrapped_settings and self.size.x > 0 then
    LineWrapping.update_docview_breaks(self)
  end
end

function DocView:get_scrollable_size()
  if not config.scroll_past_end then
    return self:get_line_height() * get_total_wrapped_lines(self) + style.padding.y * 2
  end
  return self:get_line_height() * (get_total_wrapped_lines(self) - 1) + self.size.y
end

local old_new = DocView.new
function DocView:new(doc)
  old_new(self, doc)
  if not open_files[doc] then open_files[doc] = {} end
  table.insert(open_files[doc], self)
  if config.plugins.linewrapping.enable_by_default then
    self.wrapping_enabled = true
    LineWrapping.update_docview_breaks(self)
  else
    self.wrapping_enabled = false
  end
end

local old_scroll_to_line = DocView.scroll_to_line
function DocView:scroll_to_line(...)
  if self.wrapping_enabled then LineWrapping.update_docview_breaks(self) end
  old_scroll_to_line(self, ...)
end

local old_scroll_to_make_visible = DocView.scroll_to_make_visible
function DocView:scroll_to_make_visible(line, col)
  if self.wrapping_enabled then LineWrapping.update_docview_breaks(self) end
  old_scroll_to_make_visible(self, line, col)
  if self.wrapped_settings then self.scroll.to.x = 0 end
end

local old_get_visible_line_range = DocView.get_visible_line_range
function DocView:get_visible_line_range()
  if not self.wrapped_settings then return old_get_visible_line_range(self) end
  local x, y, x2, y2 = self:get_content_bounds()
  local lh = self:get_line_height()
  local minline = get_idx_line_col(self, math.max(1, math.floor(y / lh)))
  local maxline = get_idx_line_col(self, math.min(get_total_wrapped_lines(self), math.floor(y2 / lh) + 1))
  return minline, maxline
end

local old_get_x_offset_col = DocView.get_x_offset_col
function DocView:get_x_offset_col(line, x)
  if not self.wrapped_settings then return old_get_x_offset_col(self, line, x) end
  local idx = get_line_idx_col_count(self, line)
  return get_line_col_from_index_and_x(self, idx, x)
end

-- If line end is true, returns the end of the previous line, in a multi-line break.
local old_get_col_x_offset = DocView.get_col_x_offset
function DocView:get_col_x_offset(line, col, line_end)
  if not self.wrapped_settings then return old_get_col_x_offset(self, line, col) end
  local idx, ncol, count, scol = get_line_idx_col_count(self, line, col, line_end)
  local xoffset, i = (scol ~= 1 and self.wrapped_line_offsets[line] or 0), 1
  local default_font = self:get_font()
  for _, type, text in self.doc.highlighter:each_token(line) do
    if i + #text >= scol then
      if i < scol then
        text = text:sub(scol - i + 1)
        i = scol
      end
      local font = style.syntax_fonts[type] or default_font
      for char in common.utf8_chars(text) do
        if i >= col then
          return xoffset
        end
        xoffset = xoffset + font:get_width(char)
        i = i + #char
      end
    else
     i = i + #text
    end
  end
  return xoffset
end

local old_get_line_screen_position = DocView.get_line_screen_position
function DocView:get_line_screen_position(line, col)
  if not self.wrapped_settings then return old_get_line_screen_position(self, line, col) end
  local idx, ncol, count = get_line_idx_col_count(self, line, col)
  local x, y = self:get_content_offset()
  local lh = self:get_line_height()
  local gw = self:get_gutter_width()
  return x + gw + (col and self:get_col_x_offset(line, col) or 0), y + (idx-1) * lh + style.padding.y
end

local old_resolve_screen_position = DocView.resolve_screen_position
function DocView:resolve_screen_position(x, y)
  if not self.wrapped_settings then return old_resolve_screen_position(self, x, y) end
  local ox, oy = self:get_line_screen_position(1)
  local idx = common.clamp(math.floor((y - oy) / self:get_line_height()) + 1, 1, get_total_wrapped_lines(self))
  return get_line_col_from_index_and_x(self, idx, x - ox)
end

local old_draw_line_text = DocView.draw_line_text
function DocView:draw_line_text(line, x, y)
  if not self.wrapped_settings then return old_draw_line_text(self, line, x, y) end
  local default_font = self:get_font()
  local tx, ty, begin_width = x, y + self:get_line_text_y_offset(), self.wrapped_line_offsets[line]
  local lh = self:get_line_height()
  local idx, _, count = get_line_idx_col_count(self, line)
  local total_offset = 1
  for _, type, text in self.doc.highlighter:each_token(line) do
    local color = style.syntax[type]
    local font = style.syntax_fonts[type] or default_font
    local token_offset = 1
    -- Split tokens if we're at the end of the document.
    while text ~= nil and token_offset <= #text do
      local next_line, next_line_start_col = get_idx_line_col(self, idx + 1)
      if next_line ~= line then
        next_line_start_col = #self.doc.lines[line]
      end
      local max_length = next_line_start_col - total_offset
      local rendered_text = text:sub(token_offset, token_offset + max_length - 1)
      tx = renderer.draw_text(font, rendered_text, tx, ty, color)
      total_offset = total_offset + #rendered_text
      if total_offset ~= next_line_start_col or max_length == 0 then break end
      token_offset = token_offset + #rendered_text
      idx = idx + 1
      tx, ty = x + begin_width, ty + lh
    end
  end
  return lh * count
end

local old_draw_line_body = DocView.draw_line_body
function DocView:draw_line_body(line, x, y)
  if not self.wrapped_settings then return old_draw_line_body(self, line, x, y) end
  local lh = self:get_line_height()
  local idx0 = get_line_idx_col_count(self, line)
  for lidx, line1, col1, line2, col2 in self.doc:get_selections(true) do
    if line >= line1 and line <= line2 then
      if line1 ~= line then col1 = 1 end
      if line2 ~= line then col2 = #self.doc.lines[line] + 1 end
      if col1 ~= col2 then
        local idx1, ncol1 = get_line_idx_col_count(self, line, col1)
        local idx2, ncol2 = get_line_idx_col_count(self, line, col2)
        for i = idx1, idx2 do
          local x1, x2 = x + (idx1 == i and self:get_col_x_offset(line1, col1) or 0)
          if idx2 == i then
            x2 = x + self:get_col_x_offset(line, col2)
          else
            x2 = x + self:get_col_x_offset(line, get_idx_line_length(self, i, line) + 1, true)
          end
          renderer.draw_rect(x1, y + (i - idx0) * lh, x2 - x1, lh, style.selection)
        end
      end
    end
  end
  local draw_highlight = nil
  for lidx, line1, col1, line2, col2 in self.doc:get_selections(true) do
    -- draw line highlight if caret is on this line
    if draw_highlight ~= false and config.highlight_current_line
    and line1 == line and core.active_view == self then
      draw_highlight = (line1 == line2 and col1 == col2)
    end
  end
  if draw_highlight then
    local _, _, count = get_line_idx_col_count(self, line)
    for i=1,count do
      self:draw_line_highlight(x + self.scroll.x, y + lh * (i - 1))
    end
  end
  -- draw line's text
  return self:draw_line_text(line, x, y)
end

local old_draw = DocView.draw
function DocView:draw()
  old_draw(self)
  if self.wrapped_settings then
    LineWrapping.draw_guide(self)
  end
end

local old_draw_line_gutter = DocView.draw_line_gutter
function DocView:draw_line_gutter(line, x, y, width)
  local lh = self:get_line_height()
  local _, _, count = get_line_idx_col_count(self, line)
  return (old_draw_line_gutter(self, line, x, y, width) or lh) * count
end

local old_translate_end_of_line = translate.end_of_line
function translate.end_of_line(doc, line, col)
  if not core.active_view or core.active_view.doc ~= doc or not core.active_view.wrapped_settings then old_translate_end_of_line(doc, line, col) end
  local idx, ncol = get_line_idx_col_count(core.active_view, line, col)
  local nline, ncol2 = get_idx_line_col(core.active_view, idx + 1)
  if nline ~= line then return line, math.huge end
  return line, ncol2 - 1
end

local old_translate_start_of_line = translate.start_of_line
function translate.start_of_line(doc, line, col)
  if not core.active_view or core.active_view.doc ~= doc or not core.active_view.wrapped_settings then old_translate_start_of_line(doc, line, col) end
  local idx, ncol = get_line_idx_col_count(core.active_view, line, col)
  local nline, ncol2 = get_idx_line_col(core.active_view, idx - 1)
  if nline ~= line then return line, 1 end
  return line, ncol2 + 1
end

local old_previous_line = DocView.translate.previous_line
function DocView.translate.previous_line(doc, line, col, dv)
  if not dv.wrapped_settings then return old_previous_line(doc, line, col, dv) end
  local idx, ncol = get_line_idx_col_count(dv, line, col)
  return get_line_col_from_index_and_x(dv, idx - 1, dv:get_col_x_offset(line, col))
end

local old_next_line = DocView.translate.next_line
function DocView.translate.next_line(doc, line, col, dv)
  if not dv.wrapped_settings then return old_next_line(doc, line, col, dv) end
  local idx, ncol = get_line_idx_col_count(dv, line, col)
  return get_line_col_from_index_and_x(dv, idx + 1, dv:get_col_x_offset(line, col))
end

command.add(nil, {
  ["line-wrapping:enable"] = function()
    if core.active_view and core.active_view.doc then
      core.active_view.wrapping_enabled = true
      LineWrapping.update_docview_breaks(core.active_view)
    end
  end,
  ["line-wrapping:disable"] = function()
    if core.active_view and core.active_view.doc then
      core.active_view.wrapping_enabled = false
      LineWrapping.reconstruct_breaks(core.active_view, core.active_view:get_font(), math.huge)
    end
  end,
  ["line-wrapping:toggle"] = function()
    if core.active_view and core.active_view.doc and core.active_view.wrapped_settings then
      command.perform("line-wrapping:disable")
    else
      command.perform("line-wrapping:enable")
    end
  end
})

keymap.add {
  ["f10"] = "line-wrapping:toggle",
}

return LineWrapping
-- mod-version:3
local core = require "core"
local command = require "core.command"
local keymap = require "core.keymap"

local handled_events = {
  ["keypressed"]  = true,
  ["keyreleased"] = true,
  ["textinput"]   = true,
}

local state = "stopped"
local event_buffer = {}
local modkeys = {}

local on_event = core.on_event

core.on_event = function(type, ...)
  local res = on_event(type, ...)
  if state == "recording" and handled_events[type] then
    table.insert(event_buffer, { type, ... })
  end
  return res
end


local function clone(t)
  local res = {}
  for k, v in pairs(t) do res[k] = v end
  return res
end


local function predicate()
  return state ~= "playing"
end


command.add(predicate, {
  ["macro:toggle-record"] = function()
    if state == "stopped" then
      state = "recording"
      event_buffer = {}
      modkeys = clone(keymap.modkeys)
      core.log("Recording macro...")
    else
      state = "stopped"
      core.log("Stopped recording macro (%d events)", #event_buffer)
    end
  end,

  ["macro:play"] = function()
    state = "playing"
    core.log("Playing macro... (%d events)", #event_buffer)
    local mk = keymap.modkeys
    keymap.modkeys = clone(modkeys)
    for _, ev in ipairs(event_buffer) do
      on_event(table.unpack(ev))
      core.root_view:update()
    end
    keymap.modkeys = mk
    state = "stopped"
  end,
})


keymap.add {
  ["ctrl+shift+;"] = "macro:toggle-record",
  ["ctrl+;"] = "macro:play",
}
-- mod-version:3
local core = require "core"
local common = require "core.common"
local keymap = require "core.keymap"
local command = require "core.command"
local style = require "core.style"
local View = require "core.view"

---@class plugins.projectsearch.resultsview : core.view
local ResultsView = View:extend()

ResultsView.context = "session"

function ResultsView:new(path, text, fn)
  ResultsView.super.new(self)
  self.scrollable = true
  self.brightness = 0
  self:begin_search(path, text, fn)
end


function ResultsView:get_name()
  return "Search Results"
end


local function find_all_matches_in_file(t, filename, fn)
  local fp = io.open(filename)
  if not fp then return t end
  local n = 1
  for line in fp:lines() do
    local s = fn(line)
    if s then
      -- Insert maximum 256 characters. If we insert more, for compiled files, which can have very long lines
      -- things tend to get sluggish. If our line is longer than 80 characters, begin to truncate the thing.
      local start_index = math.max(s - 80, 1)
      table.insert(t, { file = filename, text = (start_index > 1 and "..." or "") .. line:sub(start_index, 256 + start_index), line = n, col = s })
      core.redraw = true
    end
    if n % 100 == 0 then coroutine.yield() end
    n = n + 1
    core.redraw = true
  end
  fp:close()
end


function ResultsView:begin_search(path, text, fn)
  self.search_args = { path, text, fn }
  self.results = {}
  self.last_file_idx = 1
  self.query = text
  self.searching = true
  self.selected_idx = 0

  core.add_thread(function()
    local i = 1
    for dir_name, file in core.get_project_files() do
      if file.type == "file" and (not path or (dir_name .. "/" .. file.filename):find(path, 1, true) == 1) then
        local truncated_path = (dir_name == core.project_dir and "" or (dir_name .. PATHSEP))
        find_all_matches_in_file(self.results, truncated_path .. file.filename, fn)
      end
      self.last_file_idx = i
      i = i + 1
    end
    self.searching = false
    self.brightness = 100
    core.redraw = true
  end, self.results)

  self.scroll.to.y = 0
end


function ResultsView:refresh()
  self:begin_search(table.unpack(self.search_args))
end


function ResultsView:on_mouse_moved(mx, my, ...)
  ResultsView.super.on_mouse_moved(self, mx, my, ...)
  self.selected_idx = 0
  for i, item, x,y,w,h in self:each_visible_result() do
    if mx >= x and my >= y and mx < x + w and my < y + h then
      self.selected_idx = i
      break
    end
  end
end


function ResultsView:on_mouse_pressed(...)
  local caught = ResultsView.super.on_mouse_pressed(self, ...)
  if not caught then
    return self:open_selected_result()
  end
end


function ResultsView:open_selected_result()
  local res = self.results[self.selected_idx]
  if not res then
    return
  end
  core.try(function()
    local dv = core.root_view:open_doc(core.open_doc(res.file))
    core.root_view.root_node:update_layout()
    dv.doc:set_selection(res.line, res.col)
    dv:scroll_to_line(res.line, false, true)
  end)
  return true
end


function ResultsView:update()
  self:move_towards("brightness", 0, 0.1)
  ResultsView.super.update(self)
end


function ResultsView:get_results_yoffset()
  return style.font:get_height() + style.padding.y * 3
end


function ResultsView:get_line_height()
  return style.padding.y + style.font:get_height()
end


function ResultsView:get_scrollable_size()
  return self:get_results_yoffset() + #self.results * self:get_line_height()
end


function ResultsView:get_visible_results_range()
  local lh = self:get_line_height()
  local oy = self:get_results_yoffset()
  local min = math.max(1, math.floor((self.scroll.y - oy) / lh))
  return min, min + math.floor(self.size.y / lh) + 1
end


function ResultsView:each_visible_result()
  return coroutine.wrap(function()
    local lh = self:get_line_height()
    local x, y = self:get_content_offset()
    local min, max = self:get_visible_results_range()
    y = y + self:get_results_yoffset() + lh * (min - 1)
    for i = min, max do
      local item = self.results[i]
      if not item then break end
      coroutine.yield(i, item, x, y, self.size.x, lh)
      y = y + lh
    end
  end)
end


function ResultsView:scroll_to_make_selected_visible()
  local h = self:get_line_height()
  local y = self:get_results_yoffset() + h * (self.selected_idx - 1)
  self.scroll.to.y = math.min(self.scroll.to.y, y)
  self.scroll.to.y = math.max(self.scroll.to.y, y + h - self.size.y)
end


function ResultsView:draw()
  self:draw_background(style.background)

  -- status
  local ox, oy = self:get_content_offset()
  local x, y = ox + style.padding.x, oy + style.padding.y
  local files_number = core.project_files_number()
  local per = common.clamp(files_number and self.last_file_idx / files_number or 1, 0, 1)
  local text
  if self.searching then
    if files_number then
      text = string.format("Searching %.f%% (%d of %d files, %d matches) for %q...",
        per * 100, self.last_file_idx, files_number,
        #self.results, self.query)
    else
      text = string.format("Searching (%d files, %d matches) for %q...",
        self.last_file_idx, #self.results, self.query)
    end
  else
    text = string.format("Found %d matches for %q",
      #self.results, self.query)
  end
  local color = common.lerp(style.text, style.accent, self.brightness / 100)
  renderer.draw_text(style.font, text, x, y, color)

  -- horizontal line
  local yoffset = self:get_results_yoffset()
  local x = ox + style.padding.x
  local w = self.size.x - style.padding.x * 2
  local h = style.divider_size
  local color = common.lerp(style.dim, style.text, self.brightness / 100)
  renderer.draw_rect(x, oy + yoffset - style.padding.y, w, h, color)
  if self.searching then
    renderer.draw_rect(x, oy + yoffset - style.padding.y, w * per, h, style.text)
  end

  -- results
  local y1, y2 = self.position.y, self.position.y + self.size.y
  for i, item, x,y,w,h in self:each_visible_result() do
    local color = style.text
    if i == self.selected_idx then
      color = style.accent
      renderer.draw_rect(x, y, w, h, style.line_highlight)
    end
    x = x + style.padding.x
    local text = string.format("%s at line %d (col %d): ", item.file, item.line, item.col)
    x = common.draw_text(style.font, style.dim, text, "left", x, y, w, h)
    x = common.draw_text(style.code_font, color, item.text, "left", x, y, w, h)
  end

  self:draw_scrollbar()
end


---@param path string
---@param text string
---@param fn fun(line_text:string):...
---@return plugins.projectsearch.resultsview?
local function begin_search(path, text, fn)
  if text == "" then
    core.error("Expected non-empty string")
    return
  end
  local rv = ResultsView(path, text, fn)
  core.root_view:get_active_node_default():add_view(rv)
  return rv
end


local function get_selected_text()
  local view = core.active_view
  local doc = (view and view.doc) and view.doc or nil
  if doc then
    return doc:get_text(table.unpack({ doc:get_selection() }))
  end
end


local function normalize_path(path)
  if not path then return nil end
  path = common.normalize_path(path)
  for i, project_dir in ipairs(core.project_directories) do
    if common.path_belongs_to(path, project_dir.name) then
      return project_dir.item.filename .. PATHSEP .. common.relative_path(project_dir.name, path)
    end
  end
  return path
end

---@class plugins.projectsearch
local projectsearch = {}

---@type plugins.projectsearch.resultsview
projectsearch.ResultsView = ResultsView

---@param text string
---@param path string
---@param insensitive? boolean
---@return plugins.projectsearch.resultsview?
function projectsearch.search_plain(text, path, insensitive)
  if insensitive then text = text:lower() end
  return begin_search(path, text, function(line_text)
    if insensitive then
      return line_text:lower():find(text, nil, true)
    else
      return line_text:find(text, nil, true)
    end
  end)
end

---@param text string
---@param path string
---@param insensitive? boolean
---@return plugins.projectsearch.resultsview?
function projectsearch.search_regex(text, path, insensitive)
  local re, errmsg
  if insensitive then
    re, errmsg = regex.compile(text, "i")
  else
    re, errmsg = regex.compile(text)
  end
  if not re then core.log("%s", errmsg) return end
  return begin_search(path, text, function(line_text)
    return regex.cmatch(re, line_text)
  end)
end

---@param text string
---@param path string
---@param insensitive? boolean
---@return plugins.projectsearch.resultsview?
function projectsearch.search_fuzzy(text, path, insensitive)
  if insensitive then text = text:lower() end
  return begin_search(path, text, function(line_text)
    if insensitive then
      return common.fuzzy_match(line_text:lower(), text) and 1
    else
      return common.fuzzy_match(line_text, text) and 1
    end
  end)
end


command.add(nil, {
  ["project-search:find"] = function(path)
    core.command_view:enter("Find Text In " .. (normalize_path(path) or "Project"), {
      text = get_selected_text(),
      select_text = true,
      submit = function(text)
        projectsearch.search_plain(text, path, true)
      end
    })
  end,

  ["project-search:find-regex"] = function(path)
    core.command_view:enter("Find Regex In " .. (normalize_path(path) or "Project"), {
      submit = function(text)
        projectsearch.search_regex(text, path, true)
      end
    })
  end,

  ["project-search:fuzzy-find"] = function(path)
    core.command_view:enter("Fuzzy Find Text In " .. (normalize_path(path) or "Project"), {
      text = get_selected_text(),
      select_text = true,
      submit = function(text)
        projectsearch.search_fuzzy(text, path, true)
      end
    })
  end,
})


command.add(ResultsView, {
  ["project-search:select-previous"] = function()
    local view = core.active_view
    view.selected_idx = math.max(view.selected_idx - 1, 1)
    view:scroll_to_make_selected_visible()
  end,

  ["project-search:select-next"] = function()
    local view = core.active_view
    view.selected_idx = math.min(view.selected_idx + 1, #view.results)
    view:scroll_to_make_selected_visible()
  end,

  ["project-search:open-selected"] = function()
    core.active_view:open_selected_result()
  end,

  ["project-search:refresh"] = function()
    core.active_view:refresh()
  end,

  ["project-search:move-to-previous-page"] = function()
    local view = core.active_view
    view.scroll.to.y = view.scroll.to.y - view.size.y
  end,

  ["project-search:move-to-next-page"] = function()
    local view = core.active_view
    view.scroll.to.y = view.scroll.to.y + view.size.y
  end,

  ["project-search:move-to-start-of-doc"] = function()
    local view = core.active_view
    view.scroll.to.y = 0
  end,

  ["project-search:move-to-end-of-doc"] = function()
    local view = core.active_view
    view.scroll.to.y = view:get_scrollable_size()
  end
})

keymap.add {
  ["f5"]                 = "project-search:refresh",
  ["ctrl+shift+f"]       = "project-search:find",
  ["up"]                 = "project-search:select-previous",
  ["down"]               = "project-search:select-next",
  ["return"]             = "project-search:open-selected",
  ["pageup"]             = "project-search:move-to-previous-page",
  ["pagedown"]           = "project-search:move-to-next-page",
  ["ctrl+home"]          = "project-search:move-to-start-of-doc",
  ["ctrl+end"]           = "project-search:move-to-end-of-doc",
  ["home"]               = "project-search:move-to-start-of-doc",
  ["end"]                = "project-search:move-to-end-of-doc"
}


return projectsearch
-- mod-version:3
local core = require "core"
local command = require "core.command"
local keymap = require "core.keymap"


local escapes = {
  ["\\"] = "\\\\",
  ["\""] = "\\\"",
  ["\n"] = "\\n",
  ["\r"] = "\\r",
  ["\t"] = "\\t",
  ["\b"] = "\\b",
}

local function replace(chr)
  return escapes[chr] or string.format("\\x%02x", chr:byte())
end


command.add("core.docview", {
  ["quote:quote"] = function(dv)
    dv.doc:replace(function(text)
      return '"' .. text:gsub("[\0-\31\\\"]", replace) .. '"'
    end)
  end,
})

keymap.add {
  ["ctrl+'"] = "quote:quote",
}
-- mod-version:3
local core = require "core"
local config = require "core.config"
local command = require "core.command"
local keymap = require "core.keymap"


local function wordwrap_text(text, limit)
  local t = {}
  local n = 0

  for word in text:gmatch("%S+") do
    if n + #word > limit then
      table.insert(t, "\n")
      n = 0
    elseif #t > 0 then
      table.insert(t, " ")
    end
    table.insert(t, word)
    n = n + #word + 1
  end

  return table.concat(t)
end


command.add("core.docview", {
  ["reflow:reflow"] = function(dv)
    local doc = dv.doc
    doc:replace(function(text)
      local prefix_set = "[^%w\n%[%](){}`'\"]*"

      -- get line prefix and trailing whitespace
      local prefix1 = text:match("^\n*" .. prefix_set)
      local prefix2 = text:match("\n(" .. prefix_set .. ")", #prefix1+1)
      local trailing = text:match("%s*$")
      if not prefix2 or prefix2 == "" then
        prefix2 = prefix1
      end

      -- strip all line prefixes and trailing whitespace
      text = text:sub(#prefix1+1, -#trailing - 1):gsub("\n" .. prefix_set, "\n")

      -- split into blocks, wordwrap and join
      local line_limit = config.line_limit - #prefix1
      local blocks = {}
      text = text:gsub("\n\n", "\0")
      for block in text:gmatch("%Z+") do
        table.insert(blocks, wordwrap_text(block, line_limit))
      end
      text = table.concat(blocks, "\n\n")

      -- add prefix to start of lines
      text = prefix1 .. text:gsub("\n", "\n" .. prefix2) .. trailing

      return text
    end)
  end,
})


keymap.add_direct {
  ["ctrl+shift+q"] = "reflow:reflow"
}
-- mod-version:3
local core = require "core"
local common = require "core.common"
local command = require "core.command"
local config = require "core.config"
local keymap = require "core.keymap"
local style = require "core.style"
local CommandView = require "core.commandview"

config.plugins.scale = common.merge({
  -- The method used to apply the scaling: "code", "ui"
  mode = "code",
  -- Default scale applied at startup.
  default_scale = "autodetect",
  -- Allow using CTRL + MouseWheel for changing the scale.
  use_mousewheel = true
}, config.plugins.scale)

local scale_steps = 0.05

local current_scale = SCALE
local default_scale = SCALE

local function set_scale(scale)
  scale = common.clamp(scale, 0.2, 6)

  -- save scroll positions
  local scrolls = {}
  for _, view in ipairs(core.root_view.root_node:get_children()) do
    local n = view:get_scrollable_size()
    if n ~= math.huge and not view:is(CommandView) and n > view.size.y then
      scrolls[view] = view.scroll.y / (n - view.size.y)
    end
  end

  local s = scale / current_scale
  current_scale = scale

  if config.plugins.scale.mode == "ui" then
    SCALE = scale

    style.padding.x      = style.padding.x      * s
    style.padding.y      = style.padding.y      * s
    style.divider_size   = style.divider_size   * s
    style.scrollbar_size = style.scrollbar_size * s
    style.caret_width    = style.caret_width    * s
    style.tab_width      = style.tab_width      * s

    for _, name in ipairs {"font", "big_font", "icon_font", "icon_big_font", "code_font"} do
      style[name]:set_size(s * style[name]:get_size())
    end
  else
    style.code_font:set_size(s * style.code_font:get_size())
  end

  for name, font in pairs(style.syntax_fonts) do
    style.syntax_fonts[name]:set_size(s * font:get_size())
  end

  -- restore scroll positions
  for view, n in pairs(scrolls) do
    view.scroll.y = n * (view:get_scrollable_size() - view.size.y)
    view.scroll.to.y = view.scroll.y
  end

  core.redraw = true
end

local function get_scale()
  return current_scale
end

local function res_scale()
  set_scale(default_scale)
end

local function inc_scale()
  set_scale(current_scale + scale_steps)
end

local function dec_scale()
  set_scale(current_scale - scale_steps)
end

if default_scale ~= config.plugins.scale.default_scale then
  if type(config.plugins.scale.default_scale) == "number" then
    set_scale(config.plugins.scale.default_scale)
  end
end

-- The config specification used by gui generators
config.plugins.scale.config_spec = {
  name = "Scale",
  {
    label = "Mode",
    description = "The method used to apply the scaling.",
    path = "mode",
    type = "selection",
    default = "code",
    values = {
      {"Everything", "ui"},
      {"Code Only", "code"}
    }
  },
  {
    label = "Default Scale",
    description = "The scaling factor applied to lite-xl.",
    path = "default_scale",
    type = "selection",
    default = "autodetect",
    values = {
      {"Autodetect", "autodetect"},
      {"80%", 0.80},
      {"90%", 0.90},
      {"100%", 1.00},
      {"110%", 1.10},
      {"120%", 1.20},
      {"125%", 1.25},
      {"130%", 1.30},
      {"140%", 1.40},
      {"150%", 1.50},
      {"175%", 1.75},
      {"200%", 2.00},
      {"250%", 2.50},
      {"300%", 3.00}
    },
    on_apply = function(value)
      if type(value) == "string" then value = default_scale end
      if value ~= current_scale then
        set_scale(value)
      end
    end
  },
  {
    label = "Use MouseWheel",
    description = "Allow using CTRL + MouseWheel for changing the scale.",
    path = "use_mousewheel",
    type = "toggle",
    default = true,
    on_apply = function(enabled)
      if enabled then
        keymap.add {
          ["ctrl+wheelup"] = "scale:increase",
          ["ctrl+wheeldown"] = "scale:decrease"
        }
      else
        keymap.unbind("ctrl+wheelup", "scale:increase")
        keymap.unbind("ctrl+wheeldown", "scale:decrease")
      end
    end
  }
}


command.add(nil, {
  ["scale:reset"   ] = function() res_scale() end,
  ["scale:decrease"] = function() dec_scale() end,
  ["scale:increase"] = function() inc_scale() end,
})

keymap.add {
  ["ctrl+0"] = "scale:reset",
  ["ctrl+-"] = "scale:decrease",
  ["ctrl+="] = "scale:increase"
}

if config.plugins.scale.use_mousewheel then
  keymap.add {
    ["ctrl+wheelup"] = "scale:increase",
    ["ctrl+wheeldown"] = "scale:decrease"
  }
end

return {
  ["set"] = set_scale,
  ["get"] = get_scale,
  ["increase"] = inc_scale,
  ["decrease"] = dec_scale,
  ["reset"] = res_scale
}
-- mod-version:3
local core = require "core"
local command = require "core.command"
local translate = require "core.doc.translate"


local function gmatch_to_array(text, ptn)
  local res = {}
  for x in text:gmatch(ptn) do
    table.insert(res, x)
  end
  return res
end


local function tabularize_lines(lines, delim)
  local rows = {}
  local cols = {}

  -- split lines at delimiters and get maximum width of columns
  local ptn = "[^" .. delim:sub(1,1):gsub("%W", "%%%1") .. "]+"
  for i, line in ipairs(lines) do
    rows[i] = gmatch_to_array(line, ptn)
    for j, col in ipairs(rows[i]) do
      cols[j] = math.max(#col, cols[j] or 0)
    end
  end

  -- pad columns with space
  for _, row in ipairs(rows) do
    for i = 1, #row - 1 do
      row[i] = row[i] .. string.rep(" ", cols[i] - #row[i])
    end
  end

  -- write columns back to lines array
  for i, line in ipairs(lines) do
    lines[i] = table.concat(rows[i], delim)
  end
end


command.add("core.docview", {
  ["tabularize:tabularize"] = function(dv)
    core.command_view:enter("Tabularize On Delimiter", {
      submit = function(delim)
        if delim == "" then delim = " " end

        local doc = dv.doc
        local line1, col1, line2, col2, swap = doc:get_selection(true)
        line1, col1 = doc:position_offset(line1, col1, translate.start_of_line)
        line2, col2 = doc:position_offset(line2, col2, translate.end_of_line)
        doc:set_selection(line1, col1, line2, col2, swap)

        doc:replace(function(text)
          local lines = gmatch_to_array(text, "[^\n]*\n?")
          tabularize_lines(lines, delim)
          return table.concat(lines)
        end)
      end
    })
  end,
})
-- mod-version:3
local core = require "core"
local common = require "core.common"
local command = require "core.command"
local style = require "core.style"
local View = require "core.view"

local ToolbarView = View:extend()


function ToolbarView:new()
  ToolbarView.super.new(self)
  self.visible = true
  self.init_size = true
  self.tooltip = false
  self.toolbar_font = style.icon_big_font
  self.toolbar_commands = {
    {symbol = "f", command = "core:new-doc"},
    {symbol = "D", command = "core:open-file"},
    {symbol = "S", command = "doc:save"},
    {symbol = "L", command = "core:find-file"},
    {symbol = "B", command = "core:find-command"},
    {symbol = "P", command = "core:open-user-module"},
  }
end


function ToolbarView:update()
  local dest_size = self.visible and (self.toolbar_font:get_height() + style.padding.y * 2) or 0
  if self.init_size then
    self.size.y = dest_size
    self.init_size = nil
  else
    self:move_towards(self.size, "y", dest_size)
  end
  ToolbarView.super.update(self)
end


function ToolbarView:toggle_visible()
  self.visible = not self.visible
  if self.tooltip then
    core.status_view:remove_tooltip()
    self.tooltip = false
  end
  self.hovered_item = nil
end

function ToolbarView:get_icon_width()
  local max_width = 0
  for i,v in ipairs(self.toolbar_commands) do max_width = math.max(max_width, self.toolbar_font:get_width(v.symbol)) end
  return max_width
end

function ToolbarView:each_item()
  local icon_h, icon_w = self.toolbar_font:get_height(), self:get_icon_width()
  local toolbar_spacing = icon_w / 2
  local ox, oy = self:get_content_offset()
  local index = 0
  local iter = function()
    index = index + 1
    if index <= #self.toolbar_commands then
      local dx = style.padding.x + (icon_w + toolbar_spacing) * (index - 1)
      local dy = style.padding.y
      if dx + icon_w > self.size.x then return end
      return self.toolbar_commands[index], ox + dx, oy + dy, icon_w, icon_h
    end
  end
  return iter
end


function ToolbarView:get_min_width()
  local icon_w = self:get_icon_width()
  local space = icon_w / 2
  return 2 * style.padding.x + (icon_w + space) * #self.toolbar_commands - space
end


function ToolbarView:draw()
  if not self.visible then return end
  self:draw_background(style.background2)

  for item, x, y, w, h in self:each_item() do
    local color = item == self.hovered_item and command.is_valid(item.command) and style.text or style.dim
    common.draw_text(self.toolbar_font, color, item.symbol, nil, x, y, 0, h)
  end
end


function ToolbarView:on_mouse_pressed(button, x, y, clicks)
  if not self.visible then return end
  local caught = ToolbarView.super.on_mouse_pressed(self, button, x, y, clicks)
  if caught then return caught end
  core.set_active_view(core.last_active_view)
  if self.hovered_item and command.is_valid(self.hovered_item.command) then
    command.perform(self.hovered_item.command)
  end
  return true
end


function ToolbarView:on_mouse_moved(px, py, ...)
  if not self.visible then return end
  ToolbarView.super.on_mouse_moved(self, px, py, ...)
  self.hovered_item = nil
  local x_min, x_max, y_min, y_max = self.size.x, 0, self.size.y, 0
  for item, x, y, w, h in self:each_item() do
    x_min, x_max = math.min(x, x_min), math.max(x + w, x_max)
    y_min, y_max = y, y + h
    if px > x and py > y and px <= x + w and py <= y + h then
      self.hovered_item = item
      core.status_view:show_tooltip(command.prettify_name(item.command))
      self.tooltip = true
      return
    end
  end
  if self.tooltip and not (px > x_min and px <= x_max and py > y_min and py <= y_max) then
    core.status_view:remove_tooltip()
    self.tooltip = false
  end
end

-- The toolbarview pane is not plugged here but it is added in the
-- treeview plugin.

return ToolbarView
-- mod-version:3
local core = require "core"
local common = require "core.common"
local command = require "core.command"
local config = require "core.config"
local keymap = require "core.keymap"
local style = require "core.style"
local View = require "core.view"
local ContextMenu = require "core.contextmenu"
local RootView = require "core.rootview"
local CommandView = require "core.commandview"

config.plugins.treeview = common.merge({
  -- Default treeview width
  size = 200 * SCALE
}, config.plugins.treeview)

local tooltip_offset = style.font:get_height()
local tooltip_border = 1
local tooltip_delay = 0.5
local tooltip_alpha = 255
local tooltip_alpha_rate = 1


local function get_depth(filename)
  local n = 1
  for sep in filename:gmatch("[\\/]") do
    n = n + 1
  end
  return n
end

local function replace_alpha(color, alpha)
  local r, g, b = table.unpack(color)
  return { r, g, b, alpha }
end


local TreeView = View:extend()

function TreeView:new()
  TreeView.super.new(self)
  self.scrollable = true
  self.visible = true
  self.init_size = true
  self.target_size = config.plugins.treeview.size
  self.cache = {}
  self.tooltip = { x = 0, y = 0, begin = 0, alpha = 0 }
  self.cursor_pos = { x = 0, y = 0 }

  self.item_icon_width = 0
  self.item_text_spacing = 0
end


function TreeView:set_target_size(axis, value)
  if axis == "x" then
    self.target_size = value
    return true
  end
end


function TreeView:get_cached(dir, item, dirname)
  local dir_cache = self.cache[dirname]
  if not dir_cache then
    dir_cache = {}
    self.cache[dirname] = dir_cache
  end
  -- to discriminate top directories from regular files or subdirectories
  -- we add ':' at the end of the top directories' filename. it will be
  -- used only to identify the entry into the cache.
  local cache_name = item.filename .. (item.topdir and ":" or "")
  local t = dir_cache[cache_name]
  if not t or t.type ~= item.type then
    t = {}
    local basename = common.basename(item.filename)
    if item.topdir then
      t.filename = basename
      t.expanded = true
      t.depth = 0
      t.abs_filename = dirname
    else
      t.filename = item.filename
      t.depth = get_depth(item.filename)
      t.abs_filename = dirname .. PATHSEP .. item.filename
    end
    t.name = basename
    t.type = item.type
    t.dir_name = dir.name -- points to top level "dir" item
    dir_cache[cache_name] = t
  end
  return t
end


function TreeView:get_name()
  return nil
end


function TreeView:get_item_height()
  return style.font:get_height() + style.padding.y
end


function TreeView:invalidate_cache(dirname)
  for _, v in pairs(self.cache[dirname]) do
    v.skip = nil
  end
end


function TreeView:check_cache()
  for i = 1, #core.project_directories do
    local dir = core.project_directories[i]
    -- invalidate cache's skip values if directory is declared dirty
    if dir.is_dirty and self.cache[dir.name] then
      self:invalidate_cache(dir.name)
    end
    dir.is_dirty = false
  end
end


function TreeView:each_item()
  return coroutine.wrap(function()
    self:check_cache()
    local count_lines = 0
    local ox, oy = self:get_content_offset()
    local y = oy + style.padding.y
    local w = self.size.x
    local h = self:get_item_height()

    for k = 1, #core.project_directories do
      local dir = core.project_directories[k]
      local dir_cached = self:get_cached(dir, dir.item, dir.name)
      coroutine.yield(dir_cached, ox, y, w, h)
      count_lines = count_lines + 1
      y = y + h
      local i = 1
      if dir.files then -- if consumed max sys file descriptors this can be nil
        while i <= #dir.files and dir_cached.expanded do
          local item = dir.files[i]
          local cached = self:get_cached(dir, item, dir.name)

          coroutine.yield(cached, ox, y, w, h)
          count_lines = count_lines + 1
          y = y + h
          i = i + 1

          if not cached.expanded then
            if cached.skip then
              i = cached.skip
            else
              local depth = cached.depth
              while i <= #dir.files do
                if get_depth(dir.files[i].filename) <= depth then break end
                i = i + 1
              end
              cached.skip = i
            end
          end
        end -- while files
      end
    end -- for directories
    self.count_lines = count_lines
  end)
end


function TreeView:set_selection(selection, selection_y)
  self.selected_item = selection
  if selection and selection_y
      and (selection_y <= 0 or selection_y >= self.size.y) then

    local lh = self:get_item_height()
    if selection_y >= self.size.y - lh then
      selection_y = selection_y - self.size.y + lh
    end
    local _, y = self:get_content_offset()
    self.scroll.to.y = selection and (selection_y - y)
  end
end


function TreeView:get_text_bounding_box(item, x, y, w, h)
  local icon_width = style.icon_font:get_width("D")
  local xoffset = item.depth * style.padding.x + style.padding.x + icon_width
  x = x + xoffset
  w = style.font:get_width(item.name) + 2 * style.padding.x
  return x, y, w, h
end


function TreeView:on_mouse_moved(px, py, ...)
  if not self.visible then return end
  self.cursor_pos.x = px
  self.cursor_pos.y = py
  if TreeView.super.on_mouse_moved(self, px, py, ...) then
    -- mouse movement handled by the View (scrollbar)
    self.hovered_item = nil
    return
  end

  local item_changed, tooltip_changed
  for item, x,y,w,h in self:each_item() do
    if px > x and py > y and px <= x + w and py <= y + h then
      item_changed = true
      self.hovered_item = item

      x,y,w,h = self:get_text_bounding_box(item, x,y,w,h)
      if px > x and py > y and px <= x + w and py <= y + h then
        tooltip_changed = true
        self.tooltip.x, self.tooltip.y = px, py
        self.tooltip.begin = system.get_time()
      end
      break
    end
  end
  if not item_changed then self.hovered_item = nil end
  if not tooltip_changed then self.tooltip.x, self.tooltip.y = nil, nil end
end


function TreeView:update()
  -- update width
  local dest = self.visible and self.target_size or 0
  if self.init_size then
    self.size.x = dest
    self.init_size = false
  else
    self:move_towards(self.size, "x", dest, nil, "treeview")
  end

  if not self.visible then return end

  local duration = system.get_time() - self.tooltip.begin
  if self.hovered_item and self.tooltip.x and duration > tooltip_delay then
    self:move_towards(self.tooltip, "alpha", tooltip_alpha, tooltip_alpha_rate, "treeview")
  else
    self.tooltip.alpha = 0
  end

  self.item_icon_width = style.icon_font:get_width("D")
  self.item_text_spacing = style.icon_font:get_width("f") / 2

  -- this will make sure hovered_item is updated
  -- we don't want events when the thing is scrolling fast
  local dy = math.abs(self.scroll.to.y - self.scroll.y)
  if self.scroll.to.y ~= 0 and dy < self:get_item_height() then
    self:on_mouse_moved(self.cursor_pos.x, self.cursor_pos.y, 0, 0)
  end

  TreeView.super.update(self)
end


function TreeView:get_scrollable_size()
  return self.count_lines and self:get_item_height() * (self.count_lines + 1) or math.huge
end


function TreeView:draw_tooltip()
  local text = common.home_encode(self.hovered_item.abs_filename)
  local w, h = style.font:get_width(text), style.font:get_height(text)

  local x, y = self.tooltip.x + tooltip_offset, self.tooltip.y + tooltip_offset
  w, h = w + style.padding.x, h + style.padding.y

  if x + w > core.root_view.root_node.size.x then -- check if we can span right
    x = x - w -- span left instead
  end

  local bx, by = x - tooltip_border, y - tooltip_border
  local bw, bh = w + 2 * tooltip_border, h + 2 * tooltip_border
  renderer.draw_rect(bx, by, bw, bh, replace_alpha(style.text, self.tooltip.alpha))
  renderer.draw_rect(x, y, w, h, replace_alpha(style.background2, self.tooltip.alpha))
  common.draw_text(style.font, replace_alpha(style.text, self.tooltip.alpha), text, "center", x, y, w, h)
end


function TreeView:get_item_icon(item, active, hovered)
  local character = "f"
  if item.type == "dir" then
    character = item.expanded and "D" or "d"
  end
  local font = style.icon_font
  local color = style.text
  if active or hovered then
    color = style.accent
  end
  return character, font, color
end

function TreeView:get_item_text(item, active, hovered)
  local text = item.name
  local font = style.font
  local color = style.text
  if active or hovered then
    color = style.accent
  end
  return text, font, color
end


function TreeView:draw_item_text(item, active, hovered, x, y, w, h)
  local item_text, item_font, item_color = self:get_item_text(item, active, hovered)
  common.draw_text(item_font, item_color, item_text, nil, x, y, 0, h)
end


function TreeView:draw_item_icon(item, active, hovered, x, y, w, h)
  local icon_char, icon_font, icon_color = self:get_item_icon(item, active, hovered)
  common.draw_text(icon_font, icon_color, icon_char, nil, x, y, 0, h)
  return self.item_icon_width + self.item_text_spacing
end


function TreeView:draw_item_body(item, active, hovered, x, y, w, h)
    x = x + self:draw_item_icon(item, active, hovered, x, y, w, h)
    self:draw_item_text(item, active, hovered, x, y, w, h)
end


function TreeView:draw_item_chevron(item, active, hovered, x, y, w, h)
  if item.type == "dir" then
    local chevron_icon = item.expanded and "-" or "+"
    local chevron_color = hovered and style.accent or style.text
    common.draw_text(style.icon_font, chevron_color, chevron_icon, nil, x, y, 0, h)
  end
  return style.padding.x
end


function TreeView:draw_item_background(item, active, hovered, x, y, w, h)
  if hovered then
    local hover_color = { table.unpack(style.line_highlight) }
    hover_color[4] = 160
    renderer.draw_rect(x, y, w, h, hover_color)
  elseif active then
    renderer.draw_rect(x, y, w, h, style.line_highlight)
  end
end


function TreeView:draw_item(item, active, hovered, x, y, w, h)
  self:draw_item_background(item, active, hovered, x, y, w, h)

  x = x + item.depth * style.padding.x + style.padding.x
  x = x + self:draw_item_chevron(item, active, hovered, x, y, w, h)

  self:draw_item_body(item, active, hovered, x, y, w, h)
end


function TreeView:draw()
  if not self.visible then return end
  self:draw_background(style.background2)
  local _y, _h = self.position.y, self.size.y

  local doc = core.active_view.doc
  local active_filename = doc and system.absolute_path(doc.filename or "")

  for item, x,y,w,h in self:each_item() do
    if y + h >= _y and y < _y + _h then
      self:draw_item(item,
        item == self.selected_item,
        item == self.hovered_item,
        x, y, w, h)
    end
  end

  self:draw_scrollbar()
  if self.hovered_item and self.tooltip.x and self.tooltip.alpha > 0 then
    core.root_view:defer_draw(self.draw_tooltip, self)
  end
end


function TreeView:get_parent(item)
  local parent_path = common.dirname(item.abs_filename)
  if not parent_path then return end
  for it, _, y in self:each_item() do
    if it.abs_filename == parent_path then
      return it, y
    end
  end
end


function TreeView:get_item(item, where)
  local last_item, last_x, last_y, last_w, last_h
  local stop = false

  for it, x, y, w, h in self:each_item() do
    if not item and where >= 0 then
      return it, x, y, w, h
    end
    if item == it then
      if where < 0 and last_item then
        break
      elseif where == 0 or (where < 0 and not last_item) then
        return it, x, y, w, h
      end
      stop = true
    elseif stop then
      item = it
      return it, x, y, w, h
    end
    last_item, last_x, last_y, last_w, last_h = it, x, y, w, h
  end
  return last_item, last_x, last_y, last_w, last_h
end

function TreeView:get_next(item)
  return self:get_item(item, 1)
end

function TreeView:get_previous(item)
  return self:get_item(item, -1)
end


function TreeView:toggle_expand(toggle)
  local item = self.selected_item

  if not item then return end

  if item.type == "dir" then
    if type(toggle) == "boolean" then
      item.expanded = toggle
    else
      item.expanded = not item.expanded
    end
    local hovered_dir = core.project_dir_by_name(item.dir_name)
    if hovered_dir and hovered_dir.files_limit then
      core.update_project_subdir(hovered_dir, item.depth == 0 and "" or item.filename, item.expanded)
    end
  end
end


-- init
local view = TreeView()
local node = core.root_view:get_active_node()
view.node = node:split("left", view, {x = true}, true)

-- The toolbarview plugin is special because it is plugged inside
-- a treeview pane which is itelf provided in a plugin.
-- We therefore break the usual plugin's logic that would require each
-- plugin to be independent of each other. In addition it is not the
-- plugin module that plug itself in the active node but it is plugged here
-- in the treeview node.
local toolbar_view = nil
local toolbar_plugin, ToolbarView = pcall(require, "plugins.toolbarview")
if config.plugins.toolbarview ~= false and toolbar_plugin then
  toolbar_view = ToolbarView()
  view.node:split("down", toolbar_view, {y = true})
  local min_toolbar_width = toolbar_view:get_min_width()
  view:set_target_size("x", math.max(config.plugins.treeview.size, min_toolbar_width))
  command.add(nil, {
    ["toolbar:toggle"] = function()
      toolbar_view:toggle_visible()
    end,
  })
end

-- Add a context menu to the treeview
local menu = ContextMenu()

local on_view_mouse_pressed = RootView.on_view_mouse_pressed
local on_mouse_moved = RootView.on_mouse_moved
local root_view_update = RootView.update
local root_view_draw = RootView.draw

function RootView:on_mouse_moved(...)
  if menu:on_mouse_moved(...) then return end
  on_mouse_moved(self, ...)
end

function RootView.on_view_mouse_pressed(button, x, y, clicks)
  -- We give the priority to the menu to process mouse pressed events.
  if button == "right" then
    view.tooltip.alpha = 0
    view.tooltip.x, view.tooltip.y = nil, nil
  end
  local handled = menu:on_mouse_pressed(button, x, y, clicks)
  return handled or on_view_mouse_pressed(button, x, y, clicks)
end

function RootView:update(...)
  root_view_update(self, ...)
  menu:update()
end

function RootView:draw(...)
  root_view_draw(self, ...)
  menu:draw()
end

local on_quit_project = core.on_quit_project
function core.on_quit_project()
  view.cache = {}
  on_quit_project()
end

local function is_project_folder(path)
  for _,dir in pairs(core.project_directories) do
    if dir.name == path then
      return true
    end
  end
  return false
end

local function is_primary_project_folder(path)
  return core.project_dir == path
end

menu:register(function() return view.hovered_item end, {
  { text = "Open in System", command = "treeview:open-in-system" },
  ContextMenu.DIVIDER
})

menu:register(
  function()
    return view.hovered_item
      and not is_project_folder(view.hovered_item.abs_filename)
  end,
  {
    { text = "Rename", command = "treeview:rename" },
    { text = "Delete", command = "treeview:delete" },
  }
)

menu:register(
  function()
    return view.hovered_item and view.hovered_item.type == "dir"
  end,
  {
    { text = "New File", command = "treeview:new-file" },
    { text = "New Folder", command = "treeview:new-folder" },
  }
)

menu:register(
  function()
    return view.hovered_item
      and not is_primary_project_folder(view.hovered_item.abs_filename)
      and is_project_folder(view.hovered_item.abs_filename)
  end,
  {
    { text = "Remove directory", command = "treeview:remove-project-directory" },
  }
)

local previous_view = nil

-- Register the TreeView commands and keymap
command.add(nil, {
  ["treeview:toggle"] = function()
    view.visible = not view.visible
  end,

  ["treeview:toggle-focus"] = function()
    if not core.active_view:is(TreeView) then
      if core.active_view:is(CommandView) then
        previous_view = core.last_active_view
      else
        previous_view = core.active_view
      end
      if not previous_view then
        previous_view = core.root_view:get_primary_node().active_view
      end
      core.set_active_view(view)
      if not view.selected_item then
        for it, _, y in view:each_item() do
          view:set_selection(it, y)
          break
        end
      end

    else
      core.set_active_view(
        previous_view or core.root_view:get_primary_node().active_view
      )
    end
  end
})

command.add(TreeView, {
  ["treeview:next"] = function()
    local item, _, item_y = view:get_next(view.selected_item)
    view:set_selection(item, item_y)
  end,

  ["treeview:previous"] = function()
    local item, _, item_y = view:get_previous(view.selected_item)
    view:set_selection(item, item_y)
  end,

  ["treeview:open"] = function()
    local item = view.selected_item
    if not item then return end
    if item.type == "dir" then
      view:toggle_expand()
    else
      core.try(function()
        if core.last_active_view and core.active_view == view then
          core.set_active_view(core.last_active_view)
        end
        local doc_filename = core.normalize_to_project_dir(item.abs_filename)
        core.root_view:open_doc(core.open_doc(doc_filename))
      end)
    end
  end,

  ["treeview:deselect"] = function()
    view.selected_item = nil
  end,

  ["treeview:select"] = function()
    view:set_selection(view.hovered_item)
  end,

  ["treeview:select-and-open"] = function()
    if view.hovered_item then
      view:set_selection(view.hovered_item)
      command.perform "treeview:open"
    end
  end,

  ["treeview:collapse"] = function()
    if view.selected_item then
      if view.selected_item.type == "dir" and view.selected_item.expanded then
        view:toggle_expand(false)
      else
        local parent_item, y = view:get_parent(view.selected_item)
        if parent_item then
          view:set_selection(parent_item, y)
        end
      end
    end
  end,

  ["treeview:expand"] = function()
    local item = view.selected_item
    if not item or item.type ~= "dir" then return end

    if item.expanded then
      local next_item, _, next_y = view:get_next(item)
      if next_item.depth > item.depth then
        view:set_selection(next_item, next_y)
      end
    else
      view:toggle_expand(true)
    end
  end,
})


local function treeitem() return view.hovered_item or view.selected_item end


command.add(
  function()
    local item = treeitem()
    return item ~= nil
      and (
        core.active_view == view or core.active_view == menu
        or (view.toolbar and core.active_view == view.toolbar)
        -- sometimes the context menu is shown on top of statusbar
        or core.active_view == core.status_view
      ), item
  end, {
  ["treeview:delete"] = function(item)
    local filename = item.abs_filename
    local relfilename = item.filename
    if item.dir_name ~= core.project_dir then
      -- add secondary project dirs names to the file path to show
      relfilename = common.basename(item.dir_name) .. PATHSEP .. relfilename
    end
    local file_info = system.get_file_info(filename)
    local file_type = file_info.type == "dir" and "Directory" or "File"
    -- Ask before deleting
    local opt = {
      { font = style.font, text = "Yes", default_yes = true },
      { font = style.font, text = "No" , default_no = true }
    }
    core.nag_view:show(
      string.format("Delete %s", file_type),
      string.format(
        "Are you sure you want to delete the %s?\n%s: %s",
        file_type:lower(), file_type, relfilename
      ),
      opt,
      function(item)
        if item.text == "Yes" then
          if file_info.type == "dir" then
            local deleted, error, path = common.rm(filename, true)
            if not deleted then
              core.error("Error: %s - \"%s\" ", error, path)
              return
            end
          else
            local removed, error = os.remove(filename)
            if not removed then
              core.error("Error: %s - \"%s\"", error, filename)
              return
            end
          end
          core.log("Deleted \"%s\"", filename)
        end
      end
    )
  end,

  ["treeview:rename"] = function(item)
    local old_filename = item.filename
    local old_abs_filename = item.abs_filename
    core.command_view:enter("Rename", {
      text = old_filename,
      submit = function(filename)
        local abs_filename = filename
        if not common.is_absolute_path(filename) then
          abs_filename = item.dir_name .. PATHSEP .. filename
        end
        local res, err = os.rename(old_abs_filename, abs_filename)
        if res then -- successfully renamed
          for _, doc in ipairs(core.docs) do
            if doc.abs_filename and old_abs_filename == doc.abs_filename then
              doc:set_filename(filename, abs_filename) -- make doc point to the new filename
              doc:reset_syntax()
              break -- only first needed
            end
          end
          core.log("Renamed \"%s\" to \"%s\"", old_filename, filename)
        else
          core.error("Error while renaming \"%s\" to \"%s\": %s", old_abs_filename, abs_filename, err)
        end
      end,
      suggest = function(text)
        return common.path_suggest(text, item.dir_name)
      end
    })
  end,

  ["treeview:new-file"] = function(item)
    local text
    if not is_project_folder(item.abs_filename) then
      text = item.filename .. PATHSEP
    end
    core.command_view:enter("Filename", {
      text = text,
      submit = function(filename)
        local doc_filename = item.dir_name .. PATHSEP .. filename
        core.log(doc_filename)
        local file = io.open(doc_filename, "a+")
        file:write("")
        file:close()
        core.root_view:open_doc(core.open_doc(doc_filename))
        core.log("Created %s", doc_filename)
      end,
      suggest = function(text)
        return common.path_suggest(text, item.dir_name)
      end
    })
  end,

  ["treeview:new-folder"] = function(item)
    local text
    if not is_project_folder(item.abs_filename) then
      text = item.filename .. PATHSEP
    end
    core.command_view:enter("Folder Name", {
      text = text,
      submit = function(filename)
        local dir_path = item.dir_name .. PATHSEP .. filename
        common.mkdirp(dir_path)
        core.log("Created %s", dir_path)
      end,
      suggest = function(text)
        return common.path_suggest(text, item.dir_name)
      end
    })
  end,

  ["treeview:open-in-system"] = function(item)
    if PLATFORM == "Windows" then
      system.exec(string.format("start \"\" %q", item.abs_filename))
    elseif string.find(PLATFORM, "Mac") then
      system.exec(string.format("open %q", item.abs_filename))
    elseif PLATFORM == "Linux" or string.find(PLATFORM, "BSD") then
      system.exec(string.format("xdg-open %q", item.abs_filename))
    end
  end
})

local projectsearch = pcall(require, "plugins.projectsearch")
if projectsearch then
  menu:register(function()
    return view.hovered_item and view.hovered_item.type == "dir"
  end, { 
    { text = "Find in directory", command = "treeview:search-in-directory" } 
  })
  command.add(function()
    return view.hovered_item and view.hovered_item.type == "dir"
  end, {
    ["treeview:search-in-directory"] = function(item)
      command.perform("project-search:find", view.hovered_item.abs_filename)
    end
  })
end

command.add(function()
    local item = treeitem()
    return item
           and not is_primary_project_folder(item.abs_filename)
           and is_project_folder(item.abs_filename), item
  end, {
  ["treeview:remove-project-directory"] = function(item)
    core.remove_project_directory(item.dir_name)
  end,
})


keymap.add {
  ["ctrl+\\"]     = "treeview:toggle",
  ["up"]          = "treeview:previous",
  ["down"]        = "treeview:next",
  ["left"]        = "treeview:collapse",
  ["right"]       = "treeview:expand",
  ["return"]      = "treeview:open",
  ["escape"]      = "treeview:deselect",
  ["delete"]      = "treeview:delete",
  ["ctrl+return"] = "treeview:new-folder",
  ["lclick"]      = "treeview:select-and-open",
  ["mclick"]      = "treeview:select",
  ["ctrl+lclick"] = "treeview:new-folder"
}

-- The config specification used by gui generators
config.plugins.treeview.config_spec = {
  name = "Treeview",
  {
    label = "Size",
    description = "Default treeview width.",
    path = "size",
    type = "number",
    default = toolbar_view and math.ceil(toolbar_view:get_min_width() / SCALE)
      or 200 * SCALE,
    min = toolbar_view and toolbar_view:get_min_width() / SCALE
      or 200 * SCALE,
    get_value = function(value)
      return value / SCALE
    end,
    set_value = function(value)
      return value * SCALE
    end,
    on_apply = function(value)
      view:set_target_size("x", math.max(
        value, toolbar_view and toolbar_view:get_min_width() or 200 * SCALE
      ))
    end
  },
  {
    label = "Hide on Startup",
    description = "Show or hide the treeview on startup.",
    path = "visible",
    type = "toggle",
    default = false,
    on_apply = function(value)
      view.visible = not value
    end
  }
}

-- Return the treeview with toolbar and contextmenu to allow
-- user or plugin modifications
view.toolbar = toolbar_view
view.contextmenu = menu

return view
-- mod-version:3
local common = require "core.common"
local config = require "core.config"
local command = require "core.command"
local Doc = require "core.doc"

---@class config.plugins.trimwhitespace
---@field enabled boolean
---@field trim_empty_end_lines boolean
config.plugins.trimwhitespace = common.merge({
  enabled = true,
  trim_empty_end_lines = false,
  config_spec = {
    name = "Trim Whitespace",
    {
      label = "Enabled",
      description = "Disable or enable the trimming of white spaces by default.",
      path = "enabled",
      type = "toggle",
      default = true
    },
    {
      label = "Trim Empty End Lines",
      description = "Remove any empty new lines at the end of documents.",
      path = "trim_empty_end_lines",
      type = "toggle",
      default = false
    }
  }
}, config.plugins.trimwhitespace)

---@class plugins.trimwhitespace
local trimwhitespace = {}

---Disable whitespace trimming for a specific document.
---@param doc core.doc
function trimwhitespace.disable(doc)
  doc.disable_trim_whitespace = true
end

---Re-enable whitespace trimming if previously disabled.
---@param doc core.doc
function trimwhitespace.enable(doc)
  doc.disable_trim_whitespace = nil
end

---Perform whitespace trimming in all lines of a document except the
---line where the caret is currently positioned.
---@param doc core.doc
function trimwhitespace.trim(doc)
  local cline, ccol = doc:get_selection()
  for i = 1, #doc.lines do
    local old_text = doc:get_text(i, 1, i, math.huge)
    local new_text = old_text:gsub("%s*$", "")

    -- don't remove whitespace which would cause the caret to reposition
    if cline == i and ccol > #new_text then
      new_text = old_text:sub(1, ccol - 1)
    end

    if old_text ~= new_text then
      doc:insert(i, 1, new_text)
      doc:remove(i, #new_text + 1, i, math.huge)
    end
  end
end

---Removes all empty new lines at the end of the document.
---@param doc core.doc
---@param raw_remove? boolean Perform the removal not registering to undo stack
function trimwhitespace.trim_empty_end_lines(doc, raw_remove)
  for _=#doc.lines, 1, -1 do
    local l = #doc.lines
    if l > 1 and doc.lines[l] == "\n" then
      local current_line = doc:get_selection()
      if current_line == l then
        doc:set_selection(l-1, math.huge, l-1, math.huge)
      end
      if not raw_remove then
        doc:remove(l-1, math.huge, l, math.huge)
      else
        table.remove(doc.lines, l)
      end
    else
      break
    end
  end
end


command.add("core.docview", {
  ["trim-whitespace:trim-trailing-whitespace"] = function(dv)
    trimwhitespace.trim(dv.doc)
  end,

  ["trim-whitespace:trim-empty-end-lines"] = function(dv)
    trimwhitespace.trim_empty_end_lines(dv.doc)
  end,
})


local doc_save = Doc.save
Doc.save = function(self, ...)
  if
    config.plugins.trimwhitespace.enabled
    and
    not self.disable_trim_whitespace
  then
    trimwhitespace.trim(self)
    if config.plugins.trimwhitespace.trim_empty_end_lines then
      trimwhitespace.trim_empty_end_lines(self)
    end
  end
  doc_save(self, ...)
end


return trimwhitespace
-- mod-version:3
local core = require "core"
local common = require "core.common"
local DocView = require "core.docview"
local LogView = require "core.logview"


local function workspace_files_for(project_dir)
  local basename = common.basename(project_dir)
  local workspace_dir = USERDIR .. PATHSEP .. "ws"
  local info_wsdir = system.get_file_info(workspace_dir)
  if not info_wsdir then
    local ok, err = system.mkdir(workspace_dir)
    if not ok then
      error("cannot create workspace directory: \"" .. err .. "\"")
    end
  end
  return coroutine.wrap(function()
    local files = system.list_dir(workspace_dir) or {}
    local n = #basename
    for _, file in ipairs(files) do
      if file:sub(1, n) == basename then
        local id = tonumber(file:sub(n + 1):match("^-(%d+)$"))
        if id then
          coroutine.yield(workspace_dir .. PATHSEP .. file, id)
        end
      end
    end
  end)
end


local function consume_workspace_file(project_dir)
  for filename, id in workspace_files_for(project_dir) do
    local load_f = loadfile(filename)
    local workspace = load_f and load_f()
    if workspace and workspace.path == project_dir then
      os.remove(filename)
      return workspace
    end
  end
end


local function get_workspace_filename(project_dir)
  local id_list = {}
  for filename, id in workspace_files_for(project_dir) do
    id_list[id] = true
  end
  local id = 1
  while id_list[id] do
    id = id + 1
  end
  local basename = common.basename(project_dir)
  return USERDIR .. PATHSEP .. "ws" .. PATHSEP .. basename .. "-" .. tostring(id)
end


local function has_no_locked_children(node)
  if node.locked then return false end
  if node.type == "leaf" then return true end
  return has_no_locked_children(node.a) and has_no_locked_children(node.b)
end


local function get_unlocked_root(node)
  if node.type == "leaf" then
    return not node.locked and node
  end
  if has_no_locked_children(node) then
    return node
  end
  return get_unlocked_root(node.a) or get_unlocked_root(node.b)
end


local function save_view(view)
  local mt = getmetatable(view)
  if mt == DocView then
    return {
      type = "doc",
      active = (core.active_view == view),
      filename = view.doc.filename,
      selection = { view.doc:get_selection() },
      scroll = { x = view.scroll.to.x, y = view.scroll.to.y },
      text = not view.doc.filename and view.doc:get_text(1, 1, math.huge, math.huge)
    }
  end
  if mt == LogView then return end
  for name, mod in pairs(package.loaded) do
    if mod == mt then
      return {
        type = "view",
        active = (core.active_view == view),
        module = name,
        scroll = { x = view.scroll.to.x, y = view.scroll.to.y, to = { x = view.scroll.to.x, y = view.scroll.to.y } },
      }
    end
  end
end


local function load_view(t)
  if t.type == "doc" then
    local dv
    if not t.filename then
      -- document not associated to a file
      dv = DocView(core.open_doc())
      if t.text then dv.doc:insert(1, 1, t.text) end
    else
      -- we have a filename, try to read the file
      local ok, doc = pcall(core.open_doc, t.filename)
      if ok then
        dv = DocView(doc)
      end
    end
    -- doc view "dv" can be nil here if the filename associated to the document
    -- cannot be read.
    if dv and dv.doc then
      dv.doc:set_selection(table.unpack(t.selection))
      dv.last_line1, dv.last_col1, dv.last_line2, dv.last_col2 = dv.doc:get_selection()
      dv.scroll.x, dv.scroll.to.x = t.scroll.x, t.scroll.x
      dv.scroll.y, dv.scroll.to.y = t.scroll.y, t.scroll.y
    end
    return dv
  end
  return require(t.module)()
end


local function save_node(node)
  local res = {}
  res.type = node.type
  if node.type == "leaf" then
    res.views = {}
    for _, view in ipairs(node.views) do
      local t = save_view(view)
      if t then
        table.insert(res.views, t)
        if node.active_view == view then
          res.active_view = #res.views
        end
      end
    end
  else
    res.divider = node.divider
    res.a = save_node(node.a)
    res.b = save_node(node.b)
  end
  return res
end


local function load_node(node, t)
  if t.type == "leaf" then
    local res
    local active_view
    for i, v in ipairs(t.views) do
      local view = load_view(v)
      if view then
        if v.active then res = view end
        node:add_view(view)
        if t.active_view == i then
          active_view = view
        end
        if not view:is(DocView) then
          view.scroll = v.scroll	
        end
      end
    end
    if active_view then
      node:set_active_view(active_view)
    end
    return res
  else
    node:split(t.type == "hsplit" and "right" or "down")
    node.divider = t.divider
    local res1 = load_node(node.a, t.a)
    local res2 = load_node(node.b, t.b)
    return res1 or res2
  end
end


local function save_directories()
  local project_dir = core.project_dir
  local dir_list = {}
  for i = 2, #core.project_directories do
    dir_list[#dir_list + 1] = common.relative_path(project_dir, core.project_directories[i].name)
  end
  return dir_list
end


local function save_workspace()
  local root = get_unlocked_root(core.root_view.root_node)
  local workspace_filename = get_workspace_filename(core.project_dir)
  local fp = io.open(workspace_filename, "w")
  if fp then
    local node_text = common.serialize(save_node(root))
    local dir_text = common.serialize(save_directories())
    fp:write(string.format("return { path = %q, documents = %s, directories = %s }\n", core.project_dir, node_text, dir_text))
    fp:close()
  end
end


local function load_workspace()
  local workspace = consume_workspace_file(core.project_dir)
  if workspace then
    local root = get_unlocked_root(core.root_view.root_node)
    local active_view = load_node(root, workspace.documents)
    if active_view then
      core.set_active_view(active_view)
    end
    for i, dir_name in ipairs(workspace.directories) do
      core.add_project_directory(system.absolute_path(dir_name))
    end
  end
end


local run = core.run

function core.run(...)
  if #core.docs == 0 then
    core.try(load_workspace)

    local on_quit_project = core.on_quit_project
    function core.on_quit_project()
      core.try(save_workspace)
      on_quit_project()
    end

    local on_enter_project = core.on_enter_project
    function core.on_enter_project(new_dir)
      on_enter_project(new_dir)
      core.try(load_workspace)
    end
  end

  core.run = run
  return core.run(...)
end
